{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createVirtualAstObject = void 0;\n\nconst json_1 = require(\"../../json\");\n\nfunction createVirtualAstObject(root, options = {}) {\n  var _a;\n\n  const reporter = (path, target, oldValue, newValue) => {\n    if (!options.listener) {\n      return;\n    }\n\n    if (oldValue === newValue || JSON.stringify(oldValue) === JSON.stringify(newValue)) {\n      // same value\n      return;\n    }\n\n    if (Array.isArray(target)) {\n      // For arrays we remove the index and update the entire value as keeping\n      // track of changes by indices can be rather complex.\n      options.listener(path.slice(0, -1), target);\n    } else {\n      options.listener(path, newValue);\n    }\n  };\n\n  return create(Array.isArray(root) ? [...root] : { ...root\n  }, [], reporter, new Set(options.exclude), ((_a = options.include) === null || _a === void 0 ? void 0 : _a.length) ? new Set(options.include) : undefined);\n}\n\nexports.createVirtualAstObject = createVirtualAstObject;\n\nfunction create(obj, path, reporter, excluded = new Set(), included) {\n  return new Proxy(obj, {\n    getOwnPropertyDescriptor(target, p) {\n      if (excluded.has(p) || included && !included.has(p)) {\n        return undefined;\n      }\n\n      return Reflect.getOwnPropertyDescriptor(target, p);\n    },\n\n    has(target, p) {\n      if (typeof p === 'symbol' || excluded.has(p)) {\n        return false;\n      }\n\n      return Reflect.has(target, p);\n    },\n\n    get(target, p) {\n      if (excluded.has(p) || included && !included.has(p)) {\n        return undefined;\n      }\n\n      const value = Reflect.get(target, p);\n\n      if (typeof p === 'symbol') {\n        return value;\n      }\n\n      if ((0, json_1.isJsonObject)(value) && !(value instanceof Map) || Array.isArray(value)) {\n        return create(value, [...path, p], reporter);\n      } else {\n        return value;\n      }\n    },\n\n    set(target, p, value) {\n      var _a, _b;\n\n      if (excluded.has(p) || included && !included.has(p)) {\n        return false;\n      }\n\n      if (value === undefined) {\n        // setting to undefined is equivalent to a delete.\n        return (_b = (_a = this.deleteProperty) === null || _a === void 0 ? void 0 : _a.call(this, target, p)) !== null && _b !== void 0 ? _b : false;\n      }\n\n      if (typeof p === 'symbol') {\n        return Reflect.set(target, p, value);\n      }\n\n      const existingValue = getCurrentValue(target, p);\n\n      if (Reflect.set(target, p, value)) {\n        reporter([...path, p], target, existingValue, value);\n        return true;\n      }\n\n      return false;\n    },\n\n    deleteProperty(target, p) {\n      if (excluded.has(p)) {\n        return false;\n      }\n\n      if (typeof p === 'symbol') {\n        return Reflect.deleteProperty(target, p);\n      }\n\n      const existingValue = getCurrentValue(target, p);\n\n      if (Reflect.deleteProperty(target, p)) {\n        reporter([...path, p], target, existingValue, undefined);\n        return true;\n      }\n\n      return true;\n    },\n\n    defineProperty(target, p, attributes) {\n      if (typeof p === 'symbol') {\n        return Reflect.defineProperty(target, p, attributes);\n      }\n\n      return false;\n    },\n\n    ownKeys(target) {\n      return Reflect.ownKeys(target).filter(p => !excluded.has(p) && (!included || included.has(p)));\n    }\n\n  });\n}\n\nfunction getCurrentValue(target, property) {\n  if (Array.isArray(target) && isFinite(+property)) {\n    return target[+property];\n  }\n\n  if (target && property in target) {\n    return target[property];\n  }\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}