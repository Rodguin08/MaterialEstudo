{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst events = require('events');\n\nconst util = require('util');\n\nconst contentPath = require('./path');\n\nconst fixOwner = require('../util/fix-owner');\n\nconst fs = require('@npmcli/fs');\n\nconst moveFile = require('../util/move-file');\n\nconst Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst Flush = require('minipass-flush');\n\nconst path = require('path');\n\nconst rimraf = util.promisify(require('rimraf'));\n\nconst ssri = require('ssri');\n\nconst uniqueFilename = require('unique-filename');\n\nconst fsm = require('fs-minipass');\n\nmodule.exports = write;\n\nfunction write(_x, _x2) {\n  return _write.apply(this, arguments);\n}\n\nfunction _write() {\n  _write = _asyncToGenerator(function* (cache, data, opts = {}) {\n    const {\n      algorithms,\n      size,\n      integrity\n    } = opts;\n\n    if (algorithms && algorithms.length > 1) {\n      throw new Error('opts.algorithms only supports a single algorithm for now');\n    }\n\n    if (typeof size === 'number' && data.length !== size) {\n      throw sizeError(size, data.length);\n    }\n\n    const sri = ssri.fromData(data, algorithms ? {\n      algorithms\n    } : {});\n\n    if (integrity && !ssri.checkData(data, integrity, opts)) {\n      throw checksumError(integrity, sri);\n    }\n\n    const tmp = yield makeTmp(cache, opts);\n\n    try {\n      yield fs.writeFile(tmp.target, data, {\n        flag: 'wx'\n      });\n      yield moveToDestination(tmp, cache, sri, opts);\n      return {\n        integrity: sri,\n        size: data.length\n      };\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _write.apply(this, arguments);\n}\n\nmodule.exports.stream = writeStream; // writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\n\nclass CacacheWriteStream extends Flush {\n  constructor(cache, opts) {\n    super();\n    this.opts = opts;\n    this.cache = cache;\n    this.inputStream = new Minipass();\n    this.inputStream.on('error', er => this.emit('error', er));\n    this.inputStream.on('drain', () => this.emit('drain'));\n    this.handleContentP = null;\n  }\n\n  write(chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n    }\n\n    return this.inputStream.write(chunk, encoding, cb);\n  }\n\n  flush(cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty');\n        e.code = 'ENODATA'; // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n\n        return Promise.reject(e).catch(cb);\n      } // eslint-disable-next-line promise/catch-or-return\n\n\n      this.handleContentP.then(res => {\n        res.integrity && this.emit('integrity', res.integrity); // eslint-disable-next-line promise/always-return\n\n        res.size !== null && this.emit('size', res.size);\n        cb();\n      }, er => cb(er));\n    });\n  }\n\n}\n\nfunction writeStream(cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts);\n}\n\nfunction handleContent(_x3, _x4, _x5) {\n  return _handleContent.apply(this, arguments);\n}\n\nfunction _handleContent() {\n  _handleContent = _asyncToGenerator(function* (inputStream, cache, opts) {\n    const tmp = yield makeTmp(cache, opts);\n\n    try {\n      const res = yield pipeToTmp(inputStream, cache, tmp.target, opts);\n      yield moveToDestination(tmp, cache, res.integrity, opts);\n      return res;\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _handleContent.apply(this, arguments);\n}\n\nfunction pipeToTmp(_x6, _x7, _x8, _x9) {\n  return _pipeToTmp.apply(this, arguments);\n}\n\nfunction _pipeToTmp() {\n  _pipeToTmp = _asyncToGenerator(function* (inputStream, cache, tmpTarget, opts) {\n    const outStream = new fsm.WriteStream(tmpTarget, {\n      flags: 'wx'\n    });\n\n    if (opts.integrityEmitter) {\n      // we need to create these all simultaneously since they can fire in any order\n      const [integrity, size] = yield Promise.all([events.once(opts.integrityEmitter, 'integrity').then(res => res[0]), events.once(opts.integrityEmitter, 'size').then(res => res[0]), new Pipeline(inputStream, outStream).promise()]);\n      return {\n        integrity,\n        size\n      };\n    }\n\n    let integrity;\n    let size;\n    const hashStream = ssri.integrityStream({\n      integrity: opts.integrity,\n      algorithms: opts.algorithms,\n      size: opts.size\n    });\n    hashStream.on('integrity', i => {\n      integrity = i;\n    });\n    hashStream.on('size', s => {\n      size = s;\n    });\n    const pipeline = new Pipeline(inputStream, hashStream, outStream);\n    yield pipeline.promise();\n    return {\n      integrity,\n      size\n    };\n  });\n  return _pipeToTmp.apply(this, arguments);\n}\n\nfunction makeTmp(_x10, _x11) {\n  return _makeTmp.apply(this, arguments);\n}\n\nfunction _makeTmp() {\n  _makeTmp = _asyncToGenerator(function* (cache, opts) {\n    const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n    yield fixOwner.mkdirfix(cache, path.dirname(tmpTarget));\n    return {\n      target: tmpTarget,\n      moved: false\n    };\n  });\n  return _makeTmp.apply(this, arguments);\n}\n\nfunction moveToDestination(_x12, _x13, _x14, _x15) {\n  return _moveToDestination.apply(this, arguments);\n}\n\nfunction _moveToDestination() {\n  _moveToDestination = _asyncToGenerator(function* (tmp, cache, sri, opts) {\n    const destination = contentPath(cache, sri);\n    const destDir = path.dirname(destination);\n    yield fixOwner.mkdirfix(cache, destDir);\n    yield moveFile(tmp.target, destination);\n    tmp.moved = true;\n    yield fixOwner.chownr(cache, destination);\n  });\n  return _moveToDestination.apply(this, arguments);\n}\n\nfunction sizeError(expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\n\nfunction checksumError(expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":null,"metadata":{},"sourceType":"script"}