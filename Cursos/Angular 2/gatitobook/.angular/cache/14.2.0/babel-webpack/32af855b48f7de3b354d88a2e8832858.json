{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar t = require(\"assert\");\n\nclass e extends Error {\n  constructor(t) {\n    super(t || \"yargs error\"), this.name = \"YError\", Error.captureStackTrace && Error.captureStackTrace(this, e);\n  }\n\n}\n\nlet s,\n    i = [];\n\nfunction n(t, o, a, h) {\n  s = h;\n  let l = {};\n\n  if (Object.prototype.hasOwnProperty.call(t, \"extends\")) {\n    if (\"string\" != typeof t.extends) return l;\n    const r = /\\.json|\\..*rc$/.test(t.extends);\n    let h = null;\n    if (r) h = function (t, e) {\n      return s.path.resolve(t, e);\n    }(o, t.extends);else try {\n      h = require.resolve(t.extends);\n    } catch (e) {\n      return t;\n    }\n    !function (t) {\n      if (i.indexOf(t) > -1) throw new e(`Circular extended configurations: '${t}'.`);\n    }(h), i.push(h), l = r ? JSON.parse(s.readFileSync(h, \"utf8\")) : require(t.extends), delete t.extends, l = n(l, s.path.dirname(h), a, s);\n  }\n\n  return i = [], a ? r(l, t) : Object.assign({}, l, t);\n}\n\nfunction r(t, e) {\n  const s = {};\n\n  function i(t) {\n    return t && \"object\" == typeof t && !Array.isArray(t);\n  }\n\n  Object.assign(s, t);\n\n  for (const n of Object.keys(e)) i(e[n]) && i(s[n]) ? s[n] = r(t[n], e[n]) : s[n] = e[n];\n\n  return s;\n}\n\nfunction o(t) {\n  const e = t.replace(/\\s{2,}/g, \" \").split(/\\s+(?![^[]*]|[^<]*>)/),\n        s = /\\.*[\\][<>]/g,\n        i = e.shift();\n  if (!i) throw new Error(`No command found in: ${t}`);\n  const n = {\n    cmd: i.replace(s, \"\"),\n    demanded: [],\n    optional: []\n  };\n  return e.forEach((t, i) => {\n    let r = !1;\n    t = t.replace(/\\s/g, \"\"), /\\.+[\\]>]/.test(t) && i === e.length - 1 && (r = !0), /^\\[/.test(t) ? n.optional.push({\n      cmd: t.replace(s, \"\").split(\"|\"),\n      variadic: r\n    }) : n.demanded.push({\n      cmd: t.replace(s, \"\").split(\"|\"),\n      variadic: r\n    });\n  }), n;\n}\n\nconst a = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\"];\n\nfunction h(t, s, i) {\n  try {\n    let n = 0;\n    const [r, a, h] = \"object\" == typeof t ? [{\n      demanded: [],\n      optional: []\n    }, t, s] : [o(`cmd ${t}`), s, i],\n          f = [].slice.call(a);\n\n    for (; f.length && void 0 === f[f.length - 1];) f.pop();\n\n    const d = h || f.length;\n    if (d < r.demanded.length) throw new e(`Not enough arguments provided. Expected ${r.demanded.length} but received ${f.length}.`);\n    const u = r.demanded.length + r.optional.length;\n    if (d > u) throw new e(`Too many arguments provided. Expected max ${u} but received ${d}.`);\n    r.demanded.forEach(t => {\n      const e = l(f.shift());\n      0 === t.cmd.filter(t => t === e || \"*\" === t).length && c(e, t.cmd, n), n += 1;\n    }), r.optional.forEach(t => {\n      if (0 === f.length) return;\n      const e = l(f.shift());\n      0 === t.cmd.filter(t => t === e || \"*\" === t).length && c(e, t.cmd, n), n += 1;\n    });\n  } catch (t) {\n    console.warn(t.stack);\n  }\n}\n\nfunction l(t) {\n  return Array.isArray(t) ? \"array\" : null === t ? \"null\" : typeof t;\n}\n\nfunction c(t, s, i) {\n  throw new e(`Invalid ${a[i] || \"manyith\"} argument. Expected ${s.join(\" or \")} but received ${t}.`);\n}\n\nfunction f(t) {\n  return !!t && !!t.then && \"function\" == typeof t.then;\n}\n\nfunction d(t, e, s, i) {\n  s.assert.notStrictEqual(t, e, i);\n}\n\nfunction u(t, e) {\n  e.assert.strictEqual(typeof t, \"string\");\n}\n\nfunction p(t) {\n  return Object.keys(t);\n}\n\nfunction g(t = {}, e = () => !0) {\n  const s = {};\n  return p(t).forEach(i => {\n    e(i, t[i]) && (s[i] = t[i]);\n  }), s;\n}\n\nfunction m() {\n  return process.versions.electron && !process.defaultApp ? 0 : 1;\n}\n\nfunction y() {\n  return process.argv[m()];\n}\n\nvar b = Object.freeze({\n  __proto__: null,\n  hideBin: function (t) {\n    return t.slice(m() + 1);\n  },\n  getProcessArgvBin: y\n});\n\nfunction v(t, e, s, i) {\n  if (\"a\" === s && !i) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (\"function\" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return \"m\" === s ? i : \"a\" === s ? i.call(t) : i ? i.value : e.get(t);\n}\n\nfunction O(t, e, s, i, n) {\n  if (\"m\" === i) throw new TypeError(\"Private method is not writable\");\n  if (\"a\" === i && !n) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (\"function\" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return \"a\" === i ? n.call(t, s) : n ? n.value = s : e.set(t, s), s;\n}\n\nclass w {\n  constructor(t) {\n    this.globalMiddleware = [], this.frozens = [], this.yargs = t;\n  }\n\n  addMiddleware(t, e, s = !0, i = !1) {\n    if (h(\"<array|function> [boolean] [boolean] [boolean]\", [t, e, s], arguments.length), Array.isArray(t)) {\n      for (let i = 0; i < t.length; i++) {\n        if (\"function\" != typeof t[i]) throw Error(\"middleware must be a function\");\n        const n = t[i];\n        n.applyBeforeValidation = e, n.global = s;\n      }\n\n      Array.prototype.push.apply(this.globalMiddleware, t);\n    } else if (\"function\" == typeof t) {\n      const n = t;\n      n.applyBeforeValidation = e, n.global = s, n.mutates = i, this.globalMiddleware.push(t);\n    }\n\n    return this.yargs;\n  }\n\n  addCoerceMiddleware(t, e) {\n    const s = this.yargs.getAliases();\n    return this.globalMiddleware = this.globalMiddleware.filter(t => {\n      const i = [...(s[e] || []), e];\n      return !t.option || !i.includes(t.option);\n    }), t.option = e, this.addMiddleware(t, !0, !0, !0);\n  }\n\n  getMiddleware() {\n    return this.globalMiddleware;\n  }\n\n  freeze() {\n    this.frozens.push([...this.globalMiddleware]);\n  }\n\n  unfreeze() {\n    const t = this.frozens.pop();\n    void 0 !== t && (this.globalMiddleware = t);\n  }\n\n  reset() {\n    this.globalMiddleware = this.globalMiddleware.filter(t => t.global);\n  }\n\n}\n\nfunction C(t, e, s, i) {\n  return s.reduce((t, s) => {\n    if (s.applyBeforeValidation !== i) return t;\n\n    if (s.mutates) {\n      if (s.applied) return t;\n      s.applied = !0;\n    }\n\n    if (f(t)) return t.then(t => Promise.all([t, s(t, e)])).then(([t, e]) => Object.assign(t, e));\n    {\n      const i = s(t, e);\n      return f(i) ? i.then(e => Object.assign(t, e)) : Object.assign(t, i);\n    }\n  }, t);\n}\n\nfunction j(t, e, s = t => {\n  throw t;\n}) {\n  try {\n    const s = \"function\" == typeof t ? t() : t;\n    return f(s) ? s.then(t => e(t)) : e(s);\n  } catch (t) {\n    return s(t);\n  }\n}\n\nconst _ = /(^\\*)|(^\\$0)/;\n\nclass M {\n  constructor(t, e, s, i) {\n    this.requireCache = new Set(), this.handlers = {}, this.aliasMap = {}, this.frozens = [], this.shim = i, this.usage = t, this.globalMiddleware = s, this.validation = e;\n  }\n\n  addDirectory(t, e, s, i) {\n    \"boolean\" != typeof (i = i || {}).recurse && (i.recurse = !1), Array.isArray(i.extensions) || (i.extensions = [\"js\"]);\n    const n = \"function\" == typeof i.visit ? i.visit : t => t;\n    i.visit = (t, e, s) => {\n      const i = n(t, e, s);\n\n      if (i) {\n        if (this.requireCache.has(e)) return i;\n        this.requireCache.add(e), this.addHandler(i);\n      }\n\n      return i;\n    }, this.shim.requireDirectory({\n      require: e,\n      filename: s\n    }, t, i);\n  }\n\n  addHandler(t, e, s, i, n, r) {\n    let a = [];\n\n    const h = function (t) {\n      return t ? t.map(t => (t.applyBeforeValidation = !1, t)) : [];\n    }(n);\n\n    if (i = i || (() => {}), Array.isArray(t)) {\n      if (function (t) {\n        return t.every(t => \"string\" == typeof t);\n      }(t)) [t, ...a] = t;else for (const e of t) this.addHandler(e);\n    } else {\n      if (function (t) {\n        return \"object\" == typeof t && !Array.isArray(t);\n      }(t)) {\n        let e = Array.isArray(t.command) || \"string\" == typeof t.command ? t.command : this.moduleName(t);\n        return t.aliases && (e = [].concat(e).concat(t.aliases)), void this.addHandler(e, this.extractDesc(t), t.builder, t.handler, t.middlewares, t.deprecated);\n      }\n\n      if (k(s)) return void this.addHandler([t].concat(a), e, s.builder, s.handler, s.middlewares, s.deprecated);\n    }\n\n    if (\"string\" == typeof t) {\n      const n = o(t);\n      a = a.map(t => o(t).cmd);\n      let l = !1;\n      const c = [n.cmd].concat(a).filter(t => !_.test(t) || (l = !0, !1));\n      0 === c.length && l && c.push(\"$0\"), l && (n.cmd = c[0], a = c.slice(1), t = t.replace(_, n.cmd)), a.forEach(t => {\n        this.aliasMap[t] = n.cmd;\n      }), !1 !== e && this.usage.command(t, e, l, a, r), this.handlers[n.cmd] = {\n        original: t,\n        description: e,\n        handler: i,\n        builder: s || {},\n        middlewares: h,\n        deprecated: r,\n        demanded: n.demanded,\n        optional: n.optional\n      }, l && (this.defaultCommand = this.handlers[n.cmd]);\n    }\n  }\n\n  getCommandHandlers() {\n    return this.handlers;\n  }\n\n  getCommands() {\n    return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));\n  }\n\n  hasDefaultCommand() {\n    return !!this.defaultCommand;\n  }\n\n  runCommand(t, e, s, i, n, r) {\n    const o = this.handlers[t] || this.handlers[this.aliasMap[t]] || this.defaultCommand,\n          a = e.getInternalMethods().getContext(),\n          h = a.commands.slice(),\n          l = !t;\n    t && (a.commands.push(t), a.fullCommands.push(o.original));\n    const c = this.applyBuilderUpdateUsageAndParse(l, o, e, s.aliases, h, i, n, r);\n    return f(c) ? c.then(t => this.applyMiddlewareAndGetResult(l, o, t.innerArgv, a, n, t.aliases, e)) : this.applyMiddlewareAndGetResult(l, o, c.innerArgv, a, n, c.aliases, e);\n  }\n\n  applyBuilderUpdateUsageAndParse(t, e, s, i, n, r, o, a) {\n    const h = e.builder;\n    let l = s;\n\n    if (x(h)) {\n      const c = h(s.getInternalMethods().reset(i), a);\n      if (f(c)) return c.then(i => {\n        var a;\n        return l = (a = i) && \"function\" == typeof a.getInternalMethods ? i : s, this.parseAndUpdateUsage(t, e, l, n, r, o);\n      });\n    } else (function (t) {\n      return \"object\" == typeof t;\n    })(h) && (l = s.getInternalMethods().reset(i), Object.keys(e.builder).forEach(t => {\n      l.option(t, h[t]);\n    }));\n\n    return this.parseAndUpdateUsage(t, e, l, n, r, o);\n  }\n\n  parseAndUpdateUsage(t, e, s, i, n, r) {\n    t && s.getInternalMethods().getUsageInstance().unfreeze(!0), this.shouldUpdateUsage(s) && s.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(i, e), e.description);\n    const o = s.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, !0, n, r);\n    return f(o) ? o.then(t => ({\n      aliases: s.parsed.aliases,\n      innerArgv: t\n    })) : {\n      aliases: s.parsed.aliases,\n      innerArgv: o\n    };\n  }\n\n  shouldUpdateUsage(t) {\n    return !t.getInternalMethods().getUsageInstance().getUsageDisabled() && 0 === t.getInternalMethods().getUsageInstance().getUsage().length;\n  }\n\n  usageFromParentCommandsCommandHandler(t, e) {\n    const s = _.test(e.original) ? e.original.replace(_, \"\").trim() : e.original,\n          i = t.filter(t => !_.test(t));\n    return i.push(s), `$0 ${i.join(\" \")}`;\n  }\n\n  handleValidationAndGetResult(t, e, s, i, n, r, o, a) {\n    if (!r.getInternalMethods().getHasOutput()) {\n      const e = r.getInternalMethods().runValidation(n, a, r.parsed.error, t);\n      s = j(s, t => (e(t), t));\n    }\n\n    if (e.handler && !r.getInternalMethods().getHasOutput()) {\n      r.getInternalMethods().setHasOutput();\n      const i = !!r.getOptions().configuration[\"populate--\"];\n      r.getInternalMethods().postProcess(s, i, !1, !1), s = j(s = C(s, r, o, !1), t => {\n        const s = e.handler(t);\n        return f(s) ? s.then(() => t) : t;\n      }), t || r.getInternalMethods().getUsageInstance().cacheHelpMessage(), f(s) && !r.getInternalMethods().hasParseCallback() && s.catch(t => {\n        try {\n          r.getInternalMethods().getUsageInstance().fail(null, t);\n        } catch (t) {}\n      });\n    }\n\n    return t || (i.commands.pop(), i.fullCommands.pop()), s;\n  }\n\n  applyMiddlewareAndGetResult(t, e, s, i, n, r, o) {\n    let a = {};\n    if (n) return s;\n    o.getInternalMethods().getHasOutput() || (a = this.populatePositionals(e, s, i, o));\n    const h = this.globalMiddleware.getMiddleware().slice(0).concat(e.middlewares),\n          l = C(s, o, h, !0);\n    return f(l) ? l.then(s => this.handleValidationAndGetResult(t, e, s, i, r, o, h, a)) : this.handleValidationAndGetResult(t, e, l, i, r, o, h, a);\n  }\n\n  populatePositionals(t, e, s, i) {\n    e._ = e._.slice(s.commands.length);\n    const n = t.demanded.slice(0),\n          r = t.optional.slice(0),\n          o = {};\n\n    for (this.validation.positionalCount(n.length, e._.length); n.length;) {\n      const t = n.shift();\n      this.populatePositional(t, e, o);\n    }\n\n    for (; r.length;) {\n      const t = r.shift();\n      this.populatePositional(t, e, o);\n    }\n\n    return e._ = s.commands.concat(e._.map(t => \"\" + t)), this.postProcessPositionals(e, o, this.cmdToParseOptions(t.original), i), o;\n  }\n\n  populatePositional(t, e, s) {\n    const i = t.cmd[0];\n    t.variadic ? s[i] = e._.splice(0).map(String) : e._.length && (s[i] = [String(e._.shift())]);\n  }\n\n  cmdToParseOptions(t) {\n    const e = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    },\n          s = o(t);\n    return s.demanded.forEach(t => {\n      const [s, ...i] = t.cmd;\n      t.variadic && (e.array.push(s), e.default[s] = []), e.alias[s] = i, e.demand[s] = !0;\n    }), s.optional.forEach(t => {\n      const [s, ...i] = t.cmd;\n      t.variadic && (e.array.push(s), e.default[s] = []), e.alias[s] = i;\n    }), e;\n  }\n\n  postProcessPositionals(t, e, s, i) {\n    const n = Object.assign({}, i.getOptions());\n    n.default = Object.assign(s.default, n.default);\n\n    for (const t of Object.keys(s.alias)) n.alias[t] = (n.alias[t] || []).concat(s.alias[t]);\n\n    n.array = n.array.concat(s.array), n.config = {};\n    const r = [];\n    if (Object.keys(e).forEach(t => {\n      e[t].map(e => {\n        n.configuration[\"unknown-options-as-args\"] && (n.key[t] = !0), r.push(`--${t}`), r.push(e);\n      });\n    }), !r.length) return;\n    const o = Object.assign({}, n.configuration, {\n      \"populate--\": !1\n    }),\n          a = this.shim.Parser.detailed(r, Object.assign({}, n, {\n      configuration: o\n    }));\n    if (a.error) i.getInternalMethods().getUsageInstance().fail(a.error.message, a.error);else {\n      const s = Object.keys(e);\n      Object.keys(e).forEach(t => {\n        s.push(...a.aliases[t]);\n      }), Object.keys(a.argv).forEach(n => {\n        s.includes(n) && (e[n] || (e[n] = a.argv[n]), !this.isInConfigs(i, n) && !this.isDefaulted(i, n) && Object.prototype.hasOwnProperty.call(t, n) && Object.prototype.hasOwnProperty.call(a.argv, n) && (Array.isArray(t[n]) || Array.isArray(a.argv[n])) ? t[n] = [].concat(t[n], a.argv[n]) : t[n] = a.argv[n]);\n      });\n    }\n  }\n\n  isDefaulted(t, e) {\n    const {\n      default: s\n    } = t.getOptions();\n    return Object.prototype.hasOwnProperty.call(s, e) || Object.prototype.hasOwnProperty.call(s, this.shim.Parser.camelCase(e));\n  }\n\n  isInConfigs(t, e) {\n    const {\n      configObjects: s\n    } = t.getOptions();\n    return s.some(t => Object.prototype.hasOwnProperty.call(t, e)) || s.some(t => Object.prototype.hasOwnProperty.call(t, this.shim.Parser.camelCase(e)));\n  }\n\n  runDefaultBuilderOn(t) {\n    if (!this.defaultCommand) return;\n\n    if (this.shouldUpdateUsage(t)) {\n      const e = _.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\\]<>]*/, \"$0 \");\n      t.getInternalMethods().getUsageInstance().usage(e, this.defaultCommand.description);\n    }\n\n    const e = this.defaultCommand.builder;\n    if (x(e)) return e(t, !0);\n    k(e) || Object.keys(e).forEach(s => {\n      t.option(s, e[s]);\n    });\n  }\n\n  moduleName(t) {\n    const e = function (t) {\n      if (\"undefined\" == typeof require) return null;\n\n      for (let e, s = 0, i = Object.keys(require.cache); s < i.length; s++) if (e = require.cache[i[s]], e.exports === t) return e;\n\n      return null;\n    }(t);\n\n    if (!e) throw new Error(`No command name given for module: ${this.shim.inspect(t)}`);\n    return this.commandFromFilename(e.filename);\n  }\n\n  commandFromFilename(t) {\n    return this.shim.path.basename(t, this.shim.path.extname(t));\n  }\n\n  extractDesc({\n    describe: t,\n    description: e,\n    desc: s\n  }) {\n    for (const i of [t, e, s]) {\n      if (\"string\" == typeof i || !1 === i) return i;\n      d(i, !0, this.shim);\n    }\n\n    return !1;\n  }\n\n  freeze() {\n    this.frozens.push({\n      handlers: this.handlers,\n      aliasMap: this.aliasMap,\n      defaultCommand: this.defaultCommand\n    });\n  }\n\n  unfreeze() {\n    const t = this.frozens.pop();\n    d(t, void 0, this.shim), ({\n      handlers: this.handlers,\n      aliasMap: this.aliasMap,\n      defaultCommand: this.defaultCommand\n    } = t);\n  }\n\n  reset() {\n    return this.handlers = {}, this.aliasMap = {}, this.defaultCommand = void 0, this.requireCache = new Set(), this;\n  }\n\n}\n\nfunction k(t) {\n  return \"object\" == typeof t && !!t.builder && \"function\" == typeof t.handler;\n}\n\nfunction x(t) {\n  return \"function\" == typeof t;\n}\n\nfunction E(t) {\n  \"undefined\" != typeof process && [process.stdout, process.stderr].forEach(e => {\n    const s = e;\n    s._handle && s.isTTY && \"function\" == typeof s._handle.setBlocking && s._handle.setBlocking(t);\n  });\n}\n\nfunction A(t) {\n  return \"boolean\" == typeof t;\n}\n\nfunction P(t, s) {\n  const i = s.y18n.__,\n        n = {},\n        r = [];\n\n  n.failFn = function (t) {\n    r.push(t);\n  };\n\n  let o = null,\n      a = null,\n      h = !0;\n\n  n.showHelpOnFail = function (e = !0, s) {\n    const [i, r] = \"string\" == typeof e ? [!0, e] : [e, s];\n    return t.getInternalMethods().isGlobalContext() && (a = r), o = r, h = i, n;\n  };\n\n  let l = !1;\n\n  n.fail = function (s, i) {\n    const c = t.getInternalMethods().getLoggerInstance();\n\n    if (!r.length) {\n      if (t.getExitProcess() && E(!0), !l) {\n        l = !0, h && (t.showHelp(\"error\"), c.error()), (s || i) && c.error(s || i);\n        const e = o || a;\n        e && ((s || i) && c.error(\"\"), c.error(e));\n      }\n\n      if (i = i || new e(s), t.getExitProcess()) return t.exit(1);\n      if (t.getInternalMethods().hasParseCallback()) return t.exit(1, i);\n      throw i;\n    }\n\n    for (let t = r.length - 1; t >= 0; --t) {\n      const e = r[t];\n\n      if (A(e)) {\n        if (i) throw i;\n        if (s) throw Error(s);\n      } else e(s, i, n);\n    }\n  };\n\n  let c = [],\n      f = !1;\n  n.usage = (t, e) => null === t ? (f = !0, c = [], n) : (f = !1, c.push([t, e || \"\"]), n), n.getUsage = () => c, n.getUsageDisabled = () => f, n.getPositionalGroupName = () => i(\"Positionals:\");\n  let d = [];\n\n  n.example = (t, e) => {\n    d.push([t, e || \"\"]);\n  };\n\n  let u = [];\n  n.command = function (t, e, s, i, n = !1) {\n    s && (u = u.map(t => (t[2] = !1, t))), u.push([t, e || \"\", s, i, n]);\n  }, n.getCommands = () => u;\n  let p = {};\n  n.describe = function (t, e) {\n    Array.isArray(t) ? t.forEach(t => {\n      n.describe(t, e);\n    }) : \"object\" == typeof t ? Object.keys(t).forEach(e => {\n      n.describe(e, t[e]);\n    }) : p[t] = e;\n  }, n.getDescriptions = () => p;\n  let m = [];\n\n  n.epilog = t => {\n    m.push(t);\n  };\n\n  let y,\n      b = !1;\n\n  function v() {\n    return b || (y = function () {\n      const t = 80;\n      return s.process.stdColumns ? Math.min(t, s.process.stdColumns) : t;\n    }(), b = !0), y;\n  }\n\n  n.wrap = t => {\n    b = !0, y = t;\n  };\n\n  const O = \"__yargsString__:\";\n\n  function w(t, e, i) {\n    let n = 0;\n    return Array.isArray(t) || (t = Object.values(t).map(t => [t])), t.forEach(t => {\n      n = Math.max(s.stringWidth(i ? `${i} ${I(t[0])}` : I(t[0])) + $(t[0]), n);\n    }), e && (n = Math.min(n, parseInt((.5 * e).toString(), 10))), n;\n  }\n\n  let C;\n\n  function j(e) {\n    return t.getOptions().hiddenOptions.indexOf(e) < 0 || t.parsed.argv[t.getOptions().showHiddenOpt];\n  }\n\n  function _(t, e) {\n    let s = `[${i(\"default:\")} `;\n    if (void 0 === t && !e) return null;\n    if (e) s += e;else switch (typeof t) {\n      case \"string\":\n        s += `\"${t}\"`;\n        break;\n\n      case \"object\":\n        s += JSON.stringify(t);\n        break;\n\n      default:\n        s += t;\n    }\n    return `${s}]`;\n  }\n\n  n.deferY18nLookup = t => O + t, n.help = function () {\n    if (C) return C;\n    !function () {\n      const e = t.getDemandedOptions(),\n            s = t.getOptions();\n      (Object.keys(s.alias) || []).forEach(i => {\n        s.alias[i].forEach(r => {\n          p[r] && n.describe(i, p[r]), r in e && t.demandOption(i, e[r]), s.boolean.includes(r) && t.boolean(i), s.count.includes(r) && t.count(i), s.string.includes(r) && t.string(i), s.normalize.includes(r) && t.normalize(i), s.array.includes(r) && t.array(i), s.number.includes(r) && t.number(i);\n        });\n      });\n    }();\n    const e = t.customScriptName ? t.$0 : s.path.basename(t.$0),\n          r = t.getDemandedOptions(),\n          o = t.getDemandedCommands(),\n          a = t.getDeprecatedOptions(),\n          h = t.getGroups(),\n          l = t.getOptions();\n    let g = [];\n    g = g.concat(Object.keys(p)), g = g.concat(Object.keys(r)), g = g.concat(Object.keys(o)), g = g.concat(Object.keys(l.default)), g = g.filter(j), g = Object.keys(g.reduce((t, e) => (\"_\" !== e && (t[e] = !0), t), {}));\n    const y = v(),\n          b = s.cliui({\n      width: y,\n      wrap: !!y\n    });\n    if (!f) if (c.length) c.forEach(t => {\n      b.div({\n        text: `${t[0].replace(/\\$0/g, e)}`\n      }), t[1] && b.div({\n        text: `${t[1]}`,\n        padding: [1, 0, 0, 0]\n      });\n    }), b.div();else if (u.length) {\n      let t = null;\n      t = o._ ? `${e} <${i(\"command\")}>\\n` : `${e} [${i(\"command\")}]\\n`, b.div(`${t}`);\n    }\n\n    if (u.length > 1 || 1 === u.length && !u[0][2]) {\n      b.div(i(\"Commands:\"));\n      const s = t.getInternalMethods().getContext(),\n            n = s.commands.length ? `${s.commands.join(\" \")} ` : \"\";\n      !0 === t.getInternalMethods().getParserConfiguration()[\"sort-commands\"] && (u = u.sort((t, e) => t[0].localeCompare(e[0])));\n      const r = e ? `${e} ` : \"\";\n      u.forEach(t => {\n        const s = `${r}${n}${t[0].replace(/^\\$0 ?/, \"\")}`;\n        b.span({\n          text: s,\n          padding: [0, 2, 0, 2],\n          width: w(u, y, `${e}${n}`) + 4\n        }, {\n          text: t[1]\n        });\n        const o = [];\n        t[2] && o.push(`[${i(\"default\")}]`), t[3] && t[3].length && o.push(`[${i(\"aliases:\")} ${t[3].join(\", \")}]`), t[4] && (\"string\" == typeof t[4] ? o.push(`[${i(\"deprecated: %s\", t[4])}]`) : o.push(`[${i(\"deprecated\")}]`)), o.length ? b.div({\n          text: o.join(\" \"),\n          padding: [0, 0, 0, 2],\n          align: \"right\"\n        }) : b.div();\n      }), b.div();\n    }\n\n    const M = (Object.keys(l.alias) || []).concat(Object.keys(t.parsed.newAliases) || []);\n    g = g.filter(e => !t.parsed.newAliases[e] && M.every(t => -1 === (l.alias[t] || []).indexOf(e)));\n    const k = i(\"Options:\");\n    h[k] || (h[k] = []), function (t, e, s, i) {\n      let n = [],\n          r = null;\n      Object.keys(s).forEach(t => {\n        n = n.concat(s[t]);\n      }), t.forEach(t => {\n        r = [t].concat(e[t]), r.some(t => -1 !== n.indexOf(t)) || s[i].push(t);\n      });\n    }(g, l.alias, h, k);\n\n    const x = t => /^--/.test(I(t)),\n          E = Object.keys(h).filter(t => h[t].length > 0).map(t => ({\n      groupName: t,\n      normalizedKeys: h[t].filter(j).map(t => {\n        if (M.includes(t)) return t;\n\n        for (let e, s = 0; void 0 !== (e = M[s]); s++) if ((l.alias[e] || []).includes(t)) return e;\n\n        return t;\n      })\n    })).filter(({\n      normalizedKeys: t\n    }) => t.length > 0).map(({\n      groupName: t,\n      normalizedKeys: e\n    }) => {\n      const s = e.reduce((e, s) => (e[s] = [s].concat(l.alias[s] || []).map(e => t === n.getPositionalGroupName() ? e : (/^[0-9]$/.test(e) ? l.boolean.includes(s) ? \"-\" : \"--\" : e.length > 1 ? \"--\" : \"-\") + e).sort((t, e) => x(t) === x(e) ? 0 : x(t) ? 1 : -1).join(\", \"), e), {});\n      return {\n        groupName: t,\n        normalizedKeys: e,\n        switches: s\n      };\n    });\n\n    if (E.filter(({\n      groupName: t\n    }) => t !== n.getPositionalGroupName()).some(({\n      normalizedKeys: t,\n      switches: e\n    }) => !t.every(t => x(e[t]))) && E.filter(({\n      groupName: t\n    }) => t !== n.getPositionalGroupName()).forEach(({\n      normalizedKeys: t,\n      switches: e\n    }) => {\n      t.forEach(t => {\n        var s, i;\n        x(e[t]) && (e[t] = (s = e[t], i = \"-x, \".length, S(s) ? {\n          text: s.text,\n          indentation: s.indentation + i\n        } : {\n          text: s,\n          indentation: i\n        }));\n      });\n    }), E.forEach(({\n      groupName: t,\n      normalizedKeys: e,\n      switches: s\n    }) => {\n      b.div(t), e.forEach(t => {\n        const e = s[t];\n        let o = p[t] || \"\",\n            h = null;\n        o.includes(O) && (o = i(o.substring(O.length))), l.boolean.includes(t) && (h = `[${i(\"boolean\")}]`), l.count.includes(t) && (h = `[${i(\"count\")}]`), l.string.includes(t) && (h = `[${i(\"string\")}]`), l.normalize.includes(t) && (h = `[${i(\"string\")}]`), l.array.includes(t) && (h = `[${i(\"array\")}]`), l.number.includes(t) && (h = `[${i(\"number\")}]`);\n        const c = [t in a ? (f = a[t], \"string\" == typeof f ? `[${i(\"deprecated: %s\", f)}]` : `[${i(\"deprecated\")}]`) : null, h, t in r ? `[${i(\"required\")}]` : null, l.choices && l.choices[t] ? `[${i(\"choices:\")} ${n.stringifiedValues(l.choices[t])}]` : null, _(l.default[t], l.defaultDescription[t])].filter(Boolean).join(\" \");\n        var f;\n        b.span({\n          text: I(e),\n          padding: [0, 2, 0, 2 + $(e)],\n          width: w(s, y) + 4\n        }, o), c ? b.div({\n          text: c,\n          padding: [0, 0, 0, 2],\n          align: \"right\"\n        }) : b.div();\n      }), b.div();\n    }), d.length && (b.div(i(\"Examples:\")), d.forEach(t => {\n      t[0] = t[0].replace(/\\$0/g, e);\n    }), d.forEach(t => {\n      \"\" === t[1] ? b.div({\n        text: t[0],\n        padding: [0, 2, 0, 2]\n      }) : b.div({\n        text: t[0],\n        padding: [0, 2, 0, 2],\n        width: w(d, y) + 4\n      }, {\n        text: t[1]\n      });\n    }), b.div()), m.length > 0) {\n      const t = m.map(t => t.replace(/\\$0/g, e)).join(\"\\n\");\n      b.div(`${t}\\n`);\n    }\n\n    return b.toString().replace(/\\s*$/, \"\");\n  }, n.cacheHelpMessage = function () {\n    C = this.help();\n  }, n.clearCachedHelpMessage = function () {\n    C = void 0;\n  }, n.hasCachedHelpMessage = function () {\n    return !!C;\n  }, n.showHelp = e => {\n    const s = t.getInternalMethods().getLoggerInstance();\n    e || (e = \"error\");\n    (\"function\" == typeof e ? e : s[e])(n.help());\n  }, n.functionDescription = t => [\"(\", t.name ? s.Parser.decamelize(t.name, \"-\") : i(\"generated-value\"), \")\"].join(\"\"), n.stringifiedValues = function (t, e) {\n    let s = \"\";\n    const i = e || \", \",\n          n = [].concat(t);\n    return t && n.length ? (n.forEach(t => {\n      s.length && (s += i), s += JSON.stringify(t);\n    }), s) : s;\n  };\n  let M = null;\n  n.version = t => {\n    M = t;\n  }, n.showVersion = e => {\n    const s = t.getInternalMethods().getLoggerInstance();\n    e || (e = \"error\");\n    (\"function\" == typeof e ? e : s[e])(M);\n  }, n.reset = function (t) {\n    return o = null, l = !1, c = [], f = !1, m = [], d = [], u = [], p = g(p, e => !t[e]), n;\n  };\n  const k = [];\n  return n.freeze = function () {\n    k.push({\n      failMessage: o,\n      failureOutput: l,\n      usages: c,\n      usageDisabled: f,\n      epilogs: m,\n      examples: d,\n      commands: u,\n      descriptions: p\n    });\n  }, n.unfreeze = function (t = !1) {\n    const e = k.pop();\n    e && (t ? (p = { ...e.descriptions,\n      ...p\n    }, u = [...e.commands, ...u], c = [...e.usages, ...c], d = [...e.examples, ...d], m = [...e.epilogs, ...m]) : ({\n      failMessage: o,\n      failureOutput: l,\n      usages: c,\n      usageDisabled: f,\n      epilogs: m,\n      examples: d,\n      commands: u,\n      descriptions: p\n    } = e));\n  }, n;\n}\n\nfunction S(t) {\n  return \"object\" == typeof t;\n}\n\nfunction $(t) {\n  return S(t) ? t.indentation : 0;\n}\n\nfunction I(t) {\n  return S(t) ? t.text : t;\n}\n\nclass D {\n  constructor(t, e, s, i) {\n    var n, r, o;\n    this.yargs = t, this.usage = e, this.command = s, this.shim = i, this.completionKey = \"get-yargs-completions\", this.aliases = null, this.customCompletionFunction = null, this.indexAfterLastReset = 0, this.zshShell = null !== (o = (null === (n = this.shim.getEnv(\"SHELL\")) || void 0 === n ? void 0 : n.includes(\"zsh\")) || (null === (r = this.shim.getEnv(\"ZSH_NAME\")) || void 0 === r ? void 0 : r.includes(\"zsh\"))) && void 0 !== o && o;\n  }\n\n  defaultCompletion(t, e, s, i) {\n    const n = this.command.getCommandHandlers();\n\n    for (let e = 0, s = t.length; e < s; ++e) if (n[t[e]] && n[t[e]].builder) {\n      const s = n[t[e]].builder;\n\n      if (x(s)) {\n        this.indexAfterLastReset = e + 1;\n        const t = this.yargs.getInternalMethods().reset();\n        return s(t, !0), t.argv;\n      }\n    }\n\n    const r = [];\n    this.commandCompletions(r, t, s), this.optionCompletions(r, t, e, s), this.choicesFromOptionsCompletions(r, t, e, s), this.choicesFromPositionalsCompletions(r, t, e, s), i(null, r);\n  }\n\n  commandCompletions(t, e, s) {\n    const i = this.yargs.getInternalMethods().getContext().commands;\n    s.match(/^-/) || i[i.length - 1] === s || this.previousArgHasChoices(e) || this.usage.getCommands().forEach(s => {\n      const i = o(s[0]).cmd;\n      if (-1 === e.indexOf(i)) if (this.zshShell) {\n        const e = s[1] || \"\";\n        t.push(i.replace(/:/g, \"\\\\:\") + \":\" + e);\n      } else t.push(i);\n    });\n  }\n\n  optionCompletions(t, e, s, i) {\n    if ((i.match(/^-/) || \"\" === i && 0 === t.length) && !this.previousArgHasChoices(e)) {\n      const s = this.yargs.getOptions(),\n            n = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];\n      Object.keys(s.key).forEach(r => {\n        const o = !!s.configuration[\"boolean-negation\"] && s.boolean.includes(r);\n        n.includes(r) || s.hiddenOptions.includes(r) || this.argsContainKey(e, r, o) || (this.completeOptionKey(r, t, i), o && s.default[r] && this.completeOptionKey(`no-${r}`, t, i));\n      });\n    }\n  }\n\n  choicesFromOptionsCompletions(t, e, s, i) {\n    if (this.previousArgHasChoices(e)) {\n      const s = this.getPreviousArgChoices(e);\n      s && s.length > 0 && t.push(...s.map(t => t.replace(/:/g, \"\\\\:\")));\n    }\n  }\n\n  choicesFromPositionalsCompletions(t, e, s, i) {\n    if (\"\" === i && t.length > 0 && this.previousArgHasChoices(e)) return;\n    const n = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [],\n          r = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1),\n          o = n[s._.length - r - 1];\n    if (!o) return;\n    const a = this.yargs.getOptions().choices[o] || [];\n\n    for (const e of a) e.startsWith(i) && t.push(e.replace(/:/g, \"\\\\:\"));\n  }\n\n  getPreviousArgChoices(t) {\n    if (t.length < 1) return;\n    let e = t[t.length - 1],\n        s = \"\";\n    if (!e.startsWith(\"-\") && t.length > 1 && (s = e, e = t[t.length - 2]), !e.startsWith(\"-\")) return;\n    const i = e.replace(/^-+/, \"\"),\n          n = this.yargs.getOptions(),\n          r = [i, ...(this.yargs.getAliases()[i] || [])];\n    let o;\n\n    for (const t of r) if (Object.prototype.hasOwnProperty.call(n.key, t) && Array.isArray(n.choices[t])) {\n      o = n.choices[t];\n      break;\n    }\n\n    return o ? o.filter(t => !s || t.startsWith(s)) : void 0;\n  }\n\n  previousArgHasChoices(t) {\n    const e = this.getPreviousArgChoices(t);\n    return void 0 !== e && e.length > 0;\n  }\n\n  argsContainKey(t, e, s) {\n    const i = e => -1 !== t.indexOf((/^[^0-9]$/.test(e) ? \"-\" : \"--\") + e);\n\n    if (i(e)) return !0;\n    if (s && i(`no-${e}`)) return !0;\n    if (this.aliases) for (const t of this.aliases[e]) if (i(t)) return !0;\n    return !1;\n  }\n\n  completeOptionKey(t, e, s) {\n    const i = this.usage.getDescriptions(),\n          n = !/^--/.test(s) && (t => /^[^0-9]$/.test(t))(t) ? \"-\" : \"--\";\n\n    if (this.zshShell) {\n      const s = i[t] || \"\";\n      e.push(n + `${t.replace(/:/g, \"\\\\:\")}:${s.replace(\"__yargsString__:\", \"\")}`);\n    } else e.push(n + t);\n  }\n\n  customCompletion(t, e, s, i) {\n    if (d(this.customCompletionFunction, null, this.shim), this.customCompletionFunction.length < 3) {\n      const t = this.customCompletionFunction(s, e);\n      return f(t) ? t.then(t => {\n        this.shim.process.nextTick(() => {\n          i(null, t);\n        });\n      }).catch(t => {\n        this.shim.process.nextTick(() => {\n          i(t, void 0);\n        });\n      }) : i(null, t);\n    }\n\n    return function (t) {\n      return t.length > 3;\n    }(this.customCompletionFunction) ? this.customCompletionFunction(s, e, (n = i) => this.defaultCompletion(t, e, s, n), t => {\n      i(null, t);\n    }) : this.customCompletionFunction(s, e, t => {\n      i(null, t);\n    });\n  }\n\n  getCompletion(t, e) {\n    const s = t.length ? t[t.length - 1] : \"\",\n          i = this.yargs.parse(t, !0),\n          n = this.customCompletionFunction ? i => this.customCompletion(t, i, s, e) : i => this.defaultCompletion(t, i, s, e);\n    return f(i) ? i.then(n) : n(i);\n  }\n\n  generateCompletionScript(t, e) {\n    let s = this.zshShell ? '#compdef {{app_name}}\\n###-begin-{{app_name}}-completions-###\\n#\\n# yargs command completion script\\n#\\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\\n#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.\\n#\\n_{{app_name}}_yargs_completions()\\n{\\n  local reply\\n  local si=$IFS\\n  IFS=$\\'\\n\\' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"${words[@]}\"))\\n  IFS=$si\\n  _describe \\'values\\' reply\\n}\\ncompdef _{{app_name}}_yargs_completions {{app_name}}\\n###-end-{{app_name}}-completions-###\\n' : '###-begin-{{app_name}}-completions-###\\n#\\n# yargs command completion script\\n#\\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\\n#\\n_{{app_name}}_yargs_completions()\\n{\\n    local cur_word args type_list\\n\\n    cur_word=\"${COMP_WORDS[COMP_CWORD]}\"\\n    args=(\"${COMP_WORDS[@]}\")\\n\\n    # ask yargs to generate completions.\\n    type_list=$({{app_path}} --get-yargs-completions \"${args[@]}\")\\n\\n    COMPREPLY=( $(compgen -W \"${type_list}\" -- ${cur_word}) )\\n\\n    # if no match was found, fall back to filename completion\\n    if [ ${#COMPREPLY[@]} -eq 0 ]; then\\n      COMPREPLY=()\\n    fi\\n\\n    return 0\\n}\\ncomplete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}\\n###-end-{{app_name}}-completions-###\\n';\n    const i = this.shim.path.basename(t);\n    return t.match(/\\.js$/) && (t = `./${t}`), s = s.replace(/{{app_name}}/g, i), s = s.replace(/{{completion_command}}/g, e), s.replace(/{{app_path}}/g, t);\n  }\n\n  registerFunction(t) {\n    this.customCompletionFunction = t;\n  }\n\n  setParsed(t) {\n    this.aliases = t.aliases;\n  }\n\n}\n\nfunction N(t, e) {\n  if (0 === t.length) return e.length;\n  if (0 === e.length) return t.length;\n  const s = [];\n  let i, n;\n\n  for (i = 0; i <= e.length; i++) s[i] = [i];\n\n  for (n = 0; n <= t.length; n++) s[0][n] = n;\n\n  for (i = 1; i <= e.length; i++) for (n = 1; n <= t.length; n++) e.charAt(i - 1) === t.charAt(n - 1) ? s[i][n] = s[i - 1][n - 1] : i > 1 && n > 1 && e.charAt(i - 2) === t.charAt(n - 1) && e.charAt(i - 1) === t.charAt(n - 2) ? s[i][n] = s[i - 2][n - 2] + 1 : s[i][n] = Math.min(s[i - 1][n - 1] + 1, Math.min(s[i][n - 1] + 1, s[i - 1][n] + 1));\n\n  return s[e.length][t.length];\n}\n\nconst H = [\"$0\", \"--\", \"_\"];\nvar z, q, W, F, U, L, V, G, R, T, K, B, Y, J, Z, X, Q, tt, et, st, it, nt, rt, ot, at, ht, lt, ct, ft, dt, ut, pt, gt, mt;\n\nconst yt = Symbol(\"copyDoubleDash\"),\n      bt = Symbol(\"copyDoubleDash\"),\n      vt = Symbol(\"deleteFromParserHintObject\"),\n      Ot = Symbol(\"emitWarning\"),\n      wt = Symbol(\"freeze\"),\n      Ct = Symbol(\"getDollarZero\"),\n      jt = Symbol(\"getParserConfiguration\"),\n      _t = Symbol(\"guessLocale\"),\n      Mt = Symbol(\"guessVersion\"),\n      kt = Symbol(\"parsePositionalNumbers\"),\n      xt = Symbol(\"pkgUp\"),\n      Et = Symbol(\"populateParserHintArray\"),\n      At = Symbol(\"populateParserHintSingleValueDictionary\"),\n      Pt = Symbol(\"populateParserHintArrayDictionary\"),\n      St = Symbol(\"populateParserHintDictionary\"),\n      $t = Symbol(\"sanitizeKey\"),\n      It = Symbol(\"setKey\"),\n      Dt = Symbol(\"unfreeze\"),\n      Nt = Symbol(\"validateAsync\"),\n      Ht = Symbol(\"getCommandInstance\"),\n      zt = Symbol(\"getContext\"),\n      qt = Symbol(\"getHasOutput\"),\n      Wt = Symbol(\"getLoggerInstance\"),\n      Ft = Symbol(\"getParseContext\"),\n      Ut = Symbol(\"getUsageInstance\"),\n      Lt = Symbol(\"getValidationInstance\"),\n      Vt = Symbol(\"hasParseCallback\"),\n      Gt = Symbol(\"isGlobalContext\"),\n      Rt = Symbol(\"postProcess\"),\n      Tt = Symbol(\"rebase\"),\n      Kt = Symbol(\"reset\"),\n      Bt = Symbol(\"runYargsParserAndExecuteCommands\"),\n      Yt = Symbol(\"runValidation\"),\n      Jt = Symbol(\"setHasOutput\"),\n      Zt = Symbol(\"kTrackManuallySetKeys\");\n\nclass Xt {\n  constructor(t = [], e, s, i) {\n    this.customScriptName = !1, this.parsed = !1, z.set(this, void 0), q.set(this, void 0), W.set(this, {\n      commands: [],\n      fullCommands: []\n    }), F.set(this, null), U.set(this, null), L.set(this, \"show-hidden\"), V.set(this, null), G.set(this, !0), R.set(this, {}), T.set(this, !0), K.set(this, []), B.set(this, void 0), Y.set(this, {}), J.set(this, !1), Z.set(this, null), X.set(this, !0), Q.set(this, void 0), tt.set(this, \"\"), et.set(this, void 0), st.set(this, void 0), it.set(this, {}), nt.set(this, null), rt.set(this, null), ot.set(this, {}), at.set(this, {}), ht.set(this, void 0), lt.set(this, !1), ct.set(this, void 0), ft.set(this, !1), dt.set(this, !1), ut.set(this, !1), pt.set(this, void 0), gt.set(this, null), mt.set(this, void 0), O(this, ct, i, \"f\"), O(this, ht, t, \"f\"), O(this, q, e, \"f\"), O(this, st, s, \"f\"), O(this, B, new w(this), \"f\"), this.$0 = this[Ct](), this[Kt](), O(this, z, v(this, z, \"f\"), \"f\"), O(this, pt, v(this, pt, \"f\"), \"f\"), O(this, mt, v(this, mt, \"f\"), \"f\"), O(this, et, v(this, et, \"f\"), \"f\"), v(this, et, \"f\").showHiddenOpt = v(this, L, \"f\"), O(this, Q, this[bt](), \"f\");\n  }\n\n  addHelpOpt(t, e) {\n    return h(\"[string|boolean] [string]\", [t, e], arguments.length), v(this, Z, \"f\") && (this[vt](v(this, Z, \"f\")), O(this, Z, null, \"f\")), !1 === t && void 0 === e || (O(this, Z, \"string\" == typeof t ? t : \"help\", \"f\"), this.boolean(v(this, Z, \"f\")), this.describe(v(this, Z, \"f\"), e || v(this, pt, \"f\").deferY18nLookup(\"Show help\"))), this;\n  }\n\n  help(t, e) {\n    return this.addHelpOpt(t, e);\n  }\n\n  addShowHiddenOpt(t, e) {\n    if (h(\"[string|boolean] [string]\", [t, e], arguments.length), !1 === t && void 0 === e) return this;\n    const s = \"string\" == typeof t ? t : v(this, L, \"f\");\n    return this.boolean(s), this.describe(s, e || v(this, pt, \"f\").deferY18nLookup(\"Show hidden options\")), v(this, et, \"f\").showHiddenOpt = s, this;\n  }\n\n  showHidden(t, e) {\n    return this.addShowHiddenOpt(t, e);\n  }\n\n  alias(t, e) {\n    return h(\"<object|string|array> [string|array]\", [t, e], arguments.length), this[Pt](this.alias.bind(this), \"alias\", t, e), this;\n  }\n\n  array(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"array\", t), this[Zt](t), this;\n  }\n\n  boolean(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"boolean\", t), this[Zt](t), this;\n  }\n\n  check(t, e) {\n    return h(\"<function> [boolean]\", [t, e], arguments.length), this.middleware((e, s) => j(() => t(e, s.getOptions()), s => (s ? (\"string\" == typeof s || s instanceof Error) && v(this, pt, \"f\").fail(s.toString(), s) : v(this, pt, \"f\").fail(v(this, ct, \"f\").y18n.__(\"Argument check failed: %s\", t.toString())), e), t => (v(this, pt, \"f\").fail(t.message ? t.message : t.toString(), t), e)), !1, e), this;\n  }\n\n  choices(t, e) {\n    return h(\"<object|string|array> [string|array]\", [t, e], arguments.length), this[Pt](this.choices.bind(this), \"choices\", t, e), this;\n  }\n\n  coerce(t, s) {\n    if (h(\"<object|string|array> [function]\", [t, s], arguments.length), Array.isArray(t)) {\n      if (!s) throw new e(\"coerce callback must be provided\");\n\n      for (const e of t) this.coerce(e, s);\n\n      return this;\n    }\n\n    if (\"object\" == typeof t) {\n      for (const e of Object.keys(t)) this.coerce(e, t[e]);\n\n      return this;\n    }\n\n    if (!s) throw new e(\"coerce callback must be provided\");\n    return v(this, et, \"f\").key[t] = !0, v(this, B, \"f\").addCoerceMiddleware((i, n) => {\n      let r;\n      return Object.prototype.hasOwnProperty.call(i, t) ? j(() => (r = n.getAliases(), s(i[t])), e => {\n        i[t] = e;\n        const s = n.getInternalMethods().getParserConfiguration()[\"strip-aliased\"];\n        if (r[t] && !0 !== s) for (const s of r[t]) i[s] = e;\n        return i;\n      }, t => {\n        throw new e(t.message);\n      }) : i;\n    }, t), this;\n  }\n\n  conflicts(t, e) {\n    return h(\"<string|object> [string|array]\", [t, e], arguments.length), v(this, mt, \"f\").conflicts(t, e), this;\n  }\n\n  config(t = \"config\", e, s) {\n    return h(\"[object|string] [string|function] [function]\", [t, e, s], arguments.length), \"object\" != typeof t || Array.isArray(t) ? (\"function\" == typeof e && (s = e, e = void 0), this.describe(t, e || v(this, pt, \"f\").deferY18nLookup(\"Path to JSON config file\")), (Array.isArray(t) ? t : [t]).forEach(t => {\n      v(this, et, \"f\").config[t] = s || !0;\n    }), this) : (t = n(t, v(this, q, \"f\"), this[jt]()[\"deep-merge-config\"] || !1, v(this, ct, \"f\")), v(this, et, \"f\").configObjects = (v(this, et, \"f\").configObjects || []).concat(t), this);\n  }\n\n  completion(t, e, s) {\n    return h(\"[string] [string|boolean|function] [function]\", [t, e, s], arguments.length), \"function\" == typeof e && (s = e, e = void 0), O(this, U, t || v(this, U, \"f\") || \"completion\", \"f\"), e || !1 === e || (e = \"generate completion script\"), this.command(v(this, U, \"f\"), e), s && v(this, F, \"f\").registerFunction(s), this;\n  }\n\n  command(t, e, s, i, n, r) {\n    return h(\"<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]\", [t, e, s, i, n, r], arguments.length), v(this, z, \"f\").addHandler(t, e, s, i, n, r), this;\n  }\n\n  commands(t, e, s, i, n, r) {\n    return this.command(t, e, s, i, n, r);\n  }\n\n  commandDir(t, e) {\n    h(\"<string> [object]\", [t, e], arguments.length);\n\n    const s = v(this, st, \"f\") || v(this, ct, \"f\").require;\n\n    return v(this, z, \"f\").addDirectory(t, s, v(this, ct, \"f\").getCallerFile(), e), this;\n  }\n\n  count(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"count\", t), this[Zt](t), this;\n  }\n\n  default(t, e, s) {\n    return h(\"<object|string|array> [*] [string]\", [t, e, s], arguments.length), s && (u(t, v(this, ct, \"f\")), v(this, et, \"f\").defaultDescription[t] = s), \"function\" == typeof e && (u(t, v(this, ct, \"f\")), v(this, et, \"f\").defaultDescription[t] || (v(this, et, \"f\").defaultDescription[t] = v(this, pt, \"f\").functionDescription(e)), e = e.call()), this[At](this.default.bind(this), \"default\", t, e), this;\n  }\n\n  defaults(t, e, s) {\n    return this.default(t, e, s);\n  }\n\n  demandCommand(t = 1, e, s, i) {\n    return h(\"[number] [number|string] [string|null|undefined] [string|null|undefined]\", [t, e, s, i], arguments.length), \"number\" != typeof e && (s = e, e = 1 / 0), this.global(\"_\", !1), v(this, et, \"f\").demandedCommands._ = {\n      min: t,\n      max: e,\n      minMsg: s,\n      maxMsg: i\n    }, this;\n  }\n\n  demand(t, e, s) {\n    return Array.isArray(e) ? (e.forEach(t => {\n      d(s, !0, v(this, ct, \"f\")), this.demandOption(t, s);\n    }), e = 1 / 0) : \"number\" != typeof e && (s = e, e = 1 / 0), \"number\" == typeof t ? (d(s, !0, v(this, ct, \"f\")), this.demandCommand(t, e, s, s)) : Array.isArray(t) ? t.forEach(t => {\n      d(s, !0, v(this, ct, \"f\")), this.demandOption(t, s);\n    }) : \"string\" == typeof s ? this.demandOption(t, s) : !0 !== s && void 0 !== s || this.demandOption(t), this;\n  }\n\n  demandOption(t, e) {\n    return h(\"<object|string|array> [string]\", [t, e], arguments.length), this[At](this.demandOption.bind(this), \"demandedOptions\", t, e), this;\n  }\n\n  deprecateOption(t, e) {\n    return h(\"<string> [string|boolean]\", [t, e], arguments.length), v(this, et, \"f\").deprecatedOptions[t] = e, this;\n  }\n\n  describe(t, e) {\n    return h(\"<object|string|array> [string]\", [t, e], arguments.length), this[It](t, !0), v(this, pt, \"f\").describe(t, e), this;\n  }\n\n  detectLocale(t) {\n    return h(\"<boolean>\", [t], arguments.length), O(this, G, t, \"f\"), this;\n  }\n\n  env(t) {\n    return h(\"[string|boolean]\", [t], arguments.length), !1 === t ? delete v(this, et, \"f\").envPrefix : v(this, et, \"f\").envPrefix = t || \"\", this;\n  }\n\n  epilogue(t) {\n    return h(\"<string>\", [t], arguments.length), v(this, pt, \"f\").epilog(t), this;\n  }\n\n  epilog(t) {\n    return this.epilogue(t);\n  }\n\n  example(t, e) {\n    return h(\"<string|array> [string]\", [t, e], arguments.length), Array.isArray(t) ? t.forEach(t => this.example(...t)) : v(this, pt, \"f\").example(t, e), this;\n  }\n\n  exit(t, e) {\n    O(this, J, !0, \"f\"), O(this, V, e, \"f\"), v(this, T, \"f\") && v(this, ct, \"f\").process.exit(t);\n  }\n\n  exitProcess(t = !0) {\n    return h(\"[boolean]\", [t], arguments.length), O(this, T, t, \"f\"), this;\n  }\n\n  fail(t) {\n    if (h(\"<function|boolean>\", [t], arguments.length), \"boolean\" == typeof t && !1 !== t) throw new e(\"Invalid first argument. Expected function or boolean 'false'\");\n    return v(this, pt, \"f\").failFn(t), this;\n  }\n\n  getAliases() {\n    return this.parsed ? this.parsed.aliases : {};\n  }\n\n  getCompletion(t, e) {\n    var _arguments = arguments,\n        _this = this;\n\n    return _asyncToGenerator(function* () {\n      return h(\"<array> [function]\", [t, e], _arguments.length), e ? v(_this, F, \"f\").getCompletion(t, e) : new Promise((e, s) => {\n        v(_this, F, \"f\").getCompletion(t, (t, i) => {\n          t ? s(t) : e(i);\n        });\n      });\n    })();\n  }\n\n  getDemandedOptions() {\n    return h([], 0), v(this, et, \"f\").demandedOptions;\n  }\n\n  getDemandedCommands() {\n    return h([], 0), v(this, et, \"f\").demandedCommands;\n  }\n\n  getDeprecatedOptions() {\n    return h([], 0), v(this, et, \"f\").deprecatedOptions;\n  }\n\n  getDetectLocale() {\n    return v(this, G, \"f\");\n  }\n\n  getExitProcess() {\n    return v(this, T, \"f\");\n  }\n\n  getGroups() {\n    return Object.assign({}, v(this, Y, \"f\"), v(this, at, \"f\"));\n  }\n\n  getHelp() {\n    if (O(this, J, !0, \"f\"), !v(this, pt, \"f\").hasCachedHelpMessage()) {\n      if (!this.parsed) {\n        const t = this[Bt](v(this, ht, \"f\"), void 0, void 0, 0, !0);\n        if (f(t)) return t.then(() => v(this, pt, \"f\").help());\n      }\n\n      const t = v(this, z, \"f\").runDefaultBuilderOn(this);\n      if (f(t)) return t.then(() => v(this, pt, \"f\").help());\n    }\n\n    return Promise.resolve(v(this, pt, \"f\").help());\n  }\n\n  getOptions() {\n    return v(this, et, \"f\");\n  }\n\n  getStrict() {\n    return v(this, ft, \"f\");\n  }\n\n  getStrictCommands() {\n    return v(this, dt, \"f\");\n  }\n\n  getStrictOptions() {\n    return v(this, ut, \"f\");\n  }\n\n  global(t, e) {\n    return h(\"<string|array> [boolean]\", [t, e], arguments.length), t = [].concat(t), !1 !== e ? v(this, et, \"f\").local = v(this, et, \"f\").local.filter(e => -1 === t.indexOf(e)) : t.forEach(t => {\n      v(this, et, \"f\").local.includes(t) || v(this, et, \"f\").local.push(t);\n    }), this;\n  }\n\n  group(t, e) {\n    h(\"<string|array> <string>\", [t, e], arguments.length);\n    const s = v(this, at, \"f\")[e] || v(this, Y, \"f\")[e];\n    v(this, at, \"f\")[e] && delete v(this, at, \"f\")[e];\n    const i = {};\n    return v(this, Y, \"f\")[e] = (s || []).concat(t).filter(t => !i[t] && (i[t] = !0)), this;\n  }\n\n  hide(t) {\n    return h(\"<string>\", [t], arguments.length), v(this, et, \"f\").hiddenOptions.push(t), this;\n  }\n\n  implies(t, e) {\n    return h(\"<string|object> [number|string|array]\", [t, e], arguments.length), v(this, mt, \"f\").implies(t, e), this;\n  }\n\n  locale(t) {\n    return h(\"[string]\", [t], arguments.length), void 0 === t ? (this[_t](), v(this, ct, \"f\").y18n.getLocale()) : (O(this, G, !1, \"f\"), v(this, ct, \"f\").y18n.setLocale(t), this);\n  }\n\n  middleware(t, e, s) {\n    return v(this, B, \"f\").addMiddleware(t, !!e, s);\n  }\n\n  nargs(t, e) {\n    return h(\"<string|object|array> [number]\", [t, e], arguments.length), this[At](this.nargs.bind(this), \"narg\", t, e), this;\n  }\n\n  normalize(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"normalize\", t), this;\n  }\n\n  number(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"number\", t), this[Zt](t), this;\n  }\n\n  option(t, e) {\n    if (h(\"<string|object> [object]\", [t, e], arguments.length), \"object\" == typeof t) Object.keys(t).forEach(e => {\n      this.options(e, t[e]);\n    });else {\n      \"object\" != typeof e && (e = {}), this[Zt](t), !v(this, gt, \"f\") || \"version\" !== t && \"version\" !== (null == e ? void 0 : e.alias) || this[Ot](['\"version\" is a reserved word.', \"Please do one of the following:\", '- Disable version with `yargs.version(false)` if using \"version\" as an option', \"- Use the built-in `yargs.version` method instead (if applicable)\", \"- Use a different option key\", \"https://yargs.js.org/docs/#api-reference-version\"].join(\"\\n\"), void 0, \"versionWarning\"), v(this, et, \"f\").key[t] = !0, e.alias && this.alias(t, e.alias);\n      const s = e.deprecate || e.deprecated;\n      s && this.deprecateOption(t, s);\n      const i = e.demand || e.required || e.require;\n      i && this.demand(t, i), e.demandOption && this.demandOption(t, \"string\" == typeof e.demandOption ? e.demandOption : void 0), e.conflicts && this.conflicts(t, e.conflicts), \"default\" in e && this.default(t, e.default), void 0 !== e.implies && this.implies(t, e.implies), void 0 !== e.nargs && this.nargs(t, e.nargs), e.config && this.config(t, e.configParser), e.normalize && this.normalize(t), e.choices && this.choices(t, e.choices), e.coerce && this.coerce(t, e.coerce), e.group && this.group(t, e.group), (e.boolean || \"boolean\" === e.type) && (this.boolean(t), e.alias && this.boolean(e.alias)), (e.array || \"array\" === e.type) && (this.array(t), e.alias && this.array(e.alias)), (e.number || \"number\" === e.type) && (this.number(t), e.alias && this.number(e.alias)), (e.string || \"string\" === e.type) && (this.string(t), e.alias && this.string(e.alias)), (e.count || \"count\" === e.type) && this.count(t), \"boolean\" == typeof e.global && this.global(t, e.global), e.defaultDescription && (v(this, et, \"f\").defaultDescription[t] = e.defaultDescription), e.skipValidation && this.skipValidation(t);\n      const n = e.describe || e.description || e.desc;\n      this.describe(t, n), e.hidden && this.hide(t), e.requiresArg && this.requiresArg(t);\n    }\n    return this;\n  }\n\n  options(t, e) {\n    return this.option(t, e);\n  }\n\n  parse(t, e, s) {\n    h(\"[string|array] [function|boolean|object] [function]\", [t, e, s], arguments.length), this[wt](), void 0 === t && (t = v(this, ht, \"f\")), \"object\" == typeof e && (O(this, rt, e, \"f\"), e = s), \"function\" == typeof e && (O(this, nt, e, \"f\"), e = !1), e || O(this, ht, t, \"f\"), v(this, nt, \"f\") && O(this, T, !1, \"f\");\n    const i = this[Bt](t, !!e),\n          n = this.parsed;\n    return v(this, F, \"f\").setParsed(this.parsed), f(i) ? i.then(t => (v(this, nt, \"f\") && v(this, nt, \"f\").call(this, v(this, V, \"f\"), t, v(this, tt, \"f\")), t)).catch(t => {\n      throw v(this, nt, \"f\") && v(this, nt, \"f\")(t, this.parsed.argv, v(this, tt, \"f\")), t;\n    }).finally(() => {\n      this[Dt](), this.parsed = n;\n    }) : (v(this, nt, \"f\") && v(this, nt, \"f\").call(this, v(this, V, \"f\"), i, v(this, tt, \"f\")), this[Dt](), this.parsed = n, i);\n  }\n\n  parseAsync(t, e, s) {\n    const i = this.parse(t, e, s);\n    return f(i) ? i : Promise.resolve(i);\n  }\n\n  parseSync(t, s, i) {\n    const n = this.parse(t, s, i);\n    if (f(n)) throw new e(\".parseSync() must not be used with asynchronous builders, handlers, or middleware\");\n    return n;\n  }\n\n  parserConfiguration(t) {\n    return h(\"<object>\", [t], arguments.length), O(this, it, t, \"f\"), this;\n  }\n\n  pkgConf(t, e) {\n    h(\"<string> [string]\", [t, e], arguments.length);\n    let s = null;\n    const i = this[xt](e || v(this, q, \"f\"));\n    return i[t] && \"object\" == typeof i[t] && (s = n(i[t], e || v(this, q, \"f\"), this[jt]()[\"deep-merge-config\"] || !1, v(this, ct, \"f\")), v(this, et, \"f\").configObjects = (v(this, et, \"f\").configObjects || []).concat(s)), this;\n  }\n\n  positional(t, e) {\n    h(\"<string> <object>\", [t, e], arguments.length);\n    const s = [\"default\", \"defaultDescription\", \"implies\", \"normalize\", \"choices\", \"conflicts\", \"coerce\", \"type\", \"describe\", \"desc\", \"description\", \"alias\"];\n    e = g(e, (t, e) => !(\"type\" === t && ![\"string\", \"number\", \"boolean\"].includes(e)) && s.includes(t));\n    const i = v(this, W, \"f\").fullCommands[v(this, W, \"f\").fullCommands.length - 1],\n          n = i ? v(this, z, \"f\").cmdToParseOptions(i) : {\n      array: [],\n      alias: {},\n      default: {},\n      demand: {}\n    };\n    return p(n).forEach(s => {\n      const i = n[s];\n      Array.isArray(i) ? -1 !== i.indexOf(t) && (e[s] = !0) : i[t] && !(s in e) && (e[s] = i[t]);\n    }), this.group(t, v(this, pt, \"f\").getPositionalGroupName()), this.option(t, e);\n  }\n\n  recommendCommands(t = !0) {\n    return h(\"[boolean]\", [t], arguments.length), O(this, lt, t, \"f\"), this;\n  }\n\n  required(t, e, s) {\n    return this.demand(t, e, s);\n  }\n\n  require(t, e, s) {\n    return this.demand(t, e, s);\n  }\n\n  requiresArg(t) {\n    return h(\"<array|string|object> [number]\", [t], arguments.length), \"string\" == typeof t && v(this, et, \"f\").narg[t] || this[At](this.requiresArg.bind(this), \"narg\", t, NaN), this;\n  }\n\n  showCompletionScript(t, e) {\n    return h(\"[string] [string]\", [t, e], arguments.length), t = t || this.$0, v(this, Q, \"f\").log(v(this, F, \"f\").generateCompletionScript(t, e || v(this, U, \"f\") || \"completion\")), this;\n  }\n\n  showHelp(t) {\n    if (h(\"[string|function]\", [t], arguments.length), O(this, J, !0, \"f\"), !v(this, pt, \"f\").hasCachedHelpMessage()) {\n      if (!this.parsed) {\n        const e = this[Bt](v(this, ht, \"f\"), void 0, void 0, 0, !0);\n        if (f(e)) return e.then(() => {\n          v(this, pt, \"f\").showHelp(t);\n        }), this;\n      }\n\n      const e = v(this, z, \"f\").runDefaultBuilderOn(this);\n      if (f(e)) return e.then(() => {\n        v(this, pt, \"f\").showHelp(t);\n      }), this;\n    }\n\n    return v(this, pt, \"f\").showHelp(t), this;\n  }\n\n  scriptName(t) {\n    return this.customScriptName = !0, this.$0 = t, this;\n  }\n\n  showHelpOnFail(t, e) {\n    return h(\"[boolean|string] [string]\", [t, e], arguments.length), v(this, pt, \"f\").showHelpOnFail(t, e), this;\n  }\n\n  showVersion(t) {\n    return h(\"[string|function]\", [t], arguments.length), v(this, pt, \"f\").showVersion(t), this;\n  }\n\n  skipValidation(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"skipValidation\", t), this;\n  }\n\n  strict(t) {\n    return h(\"[boolean]\", [t], arguments.length), O(this, ft, !1 !== t, \"f\"), this;\n  }\n\n  strictCommands(t) {\n    return h(\"[boolean]\", [t], arguments.length), O(this, dt, !1 !== t, \"f\"), this;\n  }\n\n  strictOptions(t) {\n    return h(\"[boolean]\", [t], arguments.length), O(this, ut, !1 !== t, \"f\"), this;\n  }\n\n  string(t) {\n    return h(\"<array|string>\", [t], arguments.length), this[Et](\"string\", t), this[Zt](t), this;\n  }\n\n  terminalWidth() {\n    return h([], 0), v(this, ct, \"f\").process.stdColumns;\n  }\n\n  updateLocale(t) {\n    return this.updateStrings(t);\n  }\n\n  updateStrings(t) {\n    return h(\"<object>\", [t], arguments.length), O(this, G, !1, \"f\"), v(this, ct, \"f\").y18n.updateLocale(t), this;\n  }\n\n  usage(t, s, i, n) {\n    if (h(\"<string|null|undefined> [string|boolean] [function|object] [function]\", [t, s, i, n], arguments.length), void 0 !== s) {\n      if (d(t, null, v(this, ct, \"f\")), (t || \"\").match(/^\\$0( |$)/)) return this.command(t, s, i, n);\n      throw new e(\".usage() description must start with $0 if being used as alias for .command()\");\n    }\n\n    return v(this, pt, \"f\").usage(t), this;\n  }\n\n  version(t, e, s) {\n    const i = \"version\";\n    if (h(\"[boolean|string] [string] [string]\", [t, e, s], arguments.length), v(this, gt, \"f\") && (this[vt](v(this, gt, \"f\")), v(this, pt, \"f\").version(void 0), O(this, gt, null, \"f\")), 0 === arguments.length) s = this[Mt](), t = i;else if (1 === arguments.length) {\n      if (!1 === t) return this;\n      s = t, t = i;\n    } else 2 === arguments.length && (s = e, e = void 0);\n    return O(this, gt, \"string\" == typeof t ? t : i, \"f\"), e = e || v(this, pt, \"f\").deferY18nLookup(\"Show version number\"), v(this, pt, \"f\").version(s || void 0), this.boolean(v(this, gt, \"f\")), this.describe(v(this, gt, \"f\"), e), this;\n  }\n\n  wrap(t) {\n    return h(\"<number|null|undefined>\", [t], arguments.length), v(this, pt, \"f\").wrap(t), this;\n  }\n\n  [(z = new WeakMap(), q = new WeakMap(), W = new WeakMap(), F = new WeakMap(), U = new WeakMap(), L = new WeakMap(), V = new WeakMap(), G = new WeakMap(), R = new WeakMap(), T = new WeakMap(), K = new WeakMap(), B = new WeakMap(), Y = new WeakMap(), J = new WeakMap(), Z = new WeakMap(), X = new WeakMap(), Q = new WeakMap(), tt = new WeakMap(), et = new WeakMap(), st = new WeakMap(), it = new WeakMap(), nt = new WeakMap(), rt = new WeakMap(), ot = new WeakMap(), at = new WeakMap(), ht = new WeakMap(), lt = new WeakMap(), ct = new WeakMap(), ft = new WeakMap(), dt = new WeakMap(), ut = new WeakMap(), pt = new WeakMap(), gt = new WeakMap(), mt = new WeakMap(), yt)](t) {\n    if (!t._ || !t[\"--\"]) return t;\n\n    t._.push.apply(t._, t[\"--\"]);\n\n    try {\n      delete t[\"--\"];\n    } catch (t) {}\n\n    return t;\n  }\n\n  [bt]() {\n    return {\n      log: (...t) => {\n        this[Vt]() || console.log(...t), O(this, J, !0, \"f\"), v(this, tt, \"f\").length && O(this, tt, v(this, tt, \"f\") + \"\\n\", \"f\"), O(this, tt, v(this, tt, \"f\") + t.join(\" \"), \"f\");\n      },\n      error: (...t) => {\n        this[Vt]() || console.error(...t), O(this, J, !0, \"f\"), v(this, tt, \"f\").length && O(this, tt, v(this, tt, \"f\") + \"\\n\", \"f\"), O(this, tt, v(this, tt, \"f\") + t.join(\" \"), \"f\");\n      }\n    };\n  }\n\n  [vt](t) {\n    p(v(this, et, \"f\")).forEach(e => {\n      if (\"configObjects\" === e) return;\n      const s = v(this, et, \"f\")[e];\n      Array.isArray(s) ? s.includes(t) && s.splice(s.indexOf(t), 1) : \"object\" == typeof s && delete s[t];\n    }), delete v(this, pt, \"f\").getDescriptions()[t];\n  }\n\n  [Ot](t, e, s) {\n    v(this, R, \"f\")[s] || (v(this, ct, \"f\").process.emitWarning(t, e), v(this, R, \"f\")[s] = !0);\n  }\n\n  [wt]() {\n    v(this, K, \"f\").push({\n      options: v(this, et, \"f\"),\n      configObjects: v(this, et, \"f\").configObjects.slice(0),\n      exitProcess: v(this, T, \"f\"),\n      groups: v(this, Y, \"f\"),\n      strict: v(this, ft, \"f\"),\n      strictCommands: v(this, dt, \"f\"),\n      strictOptions: v(this, ut, \"f\"),\n      completionCommand: v(this, U, \"f\"),\n      output: v(this, tt, \"f\"),\n      exitError: v(this, V, \"f\"),\n      hasOutput: v(this, J, \"f\"),\n      parsed: this.parsed,\n      parseFn: v(this, nt, \"f\"),\n      parseContext: v(this, rt, \"f\")\n    }), v(this, pt, \"f\").freeze(), v(this, mt, \"f\").freeze(), v(this, z, \"f\").freeze(), v(this, B, \"f\").freeze();\n  }\n\n  [Ct]() {\n    let t,\n        e = \"\";\n    return t = /\\b(node|iojs|electron)(\\.exe)?$/.test(v(this, ct, \"f\").process.argv()[0]) ? v(this, ct, \"f\").process.argv().slice(1, 2) : v(this, ct, \"f\").process.argv().slice(0, 1), e = t.map(t => {\n      const e = this[Tt](v(this, q, \"f\"), t);\n      return t.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && e.length < t.length ? e : t;\n    }).join(\" \").trim(), v(this, ct, \"f\").getEnv(\"_\") && v(this, ct, \"f\").getProcessArgvBin() === v(this, ct, \"f\").getEnv(\"_\") && (e = v(this, ct, \"f\").getEnv(\"_\").replace(`${v(this, ct, \"f\").path.dirname(v(this, ct, \"f\").process.execPath())}/`, \"\")), e;\n  }\n\n  [jt]() {\n    return v(this, it, \"f\");\n  }\n\n  [_t]() {\n    if (!v(this, G, \"f\")) return;\n    const t = v(this, ct, \"f\").getEnv(\"LC_ALL\") || v(this, ct, \"f\").getEnv(\"LC_MESSAGES\") || v(this, ct, \"f\").getEnv(\"LANG\") || v(this, ct, \"f\").getEnv(\"LANGUAGE\") || \"en_US\";\n    this.locale(t.replace(/[.:].*/, \"\"));\n  }\n\n  [Mt]() {\n    return this[xt]().version || \"unknown\";\n  }\n\n  [kt](t) {\n    const e = t[\"--\"] ? t[\"--\"] : t._;\n\n    for (let t, s = 0; void 0 !== (t = e[s]); s++) v(this, ct, \"f\").Parser.looksLikeNumber(t) && Number.isSafeInteger(Math.floor(parseFloat(`${t}`))) && (e[s] = Number(t));\n\n    return t;\n  }\n\n  [xt](t) {\n    const e = t || \"*\";\n    if (v(this, ot, \"f\")[e]) return v(this, ot, \"f\")[e];\n    let s = {};\n\n    try {\n      let e = t || v(this, ct, \"f\").mainFilename;\n      !t && v(this, ct, \"f\").path.extname(e) && (e = v(this, ct, \"f\").path.dirname(e));\n      const i = v(this, ct, \"f\").findUp(e, (t, e) => e.includes(\"package.json\") ? \"package.json\" : void 0);\n      d(i, void 0, v(this, ct, \"f\")), s = JSON.parse(v(this, ct, \"f\").readFileSync(i, \"utf8\"));\n    } catch (t) {}\n\n    return v(this, ot, \"f\")[e] = s || {}, v(this, ot, \"f\")[e];\n  }\n\n  [Et](t, e) {\n    (e = [].concat(e)).forEach(e => {\n      e = this[$t](e), v(this, et, \"f\")[t].push(e);\n    });\n  }\n\n  [At](t, e, s, i) {\n    this[St](t, e, s, i, (t, e, s) => {\n      v(this, et, \"f\")[t][e] = s;\n    });\n  }\n\n  [Pt](t, e, s, i) {\n    this[St](t, e, s, i, (t, e, s) => {\n      v(this, et, \"f\")[t][e] = (v(this, et, \"f\")[t][e] || []).concat(s);\n    });\n  }\n\n  [St](t, e, s, i, n) {\n    if (Array.isArray(s)) s.forEach(e => {\n      t(e, i);\n    });else if ((t => \"object\" == typeof t)(s)) for (const e of p(s)) t(e, s[e]);else n(e, this[$t](s), i);\n  }\n\n  [$t](t) {\n    return \"__proto__\" === t ? \"___proto___\" : t;\n  }\n\n  [It](t, e) {\n    return this[At](this[It].bind(this), \"key\", t, e), this;\n  }\n\n  [Dt]() {\n    var t, e, s, i, n, r, o, a, h, l, c, f;\n    const u = v(this, K, \"f\").pop();\n    let p;\n    d(u, void 0, v(this, ct, \"f\")), t = this, e = this, s = this, i = this, n = this, r = this, o = this, a = this, h = this, l = this, c = this, f = this, ({\n      options: {\n        set value(e) {\n          O(t, et, e, \"f\");\n        }\n\n      }.value,\n      configObjects: p,\n      exitProcess: {\n        set value(t) {\n          O(e, T, t, \"f\");\n        }\n\n      }.value,\n      groups: {\n        set value(t) {\n          O(s, Y, t, \"f\");\n        }\n\n      }.value,\n      output: {\n        set value(t) {\n          O(i, tt, t, \"f\");\n        }\n\n      }.value,\n      exitError: {\n        set value(t) {\n          O(n, V, t, \"f\");\n        }\n\n      }.value,\n      hasOutput: {\n        set value(t) {\n          O(r, J, t, \"f\");\n        }\n\n      }.value,\n      parsed: this.parsed,\n      strict: {\n        set value(t) {\n          O(o, ft, t, \"f\");\n        }\n\n      }.value,\n      strictCommands: {\n        set value(t) {\n          O(a, dt, t, \"f\");\n        }\n\n      }.value,\n      strictOptions: {\n        set value(t) {\n          O(h, ut, t, \"f\");\n        }\n\n      }.value,\n      completionCommand: {\n        set value(t) {\n          O(l, U, t, \"f\");\n        }\n\n      }.value,\n      parseFn: {\n        set value(t) {\n          O(c, nt, t, \"f\");\n        }\n\n      }.value,\n      parseContext: {\n        set value(t) {\n          O(f, rt, t, \"f\");\n        }\n\n      }.value\n    } = u), v(this, et, \"f\").configObjects = p, v(this, pt, \"f\").unfreeze(), v(this, mt, \"f\").unfreeze(), v(this, z, \"f\").unfreeze(), v(this, B, \"f\").unfreeze();\n  }\n\n  [Nt](t, e) {\n    return j(e, e => (t(e), e));\n  }\n\n  getInternalMethods() {\n    return {\n      getCommandInstance: this[Ht].bind(this),\n      getContext: this[zt].bind(this),\n      getHasOutput: this[qt].bind(this),\n      getLoggerInstance: this[Wt].bind(this),\n      getParseContext: this[Ft].bind(this),\n      getParserConfiguration: this[jt].bind(this),\n      getUsageInstance: this[Ut].bind(this),\n      getValidationInstance: this[Lt].bind(this),\n      hasParseCallback: this[Vt].bind(this),\n      isGlobalContext: this[Gt].bind(this),\n      postProcess: this[Rt].bind(this),\n      reset: this[Kt].bind(this),\n      runValidation: this[Yt].bind(this),\n      runYargsParserAndExecuteCommands: this[Bt].bind(this),\n      setHasOutput: this[Jt].bind(this)\n    };\n  }\n\n  [Ht]() {\n    return v(this, z, \"f\");\n  }\n\n  [zt]() {\n    return v(this, W, \"f\");\n  }\n\n  [qt]() {\n    return v(this, J, \"f\");\n  }\n\n  [Wt]() {\n    return v(this, Q, \"f\");\n  }\n\n  [Ft]() {\n    return v(this, rt, \"f\") || {};\n  }\n\n  [Ut]() {\n    return v(this, pt, \"f\");\n  }\n\n  [Lt]() {\n    return v(this, mt, \"f\");\n  }\n\n  [Vt]() {\n    return !!v(this, nt, \"f\");\n  }\n\n  [Gt]() {\n    return v(this, X, \"f\");\n  }\n\n  [Rt](t, e, s, i) {\n    if (s) return t;\n    if (f(t)) return t;\n    e || (t = this[yt](t));\n    return (this[jt]()[\"parse-positional-numbers\"] || void 0 === this[jt]()[\"parse-positional-numbers\"]) && (t = this[kt](t)), i && (t = C(t, this, v(this, B, \"f\").getMiddleware(), !1)), t;\n  }\n\n  [Kt](t = {}) {\n    O(this, et, v(this, et, \"f\") || {}, \"f\");\n    const e = {};\n    e.local = v(this, et, \"f\").local || [], e.configObjects = v(this, et, \"f\").configObjects || [];\n    const s = {};\n    e.local.forEach(e => {\n      s[e] = !0, (t[e] || []).forEach(t => {\n        s[t] = !0;\n      });\n    }), Object.assign(v(this, at, \"f\"), Object.keys(v(this, Y, \"f\")).reduce((t, e) => {\n      const i = v(this, Y, \"f\")[e].filter(t => !(t in s));\n      return i.length > 0 && (t[e] = i), t;\n    }, {})), O(this, Y, {}, \"f\");\n    return [\"array\", \"boolean\", \"string\", \"skipValidation\", \"count\", \"normalize\", \"number\", \"hiddenOptions\"].forEach(t => {\n      e[t] = (v(this, et, \"f\")[t] || []).filter(t => !s[t]);\n    }), [\"narg\", \"key\", \"alias\", \"default\", \"defaultDescription\", \"config\", \"choices\", \"demandedOptions\", \"demandedCommands\", \"deprecatedOptions\"].forEach(t => {\n      e[t] = g(v(this, et, \"f\")[t], t => !s[t]);\n    }), e.envPrefix = v(this, et, \"f\").envPrefix, O(this, et, e, \"f\"), O(this, pt, v(this, pt, \"f\") ? v(this, pt, \"f\").reset(s) : P(this, v(this, ct, \"f\")), \"f\"), O(this, mt, v(this, mt, \"f\") ? v(this, mt, \"f\").reset(s) : function (t, e, s) {\n      const i = s.y18n.__,\n            n = s.y18n.__n,\n            r = {\n        nonOptionCount: function (s) {\n          const i = t.getDemandedCommands(),\n                r = s._.length + (s[\"--\"] ? s[\"--\"].length : 0) - t.getInternalMethods().getContext().commands.length;\n          i._ && (r < i._.min || r > i._.max) && (r < i._.min ? void 0 !== i._.minMsg ? e.fail(i._.minMsg ? i._.minMsg.replace(/\\$0/g, r.toString()).replace(/\\$1/, i._.min.toString()) : null) : e.fail(n(\"Not enough non-option arguments: got %s, need at least %s\", \"Not enough non-option arguments: got %s, need at least %s\", r, r.toString(), i._.min.toString())) : r > i._.max && (void 0 !== i._.maxMsg ? e.fail(i._.maxMsg ? i._.maxMsg.replace(/\\$0/g, r.toString()).replace(/\\$1/, i._.max.toString()) : null) : e.fail(n(\"Too many non-option arguments: got %s, maximum of %s\", \"Too many non-option arguments: got %s, maximum of %s\", r, r.toString(), i._.max.toString()))));\n        },\n        positionalCount: function (t, s) {\n          s < t && e.fail(n(\"Not enough non-option arguments: got %s, need at least %s\", \"Not enough non-option arguments: got %s, need at least %s\", s, s + \"\", t + \"\"));\n        },\n        requiredArguments: function (t, s) {\n          let i = null;\n\n          for (const e of Object.keys(s)) Object.prototype.hasOwnProperty.call(t, e) && void 0 !== t[e] || (i = i || {}, i[e] = s[e]);\n\n          if (i) {\n            const t = [];\n\n            for (const e of Object.keys(i)) {\n              const s = i[e];\n              s && t.indexOf(s) < 0 && t.push(s);\n            }\n\n            const s = t.length ? `\\n${t.join(\"\\n\")}` : \"\";\n            e.fail(n(\"Missing required argument: %s\", \"Missing required arguments: %s\", Object.keys(i).length, Object.keys(i).join(\", \") + s));\n          }\n        },\n        unknownArguments: function (s, i, o, a, h = !0) {\n          var l;\n          const c = t.getInternalMethods().getCommandInstance().getCommands(),\n                f = [],\n                d = t.getInternalMethods().getContext();\n\n          if (Object.keys(s).forEach(e => {\n            H.includes(e) || Object.prototype.hasOwnProperty.call(o, e) || Object.prototype.hasOwnProperty.call(t.getInternalMethods().getParseContext(), e) || r.isValidAndSomeAliasIsNotNew(e, i) || f.push(e);\n          }), h && (d.commands.length > 0 || c.length > 0 || a) && s._.slice(d.commands.length).forEach(t => {\n            c.includes(\"\" + t) || f.push(\"\" + t);\n          }), h) {\n            const e = (null === (l = t.getDemandedCommands()._) || void 0 === l ? void 0 : l.max) || 0,\n                  i = d.commands.length + e;\n            i < s._.length && s._.slice(i).forEach(t => {\n              t = String(t), d.commands.includes(t) || f.includes(t) || f.push(t);\n            });\n          }\n\n          f.length && e.fail(n(\"Unknown argument: %s\", \"Unknown arguments: %s\", f.length, f.map(t => t.trim() ? t : `\"${t}\"`).join(\", \")));\n        },\n        unknownCommands: function (s) {\n          const i = t.getInternalMethods().getCommandInstance().getCommands(),\n                r = [],\n                o = t.getInternalMethods().getContext();\n          return (o.commands.length > 0 || i.length > 0) && s._.slice(o.commands.length).forEach(t => {\n            i.includes(\"\" + t) || r.push(\"\" + t);\n          }), r.length > 0 && (e.fail(n(\"Unknown command: %s\", \"Unknown commands: %s\", r.length, r.join(\", \"))), !0);\n        },\n        isValidAndSomeAliasIsNotNew: function (e, s) {\n          if (!Object.prototype.hasOwnProperty.call(s, e)) return !1;\n          const i = t.parsed.newAliases;\n          return [e, ...s[e]].some(t => !Object.prototype.hasOwnProperty.call(i, t) || !i[e]);\n        },\n        limitedChoices: function (s) {\n          const n = t.getOptions(),\n                r = {};\n          if (!Object.keys(n.choices).length) return;\n          Object.keys(s).forEach(t => {\n            -1 === H.indexOf(t) && Object.prototype.hasOwnProperty.call(n.choices, t) && [].concat(s[t]).forEach(e => {\n              -1 === n.choices[t].indexOf(e) && void 0 !== e && (r[t] = (r[t] || []).concat(e));\n            });\n          });\n          const o = Object.keys(r);\n          if (!o.length) return;\n          let a = i(\"Invalid values:\");\n          o.forEach(t => {\n            a += `\\n  ${i(\"Argument: %s, Given: %s, Choices: %s\", t, e.stringifiedValues(r[t]), e.stringifiedValues(n.choices[t]))}`;\n          }), e.fail(a);\n        }\n      };\n      let o = {};\n\n      function a(t, e) {\n        const s = Number(e);\n        return \"number\" == typeof (e = isNaN(s) ? e : s) ? e = t._.length >= e : e.match(/^--no-.+/) ? (e = e.match(/^--no-(.+)/)[1], e = !Object.prototype.hasOwnProperty.call(t, e)) : e = Object.prototype.hasOwnProperty.call(t, e), e;\n      }\n\n      r.implies = function (e, i) {\n        h(\"<string|object> [array|number|string]\", [e, i], arguments.length), \"object\" == typeof e ? Object.keys(e).forEach(t => {\n          r.implies(t, e[t]);\n        }) : (t.global(e), o[e] || (o[e] = []), Array.isArray(i) ? i.forEach(t => r.implies(e, t)) : (d(i, void 0, s), o[e].push(i)));\n      }, r.getImplied = function () {\n        return o;\n      }, r.implications = function (t) {\n        const s = [];\n\n        if (Object.keys(o).forEach(e => {\n          const i = e;\n          (o[e] || []).forEach(e => {\n            let n = i;\n            const r = e;\n            n = a(t, n), e = a(t, e), n && !e && s.push(` ${i} -> ${r}`);\n          });\n        }), s.length) {\n          let t = `${i(\"Implications failed:\")}\\n`;\n          s.forEach(e => {\n            t += e;\n          }), e.fail(t);\n        }\n      };\n      let l = {};\n      r.conflicts = function (e, s) {\n        h(\"<string|object> [array|string]\", [e, s], arguments.length), \"object\" == typeof e ? Object.keys(e).forEach(t => {\n          r.conflicts(t, e[t]);\n        }) : (t.global(e), l[e] || (l[e] = []), Array.isArray(s) ? s.forEach(t => r.conflicts(e, t)) : l[e].push(s));\n      }, r.getConflicting = () => l, r.conflicting = function (n) {\n        Object.keys(n).forEach(t => {\n          l[t] && l[t].forEach(s => {\n            s && void 0 !== n[t] && void 0 !== n[s] && e.fail(i(\"Arguments %s and %s are mutually exclusive\", t, s));\n          });\n        }), t.getInternalMethods().getParserConfiguration()[\"strip-dashed\"] && Object.keys(l).forEach(t => {\n          l[t].forEach(r => {\n            r && void 0 !== n[s.Parser.camelCase(t)] && void 0 !== n[s.Parser.camelCase(r)] && e.fail(i(\"Arguments %s and %s are mutually exclusive\", t, r));\n          });\n        });\n      }, r.recommendCommands = function (t, s) {\n        s = s.sort((t, e) => e.length - t.length);\n        let n = null,\n            r = 1 / 0;\n\n        for (let e, i = 0; void 0 !== (e = s[i]); i++) {\n          const s = N(t, e);\n          s <= 3 && s < r && (r = s, n = e);\n        }\n\n        n && e.fail(i(\"Did you mean %s?\", n));\n      }, r.reset = function (t) {\n        return o = g(o, e => !t[e]), l = g(l, e => !t[e]), r;\n      };\n      const c = [];\n      return r.freeze = function () {\n        c.push({\n          implied: o,\n          conflicting: l\n        });\n      }, r.unfreeze = function () {\n        const t = c.pop();\n        d(t, void 0, s), ({\n          implied: o,\n          conflicting: l\n        } = t);\n      }, r;\n    }(this, v(this, pt, \"f\"), v(this, ct, \"f\")), \"f\"), O(this, z, v(this, z, \"f\") ? v(this, z, \"f\").reset() : function (t, e, s, i) {\n      return new M(t, e, s, i);\n    }(v(this, pt, \"f\"), v(this, mt, \"f\"), v(this, B, \"f\"), v(this, ct, \"f\")), \"f\"), v(this, F, \"f\") || O(this, F, function (t, e, s, i) {\n      return new D(t, e, s, i);\n    }(this, v(this, pt, \"f\"), v(this, z, \"f\"), v(this, ct, \"f\")), \"f\"), v(this, B, \"f\").reset(), O(this, U, null, \"f\"), O(this, tt, \"\", \"f\"), O(this, V, null, \"f\"), O(this, J, !1, \"f\"), this.parsed = !1, this;\n  }\n\n  [Tt](t, e) {\n    return v(this, ct, \"f\").path.relative(t, e);\n  }\n\n  [Bt](t, s, i, n = 0, r = !1) {\n    let o = !!i || r;\n    t = t || v(this, ht, \"f\"), v(this, et, \"f\").__ = v(this, ct, \"f\").y18n.__, v(this, et, \"f\").configuration = this[jt]();\n    const a = !!v(this, et, \"f\").configuration[\"populate--\"],\n          h = Object.assign({}, v(this, et, \"f\").configuration, {\n      \"populate--\": !0\n    }),\n          l = v(this, ct, \"f\").Parser.detailed(t, Object.assign({}, v(this, et, \"f\"), {\n      configuration: {\n        \"parse-positional-numbers\": !1,\n        ...h\n      }\n    })),\n          c = Object.assign(l.argv, v(this, rt, \"f\"));\n    let d;\n    const u = l.aliases;\n    let p = !1,\n        g = !1;\n    Object.keys(c).forEach(t => {\n      t === v(this, Z, \"f\") && c[t] ? p = !0 : t === v(this, gt, \"f\") && c[t] && (g = !0);\n    }), c.$0 = this.$0, this.parsed = l, 0 === n && v(this, pt, \"f\").clearCachedHelpMessage();\n\n    try {\n      if (this[_t](), s) return this[Rt](c, a, !!i, !1);\n\n      if (v(this, Z, \"f\")) {\n        [v(this, Z, \"f\")].concat(u[v(this, Z, \"f\")] || []).filter(t => t.length > 1).includes(\"\" + c._[c._.length - 1]) && (c._.pop(), p = !0);\n      }\n\n      O(this, X, !1, \"f\");\n      const h = v(this, z, \"f\").getCommands(),\n            m = (v(this, F, \"f\").completionKey in c),\n            y = p || m || r;\n\n      if (c._.length) {\n        if (h.length) {\n          let t;\n\n          for (let e, s = n || 0; void 0 !== c._[s]; s++) {\n            if (e = String(c._[s]), h.includes(e) && e !== v(this, U, \"f\")) {\n              const t = v(this, z, \"f\").runCommand(e, this, l, s + 1, r, p || g || r);\n              return this[Rt](t, a, !!i, !1);\n            }\n\n            if (!t && e !== v(this, U, \"f\")) {\n              t = e;\n              break;\n            }\n          }\n\n          !v(this, z, \"f\").hasDefaultCommand() && v(this, lt, \"f\") && t && !y && v(this, mt, \"f\").recommendCommands(t, h);\n        }\n\n        v(this, U, \"f\") && c._.includes(v(this, U, \"f\")) && !m && (v(this, T, \"f\") && E(!0), this.showCompletionScript(), this.exit(0));\n      }\n\n      if (v(this, z, \"f\").hasDefaultCommand() && !y) {\n        const t = v(this, z, \"f\").runCommand(null, this, l, 0, r, p || g || r);\n        return this[Rt](t, a, !!i, !1);\n      }\n\n      if (m) {\n        v(this, T, \"f\") && E(!0);\n        const s = (t = [].concat(t)).slice(t.indexOf(`--${v(this, F, \"f\").completionKey}`) + 1);\n        return v(this, F, \"f\").getCompletion(s, (t, s) => {\n          if (t) throw new e(t.message);\n          (s || []).forEach(t => {\n            v(this, Q, \"f\").log(t);\n          }), this.exit(0);\n        }), this[Rt](c, !a, !!i, !1);\n      }\n\n      if (v(this, J, \"f\") || (p ? (v(this, T, \"f\") && E(!0), o = !0, this.showHelp(\"log\"), this.exit(0)) : g && (v(this, T, \"f\") && E(!0), o = !0, v(this, pt, \"f\").showVersion(\"log\"), this.exit(0))), !o && v(this, et, \"f\").skipValidation.length > 0 && (o = Object.keys(c).some(t => v(this, et, \"f\").skipValidation.indexOf(t) >= 0 && !0 === c[t])), !o) {\n        if (l.error) throw new e(l.error.message);\n\n        if (!m) {\n          const t = this[Yt](u, {}, l.error);\n          i || (d = C(c, this, v(this, B, \"f\").getMiddleware(), !0)), d = this[Nt](t, null != d ? d : c), f(d) && !i && (d = d.then(() => C(c, this, v(this, B, \"f\").getMiddleware(), !1)));\n        }\n      }\n    } catch (t) {\n      if (!(t instanceof e)) throw t;\n      v(this, pt, \"f\").fail(t.message, t);\n    }\n\n    return this[Rt](null != d ? d : c, a, !!i, !0);\n  }\n\n  [Yt](t, s, i, n) {\n    const r = { ...this.getDemandedOptions()\n    };\n    return o => {\n      if (i) throw new e(i.message);\n      v(this, mt, \"f\").nonOptionCount(o), v(this, mt, \"f\").requiredArguments(o, r);\n      let a = !1;\n      v(this, dt, \"f\") && (a = v(this, mt, \"f\").unknownCommands(o)), v(this, ft, \"f\") && !a ? v(this, mt, \"f\").unknownArguments(o, t, s, !!n) : v(this, ut, \"f\") && v(this, mt, \"f\").unknownArguments(o, t, {}, !1, !1), v(this, mt, \"f\").limitedChoices(o), v(this, mt, \"f\").implications(o), v(this, mt, \"f\").conflicting(o);\n    };\n  }\n\n  [Jt]() {\n    O(this, J, !0, \"f\");\n  }\n\n  [Zt](t) {\n    if (\"string\" == typeof t) v(this, et, \"f\").key[t] = !0;else for (const e of t) v(this, et, \"f\").key[e] = !0;\n  }\n\n}\n\nvar Qt, te;\n\nconst {\n  readFileSync: ee\n} = require(\"fs\"),\n      {\n  inspect: se\n} = require(\"util\"),\n      {\n  resolve: ie\n} = require(\"path\"),\n      ne = require(\"y18n\"),\n      re = require(\"yargs-parser\");\n\nvar oe,\n    ae = {\n  assert: {\n    notStrictEqual: t.notStrictEqual,\n    strictEqual: t.strictEqual\n  },\n  cliui: require(\"cliui\"),\n  findUp: require(\"escalade/sync\"),\n  getEnv: t => process.env[t],\n  getCallerFile: require(\"get-caller-file\"),\n  getProcessArgvBin: y,\n  inspect: se,\n  mainFilename: null !== (te = null === (Qt = null === require || void 0 === require ? void 0 : require.main) || void 0 === Qt ? void 0 : Qt.filename) && void 0 !== te ? te : process.cwd(),\n  Parser: re,\n  path: require(\"path\"),\n  process: {\n    argv: () => process.argv,\n    cwd: process.cwd,\n    emitWarning: (t, e) => process.emitWarning(t, e),\n    execPath: () => process.execPath,\n    exit: t => {\n      process.exit(t);\n    },\n    nextTick: process.nextTick,\n    stdColumns: void 0 !== process.stdout.columns ? process.stdout.columns : null\n  },\n  readFileSync: ee,\n  require: require,\n  requireDirectory: require(\"require-directory\"),\n  stringWidth: require(\"string-width\"),\n  y18n: ne({\n    directory: ie(__dirname, \"../locales\"),\n    updateFiles: !1\n  })\n};\nconst he = (null === (oe = null === process || void 0 === process ? void 0 : process.env) || void 0 === oe ? void 0 : oe.YARGS_MIN_NODE_VERSION) ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;\n\nif (process && process.version) {\n  if (Number(process.version.match(/v([^.]+)/)[1]) < he) throw Error(`yargs supports a minimum Node.js version of ${he}. Read our version support policy: https://github.com/yargs/yargs#supported-nodejs-versions`);\n}\n\nconst le = require(\"yargs-parser\");\n\nvar ce,\n    fe = {\n  applyExtends: n,\n  cjsPlatformShim: ae,\n  Yargs: (ce = ae, (t = [], e = ce.process.cwd(), s) => {\n    const i = new Xt(t, e, s, ce);\n    return Object.defineProperty(i, \"argv\", {\n      get: () => i.parse(),\n      enumerable: !0\n    }), i.help(), i.version(), i;\n  }),\n  argsert: h,\n  isPromise: f,\n  objFilter: g,\n  parseCommand: o,\n  Parser: le,\n  processArgv: b,\n  YError: e\n};\nmodule.exports = fe;","map":null,"metadata":{},"sourceType":"script"}