{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createBuilder = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst api_1 = require(\"./api\");\n\nconst internal_1 = require(\"./internal\");\n\nconst schedule_by_name_1 = require(\"./schedule-by-name\"); // eslint-disable-next-line max-lines-per-function\n\n\nfunction createBuilder(fn) {\n  const cjh = core_1.experimental.jobs.createJobHandler; // eslint-disable-next-line max-lines-per-function\n\n  const handler = cjh((options, context) => {\n    const scheduler = context.scheduler;\n    const progressChannel = context.createChannel('progress');\n    const logChannel = context.createChannel('log');\n    const analyticsChannel = context.createChannel('analytics');\n    let currentState = api_1.BuilderProgressState.Stopped;\n    const teardownLogics = [];\n    let tearingDown = false;\n    let current = 0;\n    let status = '';\n    let total = 1;\n\n    function log(entry) {\n      logChannel.next(entry);\n    }\n\n    function progress(progress, context) {\n      currentState = progress.state;\n\n      if (progress.state === api_1.BuilderProgressState.Running) {\n        current = progress.current;\n        total = progress.total !== undefined ? progress.total : total;\n\n        if (progress.status === undefined) {\n          progress.status = status;\n        } else {\n          status = progress.status;\n        }\n      }\n\n      progressChannel.next({ ...progress,\n        ...(context.target && {\n          target: context.target\n        }),\n        ...(context.builder && {\n          builder: context.builder\n        }),\n        id: context.id\n      });\n    }\n\n    return new rxjs_1.Observable(observer => {\n      const subscriptions = [];\n      const inputSubscription = context.inboundBus.subscribe(i => {\n        switch (i.kind) {\n          case core_1.experimental.jobs.JobInboundMessageKind.Stop:\n            // Run teardown logic then complete.\n            tearingDown = true;\n            Promise.all(teardownLogics.map(fn => fn() || Promise.resolve())).then(() => observer.complete(), err => observer.error(err));\n            break;\n\n          case core_1.experimental.jobs.JobInboundMessageKind.Input:\n            if (!tearingDown) {\n              onInput(i.value);\n            }\n\n            break;\n        }\n      });\n\n      function onInput(i) {\n        const builder = i.info;\n        const loggerName = i.target ? (0, api_1.targetStringFromTarget)(i.target) : builder.builderName;\n        const logger = new core_1.logging.Logger(loggerName);\n        subscriptions.push(logger.subscribe(entry => log(entry)));\n        const context = {\n          builder,\n          workspaceRoot: i.workspaceRoot,\n          currentDirectory: i.currentDirectory,\n          target: i.target,\n          logger: logger,\n          id: i.id,\n\n          scheduleTarget(target, overrides = {}, scheduleOptions = {}) {\n            return _asyncToGenerator(function* () {\n              const run = yield (0, schedule_by_name_1.scheduleByTarget)(target, overrides, {\n                scheduler,\n                logger: scheduleOptions.logger || logger.createChild(''),\n                workspaceRoot: i.workspaceRoot,\n                currentDirectory: i.currentDirectory\n              }); // We don't want to subscribe errors and complete.\n\n              subscriptions.push(run.progress.subscribe(event => progressChannel.next(event)));\n              return run;\n            })();\n          },\n\n          scheduleBuilder(builderName, options = {}, scheduleOptions = {}) {\n            return _asyncToGenerator(function* () {\n              const run = yield (0, schedule_by_name_1.scheduleByName)(builderName, options, {\n                scheduler,\n                target: scheduleOptions.target,\n                logger: scheduleOptions.logger || logger.createChild(''),\n                workspaceRoot: i.workspaceRoot,\n                currentDirectory: i.currentDirectory\n              }); // We don't want to subscribe errors and complete.\n\n              subscriptions.push(run.progress.subscribe(event => progressChannel.next(event)));\n              return run;\n            })();\n          },\n\n          getTargetOptions(target) {\n            return _asyncToGenerator(function* () {\n              return scheduler.schedule('..getTargetOptions', target).output.toPromise();\n            })();\n          },\n\n          getProjectMetadata(target) {\n            return _asyncToGenerator(function* () {\n              return scheduler.schedule('..getProjectMetadata', target).output.toPromise();\n            })();\n          },\n\n          getBuilderNameForTarget(target) {\n            return _asyncToGenerator(function* () {\n              return scheduler.schedule('..getBuilderNameForTarget', target).output.toPromise();\n            })();\n          },\n\n          validateOptions(options, builderName) {\n            return _asyncToGenerator(function* () {\n              return scheduler.schedule('..validateOptions', [builderName, options]).output.toPromise();\n            })();\n          },\n\n          reportRunning() {\n            switch (currentState) {\n              case api_1.BuilderProgressState.Waiting:\n              case api_1.BuilderProgressState.Stopped:\n                progress({\n                  state: api_1.BuilderProgressState.Running,\n                  current: 0,\n                  total\n                }, context);\n                break;\n            }\n          },\n\n          reportStatus(status) {\n            switch (currentState) {\n              case api_1.BuilderProgressState.Running:\n                progress({\n                  state: currentState,\n                  status,\n                  current,\n                  total\n                }, context);\n                break;\n\n              case api_1.BuilderProgressState.Waiting:\n                progress({\n                  state: currentState,\n                  status\n                }, context);\n                break;\n            }\n          },\n\n          reportProgress(current, total, status) {\n            switch (currentState) {\n              case api_1.BuilderProgressState.Running:\n                progress({\n                  state: currentState,\n                  current,\n                  total,\n                  status\n                }, context);\n            }\n          },\n\n          analytics: new core_1.analytics.ForwardingAnalytics(report => analyticsChannel.next(report)),\n\n          addTeardown(teardown) {\n            teardownLogics.push(teardown);\n          }\n\n        };\n        context.reportRunning();\n        let result;\n\n        try {\n          result = fn(i.options, context);\n\n          if ((0, api_1.isBuilderOutput)(result)) {\n            result = (0, rxjs_1.of)(result);\n          } else if (!(0, rxjs_1.isObservable)(result) && isAsyncIterable(result)) {\n            result = (0, api_1.fromAsyncIterable)(result);\n          } else {\n            result = (0, rxjs_1.from)(result);\n          }\n        } catch (e) {\n          result = (0, rxjs_1.throwError)(e);\n        } // Manage some state automatically.\n\n\n        progress({\n          state: api_1.BuilderProgressState.Running,\n          current: 0,\n          total: 1\n        }, context);\n        subscriptions.push(result.pipe((0, operators_1.tap)(() => {\n          progress({\n            state: api_1.BuilderProgressState.Running,\n            current: total\n          }, context);\n          progress({\n            state: api_1.BuilderProgressState.Stopped\n          }, context);\n        }), (0, operators_1.mergeMap)( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (value) {\n            // Allow the log queue to flush\n            yield new Promise(setImmediate);\n            return value;\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }())).subscribe(message => observer.next(message), error => observer.error(error), () => observer.complete()));\n      }\n\n      return () => {\n        subscriptions.forEach(x => x.unsubscribe());\n        inputSubscription.unsubscribe();\n      };\n    });\n  });\n  return {\n    handler,\n    [internal_1.BuilderSymbol]: true,\n    [internal_1.BuilderVersionSymbol]: require('../package.json').version\n  };\n}\n\nexports.createBuilder = createBuilder;\n\nfunction isAsyncIterable(obj) {\n  return !!obj && typeof obj[Symbol.asyncIterator] === 'function';\n}","map":null,"metadata":{},"sourceType":"script"}