{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  HttpErrorAuthOTP\n} = require('./errors.js');\n\nconst checkResponse = require('./check-response.js');\n\nconst getAuth = require('./auth.js');\n\nconst fetch = require('make-fetch-happen');\n\nconst JSONStream = require('minipass-json-stream');\n\nconst npa = require('npm-package-arg');\n\nconst qs = require('querystring');\n\nconst url = require('url');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst defaultOpts = require('./default-opts.js'); // WhatWG URL throws if it's not fully resolved\n\n\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u);\n  } catch (_) {\n    return false;\n  }\n};\n\nmodule.exports = regFetch;\n\nfunction regFetch(uri,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  }; // if we did not get a fully qualified URI, then we look at the registry\n  // config or relevant scope to resolve it.\n\n  const uriValid = urlIsValid(uri);\n  let registry = opts.registry || defaultOpts.registry;\n\n  if (!uriValid) {\n    registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry || registry;\n    uri = `${registry.trim().replace(/\\/?$/g, '')}/${uri.trim().replace(/^\\//, '')}`; // asserts that this is now valid\n\n    new url.URL(uri);\n  }\n\n  const method = opts.method || 'GET'; // through that takes into account the scope, the prefix of `uri`, etc\n\n  const startTime = Date.now();\n  const auth = getAuth(uri, opts);\n  const headers = getHeaders(uri, auth, opts);\n  let body = opts.body;\n  const bodyIsStream = Minipass.isStream(body);\n  const bodyIsPromise = body && typeof body === 'object' && typeof body.then === 'function';\n\n  if (body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json';\n    body = JSON.stringify(body);\n  } else if (body && !headers['content-type']) {\n    headers['content-type'] = 'application/octet-stream';\n  }\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip';\n\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip();\n      body.on('error',\n      /* istanbul ignore next: unlikely and hard to test */\n      err => gz.emit('error', err));\n      body = body.pipe(gz);\n    } else if (!bodyIsPromise) {\n      body = new zlib.Gzip().end(body).concat();\n    }\n  }\n\n  const parsed = new url.URL(uri);\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query) : opts.query;\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) {\n        parsed.searchParams.set(key, q[key]);\n      }\n    });\n    uri = url.format(parsed);\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false;\n    opts.preferOffline = false;\n    opts.preferOnline = true;\n  }\n\n  const doFetch = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (fetchBody) {\n      const p = fetch(uri, {\n        agent: opts.agent,\n        algorithms: opts.algorithms,\n        body: fetchBody,\n        cache: getCacheMode(opts),\n        cachePath: opts.cache,\n        ca: opts.ca,\n        cert: auth.cert || opts.cert,\n        headers,\n        integrity: opts.integrity,\n        key: auth.key || opts.key,\n        localAddress: opts.localAddress,\n        maxSockets: opts.maxSockets,\n        memoize: opts.memoize,\n        method: method,\n        noProxy: opts.noProxy,\n        proxy: opts.httpsProxy || opts.proxy,\n        retry: opts.retry ? opts.retry : {\n          retries: opts.fetchRetries,\n          factor: opts.fetchRetryFactor,\n          minTimeout: opts.fetchRetryMintimeout,\n          maxTimeout: opts.fetchRetryMaxtimeout\n        },\n        strictSSL: opts.strictSSL,\n        timeout: opts.timeout || 30 * 1000\n      }).then(res => checkResponse({\n        method,\n        uri,\n        res,\n        registry,\n        startTime,\n        auth,\n        opts\n      }));\n\n      if (typeof opts.otpPrompt === 'function') {\n        return p.catch( /*#__PURE__*/function () {\n          var _ref2 = _asyncToGenerator(function* (er) {\n            if (er instanceof HttpErrorAuthOTP) {\n              let otp; // if otp fails to complete, we fail with that failure\n\n              try {\n                otp = yield opts.otpPrompt();\n              } catch (_) {// ignore this error\n              } // if no otp provided, or otpPrompt errored, throw the original HTTP error\n\n\n              if (!otp) {\n                throw er;\n              }\n\n              return regFetch(uri, { ...opts,\n                otp\n              });\n            }\n\n            throw er;\n          });\n\n          return function (_x2) {\n            return _ref2.apply(this, arguments);\n          };\n        }());\n      } else {\n        return p;\n      }\n    });\n\n    return function doFetch(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return Promise.resolve(body).then(doFetch);\n}\n\nmodule.exports.json = fetchJSON;\n\nfunction fetchJSON(uri, opts) {\n  return regFetch(uri, opts).then(res => res.json());\n}\n\nmodule.exports.json.stream = fetchJSONStream;\n\nfunction fetchJSONStream(uri, jsonPath,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  };\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON);\n  regFetch(uri, opts).then(res => res.body.on('error',\n  /* istanbul ignore next: unlikely and difficult to test */\n  er => parser.emit('error', er)).pipe(parser)).catch(er => parser.emit('error', er));\n  return parser;\n}\n\nmodule.exports.pickRegistry = pickRegistry;\n\nfunction pickRegistry(spec, opts = {}) {\n  spec = npa(spec);\n  let registry = spec.scope && opts[spec.scope.replace(/^@?/, '@') + ':registry'];\n\n  if (!registry && opts.scope) {\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry'];\n  }\n\n  if (!registry) {\n    registry = opts.registry || defaultOpts.registry;\n  }\n\n  return registry;\n}\n\nfunction getCacheMode(opts) {\n  return opts.offline ? 'only-if-cached' : opts.preferOffline ? 'force-cache' : opts.preferOnline ? 'no-cache' : 'default';\n}\n\nfunction getHeaders(uri, auth, opts) {\n  const headers = Object.assign({\n    'user-agent': opts.userAgent\n  }, opts.headers || {});\n\n  if (opts.authType) {\n    headers['npm-auth-type'] = opts.authType;\n  }\n\n  if (opts.scope) {\n    headers['npm-scope'] = opts.scope;\n  }\n\n  if (opts.npmSession) {\n    headers['npm-session'] = opts.npmSession;\n  }\n\n  if (opts.npmCommand) {\n    headers['npm-command'] = opts.npmCommand;\n  } // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n\n\n  if (auth.token) {\n    headers.authorization = `Bearer ${auth.token}`;\n  } else if (auth.auth) {\n    headers.authorization = `Basic ${auth.auth}`;\n  }\n\n  if (opts.otp) {\n    headers['npm-otp'] = opts.otp;\n  }\n\n  return headers;\n}\n\nmodule.exports.cleanUrl = require('./clean-url.js');","map":null,"metadata":{},"sourceType":"script"}