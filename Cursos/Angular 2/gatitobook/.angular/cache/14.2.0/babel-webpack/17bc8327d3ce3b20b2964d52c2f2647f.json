{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst path = require('path');\n\nconst childProcess = require('child_process');\n\nconst {\n  promises: fs,\n  constants: fsConstants\n} = require('fs');\n\nconst isWsl = require('is-wsl');\n\nconst isDocker = require('is-docker');\n\nconst defineLazyProperty = require('define-lazy-prop'); // Path to included `xdg-open`.\n\n\nconst localXdgOpenPath = path.join(__dirname, 'xdg-open');\nconst {\n  platform,\n  arch\n} = process;\n/**\nGet the mount point for fixed drives in WSL.\n\n@inner\n@returns {string} The mount point.\n*/\n\nconst getWslDrivesMountPoint = (() => {\n  // Default value for \"root\" param\n  // according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config\n  const defaultMountPoint = '/mnt/';\n  let mountPoint;\n  return /*#__PURE__*/_asyncToGenerator(function* () {\n    if (mountPoint) {\n      // Return memoized mount point value\n      return mountPoint;\n    }\n\n    const configFilePath = '/etc/wsl.conf';\n    let isConfigFileExists = false;\n\n    try {\n      yield fs.access(configFilePath, fsConstants.F_OK);\n      isConfigFileExists = true;\n    } catch {}\n\n    if (!isConfigFileExists) {\n      return defaultMountPoint;\n    }\n\n    const configContent = yield fs.readFile(configFilePath, {\n      encoding: 'utf8'\n    });\n    const configMountPoint = /(?<!#.*)root\\s*=\\s*(?<mountPoint>.*)/g.exec(configContent);\n\n    if (!configMountPoint) {\n      return defaultMountPoint;\n    }\n\n    mountPoint = configMountPoint.groups.mountPoint.trim();\n    mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint}/`;\n    return mountPoint;\n  });\n})();\n\nconst pTryEach = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (array, mapper) {\n    let latestError;\n\n    for (const item of array) {\n      try {\n        return yield mapper(item); // eslint-disable-line no-await-in-loop\n      } catch (error) {\n        latestError = error;\n      }\n    }\n\n    throw latestError;\n  });\n\n  return function pTryEach(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst baseOpen = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator(function* (options) {\n    options = {\n      wait: false,\n      background: false,\n      newInstance: false,\n      allowNonzeroExitCode: false,\n      ...options\n    };\n\n    if (Array.isArray(options.app)) {\n      return pTryEach(options.app, singleApp => baseOpen({ ...options,\n        app: singleApp\n      }));\n    }\n\n    let {\n      name: app,\n      arguments: appArguments = []\n    } = options.app || {};\n    appArguments = [...appArguments];\n\n    if (Array.isArray(app)) {\n      return pTryEach(app, appName => baseOpen({ ...options,\n        app: {\n          name: appName,\n          arguments: appArguments\n        }\n      }));\n    }\n\n    let command;\n    const cliArguments = [];\n    const childProcessOptions = {};\n\n    if (platform === 'darwin') {\n      command = 'open';\n\n      if (options.wait) {\n        cliArguments.push('--wait-apps');\n      }\n\n      if (options.background) {\n        cliArguments.push('--background');\n      }\n\n      if (options.newInstance) {\n        cliArguments.push('--new');\n      }\n\n      if (app) {\n        cliArguments.push('-a', app);\n      }\n    } else if (platform === 'win32' || isWsl && !isDocker()) {\n      const mountPoint = yield getWslDrivesMountPoint();\n      command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell`;\n      cliArguments.push('-NoProfile', '-NonInteractive', 'â€“ExecutionPolicy', 'Bypass', '-EncodedCommand');\n\n      if (!isWsl) {\n        childProcessOptions.windowsVerbatimArguments = true;\n      }\n\n      const encodedArguments = ['Start'];\n\n      if (options.wait) {\n        encodedArguments.push('-Wait');\n      }\n\n      if (app) {\n        // Double quote with double quotes to ensure the inner quotes are passed through.\n        // Inner quotes are delimited for PowerShell interpretation with backticks.\n        encodedArguments.push(`\"\\`\"${app}\\`\"\"`, '-ArgumentList');\n\n        if (options.target) {\n          appArguments.unshift(options.target);\n        }\n      } else if (options.target) {\n        encodedArguments.push(`\"${options.target}\"`);\n      }\n\n      if (appArguments.length > 0) {\n        appArguments = appArguments.map(arg => `\"\\`\"${arg}\\`\"\"`);\n        encodedArguments.push(appArguments.join(','));\n      } // Using Base64-encoded command, accepted by PowerShell, to allow special characters.\n\n\n      options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');\n    } else {\n      if (app) {\n        command = app;\n      } else {\n        // When bundled by Webpack, there's no actual package file path and no local `xdg-open`.\n        const isBundled = !__dirname || __dirname === '/'; // Check if local `xdg-open` exists and is executable.\n\n        let exeLocalXdgOpen = false;\n\n        try {\n          yield fs.access(localXdgOpenPath, fsConstants.X_OK);\n          exeLocalXdgOpen = true;\n        } catch {}\n\n        const useSystemXdgOpen = process.versions.electron || platform === 'android' || isBundled || !exeLocalXdgOpen;\n        command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;\n      }\n\n      if (appArguments.length > 0) {\n        cliArguments.push(...appArguments);\n      }\n\n      if (!options.wait) {\n        // `xdg-open` will block the process unless stdio is ignored\n        // and it's detached from the parent even if it's unref'd.\n        childProcessOptions.stdio = 'ignore';\n        childProcessOptions.detached = true;\n      }\n    }\n\n    if (options.target) {\n      cliArguments.push(options.target);\n    }\n\n    if (platform === 'darwin' && appArguments.length > 0) {\n      cliArguments.push('--args', ...appArguments);\n    }\n\n    const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);\n\n    if (options.wait) {\n      return new Promise((resolve, reject) => {\n        subprocess.once('error', reject);\n        subprocess.once('close', exitCode => {\n          if (options.allowNonzeroExitCode && exitCode > 0) {\n            reject(new Error(`Exited with code ${exitCode}`));\n            return;\n          }\n\n          resolve(subprocess);\n        });\n      });\n    }\n\n    subprocess.unref();\n    return subprocess;\n  });\n\n  return function baseOpen(_x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nconst open = (target, options) => {\n  if (typeof target !== 'string') {\n    throw new TypeError('Expected a `target`');\n  }\n\n  return baseOpen({ ...options,\n    target\n  });\n};\n\nconst openApp = (name, options) => {\n  if (typeof name !== 'string') {\n    throw new TypeError('Expected a `name`');\n  }\n\n  const {\n    arguments: appArguments = []\n  } = options || {};\n\n  if (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {\n    throw new TypeError('Expected `appArguments` as Array type');\n  }\n\n  return baseOpen({ ...options,\n    app: {\n      name,\n      arguments: appArguments\n    }\n  });\n};\n\nfunction detectArchBinary(binary) {\n  if (typeof binary === 'string' || Array.isArray(binary)) {\n    return binary;\n  }\n\n  const {\n    [arch]: archBinary\n  } = binary;\n\n  if (!archBinary) {\n    throw new Error(`${arch} is not supported`);\n  }\n\n  return archBinary;\n}\n\nfunction detectPlatformBinary({\n  [platform]: platformBinary\n}, {\n  wsl\n}) {\n  if (wsl && isWsl) {\n    return detectArchBinary(wsl);\n  }\n\n  if (!platformBinary) {\n    throw new Error(`${platform} is not supported`);\n  }\n\n  return detectArchBinary(platformBinary);\n}\n\nconst apps = {};\ndefineLazyProperty(apps, 'chrome', () => detectPlatformBinary({\n  darwin: 'google chrome',\n  win32: 'chrome',\n  linux: ['google-chrome', 'google-chrome-stable', 'chromium']\n}, {\n  wsl: {\n    ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',\n    x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe']\n  }\n}));\ndefineLazyProperty(apps, 'firefox', () => detectPlatformBinary({\n  darwin: 'firefox',\n  win32: 'C:\\\\Program Files\\\\Mozilla Firefox\\\\firefox.exe',\n  linux: 'firefox'\n}, {\n  wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'\n}));\ndefineLazyProperty(apps, 'edge', () => detectPlatformBinary({\n  darwin: 'microsoft edge',\n  win32: 'msedge',\n  linux: ['microsoft-edge', 'microsoft-edge-dev']\n}, {\n  wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'\n}));\nopen.apps = apps;\nopen.openApp = openApp;\nmodule.exports = open;","map":null,"metadata":{},"sourceType":"script"}