{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\n\nconst Negotiator = require('negotiator');\n\nconst ssri = require('ssri'); // options passed to http-cache-semantics constructor\n\n\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n}; // a fake empty response, used when only testing the\n// request for storability\n\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n}; // returns a plain object representation of the Request\n\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n    compress: request.compress\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n}; // returns a plain object representation of the Response\n\n\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\nclass CachePolicy {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  } // static method to quickly determine if a request alone is storable\n\n\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) {\n      return false;\n    } // user explicitly asked not to cache\n\n\n    if (options.cache === 'no-store') {\n      return false;\n    } // we only cache GET and HEAD requests\n\n\n    if (!['GET', 'HEAD'].includes(request.method)) {\n      return false;\n    } // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n\n\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  } // returns true if the policy satisfies the request\n\n\n  satisfies(request) {\n    const _req = requestObject(request);\n\n    if (this.request.headers.host !== _req.headers.host) {\n      return false;\n    }\n\n    if (this.request.compress !== _req.compress) {\n      return false;\n    }\n\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {\n      return false;\n    }\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {\n      return false;\n    }\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {\n      return false;\n    }\n\n    if (this.options.integrity) {\n      return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    }\n\n    return true;\n  } // returns true if the request and response allow caching\n\n\n  storable() {\n    return this.policy.storable();\n  } // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n\n\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  } // returns true if the cached response requires revalidation\n  // for the given request\n\n\n  needsRevalidation(request) {\n    const _req = requestObject(request); // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n\n\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  } // returns a new object containing the appropriate headers\n  // to send a revalidation request\n\n\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n\n    return this.policy.revalidationHeaders(_req);\n  } // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n\n\n  revalidated(request, response) {\n    const _req = requestObject(request);\n\n    const _res = responseObject(response);\n\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n\n}\n\nmodule.exports = CachePolicy;","map":null,"metadata":{},"sourceType":"script"}