{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Minipass = require('minipass');\n\nconst MinipassSized = require('minipass-sized');\n\nconst Blob = require('./blob.js');\n\nconst {\n  BUFFER\n} = Blob;\n\nconst FetchError = require('./fetch-error.js'); // optional dependency on 'encoding'\n\n\nlet convert;\n\ntry {\n  convert = require('encoding').convert;\n} catch (e) {// defer error until textConverted is called\n}\n\nconst INTERNALS = Symbol('Body internals');\nconst CONSUME_BODY = Symbol('consumeBody');\n\nclass Body {\n  constructor(bodyArg, options = {}) {\n    const {\n      size = 0,\n      timeout = 0\n    } = options;\n    const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n\n  get body() {\n    return this[INTERNALS].body;\n  }\n\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n\n  arrayBuffer() {\n    return this[CONSUME_BODY]().then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  }\n\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return this[CONSUME_BODY]().then(buf => Object.assign(new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  }\n\n  json() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const buf = yield _this[CONSUME_BODY]();\n\n      try {\n        return JSON.parse(buf.toString());\n      } catch (er) {\n        throw new FetchError(`invalid json response body at ${_this.url} reason: ${er.message}`, 'invalid-json');\n      }\n    })();\n  }\n\n  text() {\n    return this[CONSUME_BODY]().then(buf => buf.toString());\n  }\n\n  buffer() {\n    return this[CONSUME_BODY]();\n  }\n\n  textConverted() {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers));\n  }\n\n  [CONSUME_BODY]() {\n    if (this[INTERNALS].disturbed) {\n      return Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n\n    this[INTERNALS].disturbed = true;\n\n    if (this[INTERNALS].error) {\n      return Promise.reject(this[INTERNALS].error);\n    } // body is null\n\n\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n\n    if (Buffer.isBuffer(this.body)) {\n      return Promise.resolve(this.body);\n    }\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body;\n    /* istanbul ignore if: should never happen */\n\n    if (!Minipass.isStream(upstream)) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({\n      size: this.size\n    }) : new Minipass(); // allow timeout on slow response body, but only if the stream is still writable. this\n    // makes the timeout center on the socket stream from lib/index.js rather than the\n    // intermediary minipass stream we create to receive the data\n\n    const resTimeout = this.timeout && stream.writable ? setTimeout(() => {\n      stream.emit('error', new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n    }, this.timeout) : null; // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n\n    if (resTimeout && resTimeout.unref) {\n      resTimeout.unref();\n    } // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n\n\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er));\n        upstream.pipe(stream);\n      }\n\n      resolve();\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout);\n      return buf;\n    }).catch(er => {\n      clearTimeout(resTimeout); // request was aborted, reject with this Error\n\n      if (er.name === 'AbortError' || er.name === 'FetchError') {\n        throw er;\n      } else if (er.name === 'RangeError') {\n        throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, 'system', er);\n      } else {\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n      }\n    });\n  }\n\n  static clone(instance) {\n    if (instance.bodyUsed) {\n      throw new Error('cannot clone body after it is used');\n    }\n\n    const body = instance.body; // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass();\n      const p1 = new Minipass();\n      const p2 = new Minipass();\n      tee.on('error', er => {\n        p1.emit('error', er);\n        p2.emit('error', er);\n      });\n      body.on('error', er => tee.emit('error', er));\n      tee.pipe(p1);\n      tee.pipe(p2);\n      body.pipe(tee); // set instance body to one fork, return the other\n\n      instance[INTERNALS].body = p1;\n      return p2;\n    } else {\n      return instance.body;\n    }\n  }\n\n  static extractContentType(body) {\n    return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';\n  }\n\n  static getTotalBytes(instance) {\n    const {\n      body\n    } = instance;\n    return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && ( // detect form data input from form-data module\n    body._lengthRetrievers &&\n    /* istanbul ignore next */\n    body._lengthRetrievers.length === 0 || // 1.x\n    body.hasKnownLength && body.hasKnownLength()) // 2.x\n    ? body.getLengthSync() : null;\n  }\n\n  static writeToStream(dest, instance) {\n    const {\n      body\n    } = instance;\n\n    if (body === null || body === undefined) {\n      dest.end();\n    } else if (Buffer.isBuffer(body) || typeof body === 'string') {\n      dest.end(body);\n    } else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body;\n      stream.on('error', er => dest.emit('error', er)).pipe(dest);\n    }\n\n    return dest;\n  }\n\n}\n\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\n\nconst isURLSearchParams = obj => // Duck-typing as a necessary condition.\ntypeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false // Brand-checking and more duck-typing as optional condition.\n: obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n\nconst isBlob = obj => typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  }\n\n  const ct = headers && headers.get('content-type');\n  let charset = 'utf-8';\n  let res; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n\n  const str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\n      if (res) {\n        res.pop();\n      } // drop last quote\n\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n};\n\nmodule.exports = Body;","map":null,"metadata":{},"sourceType":"script"}