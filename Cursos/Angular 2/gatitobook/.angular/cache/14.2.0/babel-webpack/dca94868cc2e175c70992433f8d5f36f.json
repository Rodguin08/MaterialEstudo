{"ast":null,"code":"'use strict';\n\nconst {\n  URL\n} = require('url');\n\nconst Minipass = require('minipass');\n\nconst Headers = require('./headers.js');\n\nconst {\n  exportNodeCompatibleHeaders\n} = Headers;\n\nconst Body = require('./body.js');\n\nconst {\n  clone,\n  extractContentType,\n  getTotalBytes\n} = Body;\n\nconst version = require('../package.json').version;\n\nconst defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;\nconst INTERNALS = Symbol('Request internals');\n\nconst isRequest = input => typeof input === 'object' && typeof input[INTERNALS] === 'object';\n\nconst isAbortSignal = signal => {\n  const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n  return !!(proto && proto.constructor.name === 'AbortSignal');\n};\n\nclass Request extends Body {\n  constructor(input, init = {}) {\n    const parsedURL = isRequest(input) ? new URL(input.url) : input && input.href ? new URL(input.href) : new URL(`${input}`);\n\n    if (isRequest(input)) {\n      init = { ...input[INTERNALS],\n        ...init\n      };\n    } else if (!input || typeof input === 'string') {\n      input = {};\n    }\n\n    const method = (init.method || input.method || 'GET').toUpperCase();\n    const isGETHEAD = method === 'GET' || method === 'HEAD';\n\n    if ((init.body !== null && init.body !== undefined || isRequest(input) && input.body !== null) && isGETHEAD) {\n      throw new TypeError('Request with GET/HEAD method cannot have body');\n    }\n\n    const inputBody = init.body !== null && init.body !== undefined ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n\n    if (inputBody !== null && inputBody !== undefined && !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody);\n\n      if (contentType) {\n        headers.append('Content-Type', contentType);\n      }\n    }\n\n    const signal = 'signal' in init ? init.signal : null;\n\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal)) {\n      throw new TypeError('Expected signal must be an instanceof AbortSignal');\n    } // TLS specific options that are handled by node\n\n\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !== '0',\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = init;\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    }; // node-fetch-only options\n\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n  }\n\n  get method() {\n    return this[INTERNALS].method;\n  }\n\n  get url() {\n    return this[INTERNALS].parsedURL.toString();\n  }\n\n  get headers() {\n    return this[INTERNALS].headers;\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect;\n  }\n\n  get signal() {\n    return this[INTERNALS].signal;\n  }\n\n  clone() {\n    return new Request(this);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Request';\n  }\n\n  static getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS].parsedURL;\n    const headers = new Headers(request[INTERNALS].headers); // fetch step 1.3\n\n    if (!headers.has('Accept')) {\n      headers.set('Accept', '*/*');\n    } // Basic fetch\n\n\n    if (!/^https?:$/.test(parsedURL.protocol)) {\n      throw new TypeError('Only HTTP(S) protocols are supported');\n    }\n\n    if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== 'function') {\n      throw new Error('Cancellation of streamed requests with AbortSignal is not supported');\n    } // HTTP-network-or-cache fetch steps 2.4-2.7\n\n\n    const contentLengthValue = (request.body === null || request.body === undefined) && /^(POST|PUT)$/i.test(request.method) ? '0' : request.body !== null && request.body !== undefined ? getTotalBytes(request) : null;\n\n    if (contentLengthValue) {\n      headers.set('Content-Length', contentLengthValue + '');\n    } // HTTP-network-or-cache fetch step 2.11\n\n\n    if (!headers.has('User-Agent')) {\n      headers.set('User-Agent', defaultUserAgent);\n    } // HTTP-network-or-cache fetch step 2.15\n\n\n    if (request.compress && !headers.has('Accept-Encoding')) {\n      headers.set('Accept-Encoding', 'gzip,deflate');\n    }\n\n    const agent = typeof request.agent === 'function' ? request.agent(parsedURL) : request.agent;\n\n    if (!headers.has('Connection') && !agent) {\n      headers.set('Connection', 'close');\n    } // TLS specific options that are handled by node\n\n\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = request[INTERNALS]; // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n    // we cannot spread parsedURL directly, so we have to read each property one-by-one\n    // and map them to the equivalent https?.request() method options\n\n    const urlProps = {\n      auth: parsedURL.username || parsedURL.password ? `${parsedURL.username}:${parsedURL.password}` : '',\n      host: parsedURL.host,\n      hostname: parsedURL.hostname,\n      path: `${parsedURL.pathname}${parsedURL.search}`,\n      port: parsedURL.port,\n      protocol: parsedURL.protocol\n    };\n    return { ...urlProps,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      family,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    };\n  }\n\n}\n\nmodule.exports = Request;\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  }\n});","map":null,"metadata":{},"sourceType":"script"}