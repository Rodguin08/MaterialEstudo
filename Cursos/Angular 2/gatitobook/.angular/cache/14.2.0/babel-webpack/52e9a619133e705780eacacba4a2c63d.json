{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  URL\n} = require('url'); // Find the longest registry key that is used for some kind of auth\n// in the options.\n\n\nconst regKeyFromURI = (uri, opts) => {\n  const parsed = new URL(uri); // try to find a config key indicating we have auth for this registry\n  // can be one of :_authToken, :_auth, :_password and :username, or\n  // :certfile and :keyfile\n  // We walk up the \"path\" until we're left with just //<host>[:<port>],\n  // stopping when we reach '//'.\n\n  let regKey = `//${parsed.host}${parsed.pathname}`;\n\n  while (regKey.length > '//'.length) {\n    // got some auth for this URI\n    if (hasAuth(regKey, opts)) {\n      return regKey;\n    } // can be either //host/some/path/:_auth or //host/some/path:_auth\n    // walk up by removing EITHER what's after the slash OR the slash itself\n\n\n    regKey = regKey.replace(/([^/]+|\\/)$/, '');\n  }\n};\n\nconst hasAuth = (regKey, opts) => opts[`${regKey}:_authToken`] || opts[`${regKey}:_auth`] || opts[`${regKey}:username`] && opts[`${regKey}:_password`] || opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`];\n\nconst sameHost = (a, b) => {\n  const parsedA = new URL(a);\n  const parsedB = new URL(b);\n  return parsedA.host === parsedB.host;\n};\n\nconst getRegistry = opts => {\n  const {\n    spec\n  } = opts;\n  const {\n    scope: specScope,\n    subSpec\n  } = spec ? npa(spec) : {};\n  const subSpecScope = subSpec && subSpec.scope;\n  const scope = subSpec ? subSpecScope : specScope;\n  const scopeReg = scope && opts[`${scope}:registry`];\n  return scopeReg || opts.registry;\n};\n\nconst maybeReadFile = file => {\n  try {\n    return fs.readFileSync(file, 'utf8');\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er;\n    }\n\n    return null;\n  }\n};\n\nconst getAuth = (uri, opts = {}) => {\n  const {\n    forceAuth\n  } = opts;\n\n  if (!uri) {\n    throw new Error('URI is required');\n  }\n\n  const regKey = regKeyFromURI(uri, forceAuth || opts); // we are only allowed to use what's in forceAuth if specified\n\n  if (forceAuth && !regKey) {\n    return new Auth({\n      scopeAuthKey: null,\n      token: forceAuth._authToken || forceAuth.token,\n      username: forceAuth.username,\n      password: forceAuth._password || forceAuth.password,\n      auth: forceAuth._auth || forceAuth.auth,\n      certfile: forceAuth.certfile,\n      keyfile: forceAuth.keyfile\n    });\n  } // no auth for this URI, but might have it for the registry\n\n\n  if (!regKey) {\n    const registry = getRegistry(opts);\n\n    if (registry && uri !== registry && sameHost(uri, registry)) {\n      return getAuth(registry, opts);\n    } else if (registry !== opts.registry) {\n      // If making a tarball request to a different base URI than the\n      // registry where we logged in, but the same auth SHOULD be sent\n      // to that artifact host, then we track where it was coming in from,\n      // and warn the user if we get a 4xx error on it.\n      const scopeAuthKey = regKeyFromURI(registry, opts);\n      return new Auth({\n        scopeAuthKey\n      });\n    }\n  }\n\n  const {\n    [`${regKey}:_authToken`]: token,\n    [`${regKey}:username`]: username,\n    [`${regKey}:_password`]: password,\n    [`${regKey}:_auth`]: auth,\n    [`${regKey}:certfile`]: certfile,\n    [`${regKey}:keyfile`]: keyfile\n  } = opts;\n  return new Auth({\n    scopeAuthKey: null,\n    token,\n    auth,\n    username,\n    password,\n    certfile,\n    keyfile\n  });\n};\n\nclass Auth {\n  constructor({\n    token,\n    auth,\n    username,\n    password,\n    scopeAuthKey,\n    certfile,\n    keyfile\n  }) {\n    this.scopeAuthKey = scopeAuthKey;\n    this.token = null;\n    this.auth = null;\n    this.isBasicAuth = false;\n    this.cert = null;\n    this.key = null;\n\n    if (token) {\n      this.token = token;\n    } else if (auth) {\n      this.auth = auth;\n    } else if (username && password) {\n      const p = Buffer.from(password, 'base64').toString('utf8');\n      this.auth = Buffer.from(`${username}:${p}`, 'utf8').toString('base64');\n      this.isBasicAuth = true;\n    } // mTLS may be used in conjunction with another auth method above\n\n\n    if (certfile && keyfile) {\n      const cert = maybeReadFile(certfile, 'utf-8');\n      const key = maybeReadFile(keyfile, 'utf-8');\n\n      if (cert && key) {\n        this.cert = cert;\n        this.key = key;\n      }\n    }\n  }\n\n}\n\nmodule.exports = getAuth;","map":null,"metadata":{},"sourceType":"script"}