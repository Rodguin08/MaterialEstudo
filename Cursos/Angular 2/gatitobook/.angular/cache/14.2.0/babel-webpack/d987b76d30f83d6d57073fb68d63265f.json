{"ast":null,"code":"/* eslint-disable node/no-deprecated-api */\n'use strict';\n\nconst semver = require('semver');\n\nconst url = require('url');\n\nconst path = require('path');\n\nconst log = require('npmlog'); // versions where -headers.tar.gz started shipping\n\n\nconst headersTarballRange = '>= 3.0.0 || ~0.12.10 || ~0.10.42';\nconst bitsre = /\\/win-(x86|x64|arm64)\\//;\nconst bitsreV3 = /\\/win-(x86|ia32|x64)\\//; // io.js v3.x.x shipped with \"ia32\" but should\n// have been \"x86\"\n// Captures all the logic required to determine download URLs, local directory and\n// file names. Inputs come from command-line switches (--target, --dist-url),\n// `process.version` and `process.release` where it exists.\n\nfunction processRelease(argv, gyp, defaultVersion, defaultRelease) {\n  var version = semver.valid(argv[0]) && argv[0] || gyp.opts.target || defaultVersion;\n  var versionSemver = semver.parse(version);\n  var overrideDistUrl = gyp.opts['dist-url'] || gyp.opts.disturl;\n  var isDefaultVersion;\n  var isNamedForLegacyIojs;\n  var name;\n  var distBaseUrl;\n  var baseUrl;\n  var libUrl32;\n  var libUrl64;\n  var libUrlArm64;\n  var tarballUrl;\n  var canGetHeaders;\n\n  if (!versionSemver) {\n    // not a valid semver string, nothing we can do\n    return {\n      version: version\n    };\n  } // flatten version into String\n\n\n  version = versionSemver.version; // defaultVersion should come from process.version so ought to be valid semver\n\n  isDefaultVersion = version === semver.parse(defaultVersion).version; // can't use process.release if we're using --target=x.y.z\n\n  if (!isDefaultVersion) {\n    defaultRelease = null;\n  }\n\n  if (defaultRelease) {\n    // v3 onward, has process.release\n    name = defaultRelease.name.replace(/io\\.js/, 'iojs'); // remove the '.' for directory naming purposes\n  } else {\n    // old node or alternative --target=\n    // semver.satisfies() doesn't like prerelease tags so test major directly\n    isNamedForLegacyIojs = versionSemver.major >= 1 && versionSemver.major < 4; // isNamedForLegacyIojs is required to support Electron < 4 (in particular Electron 3)\n    // as previously this logic was used to ensure \"iojs\" was used to download iojs releases\n    // and \"node\" for node releases.  Unfortunately the logic was broad enough that electron@3\n    // published release assets as \"iojs\" so that the node-gyp logic worked.  Once Electron@3 has\n    // been EOL for a while (late 2019) we should remove this hack.\n\n    name = isNamedForLegacyIojs ? 'iojs' : 'node';\n  } // check for the nvm.sh standard mirror env variables\n\n\n  if (!overrideDistUrl && process.env.NODEJS_ORG_MIRROR) {\n    overrideDistUrl = process.env.NODEJS_ORG_MIRROR;\n  }\n\n  if (overrideDistUrl) {\n    log.verbose('download', 'using dist-url', overrideDistUrl);\n  }\n\n  if (overrideDistUrl) {\n    distBaseUrl = overrideDistUrl.replace(/\\/+$/, '');\n  } else {\n    distBaseUrl = 'https://nodejs.org/dist';\n  }\n\n  distBaseUrl += '/v' + version + '/'; // new style, based on process.release so we have a lot of the data we need\n\n  if (defaultRelease && defaultRelease.headersUrl && !overrideDistUrl) {\n    baseUrl = url.resolve(defaultRelease.headersUrl, './');\n    libUrl32 = resolveLibUrl(name, defaultRelease.libUrl || baseUrl || distBaseUrl, 'x86', versionSemver.major);\n    libUrl64 = resolveLibUrl(name, defaultRelease.libUrl || baseUrl || distBaseUrl, 'x64', versionSemver.major);\n    libUrlArm64 = resolveLibUrl(name, defaultRelease.libUrl || baseUrl || distBaseUrl, 'arm64', versionSemver.major);\n    tarballUrl = defaultRelease.headersUrl;\n  } else {\n    // older versions without process.release are captured here and we have to make\n    // a lot of assumptions, additionally if you --target=x.y.z then we can't use the\n    // current process.release\n    baseUrl = distBaseUrl;\n    libUrl32 = resolveLibUrl(name, baseUrl, 'x86', versionSemver.major);\n    libUrl64 = resolveLibUrl(name, baseUrl, 'x64', versionSemver.major);\n    libUrlArm64 = resolveLibUrl(name, baseUrl, 'arm64', versionSemver.major); // making the bold assumption that anything with a version number >3.0.0 will\n    // have a *-headers.tar.gz file in its dist location, even some frankenstein\n    // custom version\n\n    canGetHeaders = semver.satisfies(versionSemver, headersTarballRange);\n    tarballUrl = url.resolve(baseUrl, name + '-v' + version + (canGetHeaders ? '-headers' : '') + '.tar.gz');\n  }\n\n  return {\n    version: version,\n    semver: versionSemver,\n    name: name,\n    baseUrl: baseUrl,\n    tarballUrl: tarballUrl,\n    shasumsUrl: url.resolve(baseUrl, 'SHASUMS256.txt'),\n    versionDir: (name !== 'node' ? name + '-' : '') + version,\n    ia32: {\n      libUrl: libUrl32,\n      libPath: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl32).path))\n    },\n    x64: {\n      libUrl: libUrl64,\n      libPath: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrl64).path))\n    },\n    arm64: {\n      libUrl: libUrlArm64,\n      libPath: normalizePath(path.relative(url.parse(baseUrl).path, url.parse(libUrlArm64).path))\n    }\n  };\n}\n\nfunction normalizePath(p) {\n  return path.normalize(p).replace(/\\\\/g, '/');\n}\n\nfunction resolveLibUrl(name, defaultUrl, arch, versionMajor) {\n  var base = url.resolve(defaultUrl, './');\n  var hasLibUrl = bitsre.test(defaultUrl) || versionMajor === 3 && bitsreV3.test(defaultUrl);\n\n  if (!hasLibUrl) {\n    // let's assume it's a baseUrl then\n    if (versionMajor >= 1) {\n      return url.resolve(base, 'win-' + arch + '/' + name + '.lib');\n    } // prior to io.js@1.0.0 32-bit node.lib lives in /, 64-bit lives in /x64/\n\n\n    return url.resolve(base, (arch === 'x86' ? '' : arch + '/') + name + '.lib');\n  } // else we have a proper url to a .lib, just make sure it's the right arch\n\n\n  return defaultUrl.replace(versionMajor === 3 ? bitsreV3 : bitsre, '/win-' + arch + '/');\n}\n\nmodule.exports = processRelease;","map":null,"metadata":{},"sourceType":"script"}