{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst errors = require('./errors.js');\n\nconst {\n  Response\n} = require('minipass-fetch');\n\nconst defaultOpts = require('./default-opts.js');\n\nconst log = require('proc-log');\n\nconst cleanUrl = require('./clean-url.js');\n/* eslint-disable-next-line max-len */\n\n\nconst moreInfoUrl = 'https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry';\n\nconst checkResponse = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* ({\n    method,\n    uri,\n    res,\n    startTime,\n    auth,\n    opts\n  }) {\n    opts = { ...defaultOpts,\n      ...opts\n    };\n\n    if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) {\n      log.notice('', res.headers.get('npm-notice'));\n    }\n\n    if (res.status >= 400) {\n      logRequest(method, res, startTime);\n\n      if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {\n        // we didn't have auth for THIS request, but we do have auth for\n        // requests to the registry indicated by the spec's scope value.\n        // Warn the user.\n        log.warn('registry', `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: ${moreInfoUrl}`);\n      }\n\n      return checkErrors(method, res, startTime, opts);\n    } else {\n      res.body.on('end', () => logRequest(method, res, startTime, opts));\n\n      if (opts.ignoreBody) {\n        res.body.resume();\n        return new Response(null, res);\n      }\n\n      return res;\n    }\n  });\n\n  return function checkResponse(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = checkResponse;\n\nfunction logRequest(method, res, startTime) {\n  const elapsedTime = Date.now() - startTime;\n  const attempt = res.headers.get('x-fetch-attempts');\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : '';\n  const cacheStatus = res.headers.get('x-local-cache-status');\n  const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : '';\n  const urlStr = cleanUrl(res.url);\n  log.http('fetch', `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);\n}\n\nfunction checkErrors(method, res, startTime, opts) {\n  return res.buffer().catch(() => null).then(body => {\n    let parsed = body;\n\n    try {\n      parsed = JSON.parse(body.toString('utf8'));\n    } catch {// ignore errors\n    }\n\n    if (res.status === 401 && res.headers.get('www-authenticate')) {\n      const auth = res.headers.get('www-authenticate').split(/,\\s*/).map(s => s.toLowerCase());\n\n      if (auth.indexOf('ipaddress') !== -1) {\n        throw new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec);\n      } else if (auth.indexOf('otp') !== -1) {\n        throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n      } else {\n        throw new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);\n      }\n    } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n      // Heuristic for malformed OTP responses that don't include the\n      // www-authenticate header.\n      throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n    } else {\n      throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}