{"ast":null,"code":"'use strict';\n/**\n * Base prompt implementation\n * Should be extended by prompt types.\n */\n\nconst _ = {\n  defaults: require('lodash/defaults'),\n  clone: require('lodash/clone')\n};\n\nconst chalk = require('chalk');\n\nconst runAsync = require('run-async');\n\nconst {\n  filter,\n  flatMap,\n  share,\n  take,\n  takeUntil\n} = require('rxjs/operators');\n\nconst Choices = require('../objects/choices');\n\nconst ScreenManager = require('../utils/screen-manager');\n\nclass Prompt {\n  constructor(question, rl, answers) {\n    // Setup instance defaults property\n    Object.assign(this, {\n      answers,\n      status: 'pending'\n    }); // Set defaults prompt options\n\n    this.opt = _.defaults(_.clone(question), {\n      validate: () => true,\n      validatingText: '',\n      filter: val => val,\n      filteringText: '',\n      when: () => true,\n      suffix: '',\n      prefix: chalk.green('?')\n    }); // Make sure name is present\n\n    if (!this.opt.name) {\n      this.throwParamError('name');\n    } // Set default message if no message defined\n\n\n    if (!this.opt.message) {\n      this.opt.message = this.opt.name + ':';\n    } // Normalize choices\n\n\n    if (Array.isArray(this.opt.choices)) {\n      this.opt.choices = new Choices(this.opt.choices, answers);\n    }\n\n    this.rl = rl;\n    this.screen = new ScreenManager(this.rl);\n  }\n  /**\n   * Start the Inquiry session and manage output value filtering\n   * @return {Promise}\n   */\n\n\n  run() {\n    return new Promise((resolve, reject) => {\n      this._run(value => resolve(value), error => reject(error));\n    });\n  } // Default noop (this one should be overwritten in prompts)\n\n\n  _run(cb) {\n    cb();\n  }\n  /**\n   * Throw an error telling a required parameter is missing\n   * @param  {String} name Name of the missing param\n   * @return {Throw Error}\n   */\n\n\n  throwParamError(name) {\n    throw new Error('You must provide a `' + name + '` parameter');\n  }\n  /**\n   * Called when the UI closes. Override to do any specific cleanup necessary\n   */\n\n\n  close() {\n    this.screen.releaseCursor();\n  }\n  /**\n   * Run the provided validation method each time a submit event occur.\n   * @param  {Rx.Observable} submit - submit event flow\n   * @return {Object}        Object containing two observables: `success` and `error`\n   */\n\n\n  handleSubmitEvents(submit) {\n    const self = this;\n    const validate = runAsync(this.opt.validate);\n    const asyncFilter = runAsync(this.opt.filter);\n    const validation = submit.pipe(flatMap(value => {\n      this.startSpinner(value, this.opt.filteringText);\n      return asyncFilter(value, self.answers).then(filteredValue => {\n        this.startSpinner(filteredValue, this.opt.validatingText);\n        return validate(filteredValue, self.answers).then(isValid => ({\n          isValid,\n          value: filteredValue\n        }), err => ({\n          isValid: err,\n          value: filteredValue\n        }));\n      }, err => ({\n        isValid: err\n      }));\n    }), share());\n    const success = validation.pipe(filter(state => state.isValid === true), take(1));\n    const error = validation.pipe(filter(state => state.isValid !== true), takeUntil(success));\n    return {\n      success,\n      error\n    };\n  }\n\n  startSpinner(value, bottomContent) {\n    value = this.getSpinningValue(value); // If the question will spin, cut off the prefix (for layout purposes)\n\n    const content = bottomContent ? this.getQuestion() + value : this.getQuestion().slice(this.opt.prefix.length + 1) + value;\n    this.screen.renderWithSpinner(content, bottomContent);\n  }\n  /**\n   * Allow override, e.g. for password prompts\n   * See: https://github.com/SBoudrias/Inquirer.js/issues/1022\n   *\n   * @return {String} value to display while spinning\n   */\n\n\n  getSpinningValue(value) {\n    return value;\n  }\n  /**\n   * Generate the prompt question string\n   * @return {String} prompt question string\n   */\n\n\n  getQuestion() {\n    let message = (this.opt.prefix ? this.opt.prefix + ' ' : '') + chalk.bold(this.opt.message) + this.opt.suffix + chalk.reset(' '); // Append the default if available, and if question isn't touched/answered\n\n    if (this.opt.default != null && this.status !== 'touched' && this.status !== 'answered') {\n      // If default password is supplied, hide it\n      if (this.opt.type === 'password') {\n        message += chalk.italic.dim('[hidden] ');\n      } else {\n        message += chalk.dim('(' + this.opt.default + ') ');\n      }\n    }\n\n    return message;\n  }\n\n}\n\nmodule.exports = Prompt;","map":null,"metadata":{},"sourceType":"script"}