{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst fetch = require('npm-registry-fetch');\n\nconst Minipass = require('minipass');\n\nconst _cacheFetches = Symbol.for('pacote.Fetcher._cacheFetches');\n\nconst _headers = Symbol('_headers');\n\nclass RemoteFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts);\n    this.resolved = this.spec.fetchSpec;\n    const resolvedURL = new URL(this.resolved);\n\n    if (this.replaceRegistryHost !== 'never' && (this.replaceRegistryHost === 'always' || this.replaceRegistryHost === resolvedURL.host)) {\n      this.resolved = new URL(resolvedURL.pathname, this.registry).href;\n    } // nam is a fermented pork sausage that is good to eat\n\n\n    const nameat = this.spec.name ? `${this.spec.name}@` : '';\n    this.pkgid = opts.pkgid ? opts.pkgid : `remote:${nameat}${this.resolved}`;\n  } // Don't need to cache tarball fetches in pacote, because make-fetch-happen\n  // will write into cacache anyway.\n\n\n  get [_cacheFetches]() {\n    return false;\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.hasIntegrityEmitter = true;\n    const fetchOpts = { ...this.opts,\n      headers: this[_headers](),\n      spec: this.spec,\n      integrity: this.integrity,\n      algorithms: [this.pickIntegrityAlgorithm()]\n    }; // eslint-disable-next-line promise/always-return\n\n    fetch(this.resolved, fetchOpts).then(res => {\n      res.body.on('error',\n      /* istanbul ignore next - exceedingly rare and hard to simulate */\n      er => stream.emit('error', er));\n      res.body.on('integrity', i => {\n        this.integrity = i;\n        stream.emit('integrity', i);\n      });\n      res.body.pipe(stream);\n    }).catch(er => stream.emit('error', er));\n    return stream;\n  }\n\n  [_headers]() {\n    return {\n      // npm will override this, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'tarball',\n      'pacote-pkg-id': this.pkgid,\n      ...(this.integrity ? {\n        'pacote-integrity': String(this.integrity)\n      } : {}),\n      ...(this.opts.headers || {})\n    };\n  }\n\n  get types() {\n    return ['remote'];\n  } // getting a packument and/or manifest is the same as with a file: spec.\n  // unpack the tarball stream, and then read from the package.json file.\n\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n  manifest() {\n    return FileFetcher.prototype.manifest.apply(this);\n  }\n\n}\n\nmodule.exports = RemoteFetcher;","map":null,"metadata":{},"sourceType":"script"}