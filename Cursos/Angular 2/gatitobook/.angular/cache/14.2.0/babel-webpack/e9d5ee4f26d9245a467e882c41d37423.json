{"ast":null,"code":"'use strict';\n\nvar sourcemapCodec = require('sourcemap-codec');\n\nclass BitSet {\n  constructor(arg) {\n    this.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n  }\n\n  add(n) {\n    this.bits[n >> 5] |= 1 << (n & 31);\n  }\n\n  has(n) {\n    return !!(this.bits[n >> 5] & 1 << (n & 31));\n  }\n\n}\n\nclass Chunk {\n  constructor(start, end, content) {\n    this.start = start;\n    this.end = end;\n    this.original = content;\n    this.intro = '';\n    this.outro = '';\n    this.content = content;\n    this.storeName = false;\n    this.edited = false; // we make these non-enumerable, for sanity while debugging\n\n    Object.defineProperties(this, {\n      previous: {\n        writable: true,\n        value: null\n      },\n      next: {\n        writable: true,\n        value: null\n      }\n    });\n  }\n\n  appendLeft(content) {\n    this.outro += content;\n  }\n\n  appendRight(content) {\n    this.intro = this.intro + content;\n  }\n\n  clone() {\n    const chunk = new Chunk(this.start, this.end, this.original);\n    chunk.intro = this.intro;\n    chunk.outro = this.outro;\n    chunk.content = this.content;\n    chunk.storeName = this.storeName;\n    chunk.edited = this.edited;\n    return chunk;\n  }\n\n  contains(index) {\n    return this.start < index && index < this.end;\n  }\n\n  eachNext(fn) {\n    let chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.next;\n    }\n  }\n\n  eachPrevious(fn) {\n    let chunk = this;\n\n    while (chunk) {\n      fn(chunk);\n      chunk = chunk.previous;\n    }\n  }\n\n  edit(content, storeName, contentOnly) {\n    this.content = content;\n\n    if (!contentOnly) {\n      this.intro = '';\n      this.outro = '';\n    }\n\n    this.storeName = storeName;\n    this.edited = true;\n    return this;\n  }\n\n  prependLeft(content) {\n    this.outro = content + this.outro;\n  }\n\n  prependRight(content) {\n    this.intro = content + this.intro;\n  }\n\n  split(index) {\n    const sliceIndex = index - this.start;\n    const originalBefore = this.original.slice(0, sliceIndex);\n    const originalAfter = this.original.slice(sliceIndex);\n    this.original = originalBefore;\n    const newChunk = new Chunk(index, this.end, originalAfter);\n    newChunk.outro = this.outro;\n    this.outro = '';\n    this.end = index;\n\n    if (this.edited) {\n      // TODO is this block necessary?...\n      newChunk.edit('', false);\n      this.content = '';\n    } else {\n      this.content = originalBefore;\n    }\n\n    newChunk.next = this.next;\n    if (newChunk.next) newChunk.next.previous = newChunk;\n    newChunk.previous = this;\n    this.next = newChunk;\n    return newChunk;\n  }\n\n  toString() {\n    return this.intro + this.content + this.outro;\n  }\n\n  trimEnd(rx) {\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.start + trimmed.length).edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.intro = this.intro.replace(rx, '');\n      if (this.intro.length) return true;\n    }\n  }\n\n  trimStart(rx) {\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    const trimmed = this.content.replace(rx, '');\n\n    if (trimmed.length) {\n      if (trimmed !== this.content) {\n        this.split(this.end - trimmed.length);\n        this.edit('', undefined, true);\n      }\n\n      return true;\n    } else {\n      this.edit('', undefined, true);\n      this.outro = this.outro.replace(rx, '');\n      if (this.outro.length) return true;\n    }\n  }\n\n}\n\nlet btoa = () => {\n  throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n};\n\nif (typeof window !== 'undefined' && typeof window.btoa === 'function') {\n  btoa = str => window.btoa(unescape(encodeURIComponent(str)));\n} else if (typeof Buffer === 'function') {\n  btoa = str => Buffer.from(str, 'utf-8').toString('base64');\n}\n\nclass SourceMap {\n  constructor(properties) {\n    this.version = 3;\n    this.file = properties.file;\n    this.sources = properties.sources;\n    this.sourcesContent = properties.sourcesContent;\n    this.names = properties.names;\n    this.mappings = sourcemapCodec.encode(properties.mappings);\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n  toUrl() {\n    return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n  }\n\n}\n\nfunction guessIndent(code) {\n  const lines = code.split('\\n');\n  const tabbed = lines.filter(line => /^\\t+/.test(line));\n  const spaced = lines.filter(line => /^ {2,}/.test(line));\n\n  if (tabbed.length === 0 && spaced.length === 0) {\n    return null;\n  } // More lines tabbed than spaced? Assume tabs, and\n  // default to tabs in the case of a tie (or nothing\n  // to go on)\n\n\n  if (tabbed.length >= spaced.length) {\n    return '\\t';\n  } // Otherwise, we need to guess the multiple\n\n\n  const min = spaced.reduce((previous, current) => {\n    const numSpaces = /^ +/.exec(current)[0].length;\n    return Math.min(numSpaces, previous);\n  }, Infinity);\n  return new Array(min + 1).join(' ');\n}\n\nfunction getRelativePath(from, to) {\n  const fromParts = from.split(/[/\\\\]/);\n  const toParts = to.split(/[/\\\\]/);\n  fromParts.pop(); // get dirname\n\n  while (fromParts[0] === toParts[0]) {\n    fromParts.shift();\n    toParts.shift();\n  }\n\n  if (fromParts.length) {\n    let i = fromParts.length;\n\n    while (i--) fromParts[i] = '..';\n  }\n\n  return fromParts.concat(toParts).join('/');\n}\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(thing) {\n  return toString.call(thing) === '[object Object]';\n}\n\nfunction getLocator(source) {\n  const originalLines = source.split('\\n');\n  const lineOffsets = [];\n\n  for (let i = 0, pos = 0; i < originalLines.length; i++) {\n    lineOffsets.push(pos);\n    pos += originalLines[i].length + 1;\n  }\n\n  return function locate(index) {\n    let i = 0;\n    let j = lineOffsets.length;\n\n    while (i < j) {\n      const m = i + j >> 1;\n\n      if (index < lineOffsets[m]) {\n        j = m;\n      } else {\n        i = m + 1;\n      }\n    }\n\n    const line = i - 1;\n    const column = index - lineOffsets[line];\n    return {\n      line,\n      column\n    };\n  };\n}\n\nclass Mappings {\n  constructor(hires) {\n    this.hires = hires;\n    this.generatedCodeLine = 0;\n    this.generatedCodeColumn = 0;\n    this.raw = [];\n    this.rawSegments = this.raw[this.generatedCodeLine] = [];\n    this.pending = null;\n  }\n\n  addEdit(sourceIndex, content, loc, nameIndex) {\n    if (content.length) {\n      const segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n      if (nameIndex >= 0) {\n        segment.push(nameIndex);\n      }\n\n      this.rawSegments.push(segment);\n    } else if (this.pending) {\n      this.rawSegments.push(this.pending);\n    }\n\n    this.advance(content);\n    this.pending = null;\n  }\n\n  addUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n    let originalCharIndex = chunk.start;\n    let first = true;\n\n    while (originalCharIndex < chunk.end) {\n      if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n        this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);\n      }\n\n      if (original[originalCharIndex] === '\\n') {\n        loc.line += 1;\n        loc.column = 0;\n        this.generatedCodeLine += 1;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n        this.generatedCodeColumn = 0;\n        first = true;\n      } else {\n        loc.column += 1;\n        this.generatedCodeColumn += 1;\n        first = false;\n      }\n\n      originalCharIndex += 1;\n    }\n\n    this.pending = null;\n  }\n\n  advance(str) {\n    if (!str) return;\n    const lines = str.split('\\n');\n\n    if (lines.length > 1) {\n      for (let i = 0; i < lines.length - 1; i++) {\n        this.generatedCodeLine++;\n        this.raw[this.generatedCodeLine] = this.rawSegments = [];\n      }\n\n      this.generatedCodeColumn = 0;\n    }\n\n    this.generatedCodeColumn += lines[lines.length - 1].length;\n  }\n\n}\n\nconst n = '\\n';\nconst warned = {\n  insertLeft: false,\n  insertRight: false,\n  storeName: false\n};\n\nclass MagicString {\n  constructor(string, options = {}) {\n    const chunk = new Chunk(0, string.length, string);\n    Object.defineProperties(this, {\n      original: {\n        writable: true,\n        value: string\n      },\n      outro: {\n        writable: true,\n        value: ''\n      },\n      intro: {\n        writable: true,\n        value: ''\n      },\n      firstChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastChunk: {\n        writable: true,\n        value: chunk\n      },\n      lastSearchedChunk: {\n        writable: true,\n        value: chunk\n      },\n      byStart: {\n        writable: true,\n        value: {}\n      },\n      byEnd: {\n        writable: true,\n        value: {}\n      },\n      filename: {\n        writable: true,\n        value: options.filename\n      },\n      indentExclusionRanges: {\n        writable: true,\n        value: options.indentExclusionRanges\n      },\n      sourcemapLocations: {\n        writable: true,\n        value: new BitSet()\n      },\n      storedNames: {\n        writable: true,\n        value: {}\n      },\n      indentStr: {\n        writable: true,\n        value: guessIndent(string)\n      }\n    });\n    this.byStart[0] = chunk;\n    this.byEnd[string.length] = chunk;\n  }\n\n  addSourcemapLocation(char) {\n    this.sourcemapLocations.add(char);\n  }\n\n  append(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.outro += content;\n    return this;\n  }\n\n  appendLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.appendLeft(content);\n    } else {\n      this.intro += content;\n    }\n\n    return this;\n  }\n\n  appendRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.appendRight(content);\n    } else {\n      this.outro += content;\n    }\n\n    return this;\n  }\n\n  clone() {\n    const cloned = new MagicString(this.original, {\n      filename: this.filename\n    });\n    let originalChunk = this.firstChunk;\n    let clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();\n\n    while (originalChunk) {\n      cloned.byStart[clonedChunk.start] = clonedChunk;\n      cloned.byEnd[clonedChunk.end] = clonedChunk;\n      const nextOriginalChunk = originalChunk.next;\n      const nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n      if (nextClonedChunk) {\n        clonedChunk.next = nextClonedChunk;\n        nextClonedChunk.previous = clonedChunk;\n        clonedChunk = nextClonedChunk;\n      }\n\n      originalChunk = nextOriginalChunk;\n    }\n\n    cloned.lastChunk = clonedChunk;\n\n    if (this.indentExclusionRanges) {\n      cloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n    }\n\n    cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n    cloned.intro = this.intro;\n    cloned.outro = this.outro;\n    return cloned;\n  }\n\n  generateDecodedMap(options) {\n    options = options || {};\n    const sourceIndex = 0;\n    const names = Object.keys(this.storedNames);\n    const mappings = new Mappings(options.hires);\n    const locate = getLocator(this.original);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.firstChunk.eachNext(chunk => {\n      const loc = locate(chunk.start);\n      if (chunk.intro.length) mappings.advance(chunk.intro);\n\n      if (chunk.edited) {\n        mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n      } else {\n        mappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n      }\n\n      if (chunk.outro.length) mappings.advance(chunk.outro);\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: [options.source ? getRelativePath(options.file || '', options.source) : null],\n      sourcesContent: options.includeContent ? [this.original] : [null],\n      names,\n      mappings: mappings.raw\n    };\n  }\n\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n\n  getIndentString() {\n    return this.indentStr === null ? '\\t' : this.indentStr;\n  }\n\n  indent(indentStr, options) {\n    const pattern = /^[^\\r\\n]/gm;\n\n    if (isObject(indentStr)) {\n      options = indentStr;\n      indentStr = undefined;\n    }\n\n    indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\\t';\n    if (indentStr === '') return this; // noop\n\n    options = options || {}; // Process exclusion ranges\n\n    const isExcluded = {};\n\n    if (options.exclude) {\n      const exclusions = typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n      exclusions.forEach(exclusion => {\n        for (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n          isExcluded[i] = true;\n        }\n      });\n    }\n\n    let shouldIndentNextCharacter = options.indentStart !== false;\n\n    const replacer = match => {\n      if (shouldIndentNextCharacter) return `${indentStr}${match}`;\n      shouldIndentNextCharacter = true;\n      return match;\n    };\n\n    this.intro = this.intro.replace(pattern, replacer);\n    let charIndex = 0;\n    let chunk = this.firstChunk;\n\n    while (chunk) {\n      const end = chunk.end;\n\n      if (chunk.edited) {\n        if (!isExcluded[charIndex]) {\n          chunk.content = chunk.content.replace(pattern, replacer);\n\n          if (chunk.content.length) {\n            shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n          }\n        }\n      } else {\n        charIndex = chunk.start;\n\n        while (charIndex < end) {\n          if (!isExcluded[charIndex]) {\n            const char = this.original[charIndex];\n\n            if (char === '\\n') {\n              shouldIndentNextCharacter = true;\n            } else if (char !== '\\r' && shouldIndentNextCharacter) {\n              shouldIndentNextCharacter = false;\n\n              if (charIndex === chunk.start) {\n                chunk.prependRight(indentStr);\n              } else {\n                this._splitChunk(chunk, charIndex);\n\n                chunk = chunk.next;\n                chunk.prependRight(indentStr);\n              }\n            }\n          }\n\n          charIndex += 1;\n        }\n      }\n\n      charIndex = chunk.end;\n      chunk = chunk.next;\n    }\n\n    this.outro = this.outro.replace(pattern, replacer);\n    return this;\n  }\n\n  insert() {\n    throw new Error('magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)');\n  }\n\n  insertLeft(index, content) {\n    if (!warned.insertLeft) {\n      console.warn('magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'); // eslint-disable-line no-console\n\n      warned.insertLeft = true;\n    }\n\n    return this.appendLeft(index, content);\n  }\n\n  insertRight(index, content) {\n    if (!warned.insertRight) {\n      console.warn('magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'); // eslint-disable-line no-console\n\n      warned.insertRight = true;\n    }\n\n    return this.prependRight(index, content);\n  }\n\n  move(start, end, index) {\n    if (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n    this._split(start);\n\n    this._split(end);\n\n    this._split(index);\n\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n    const oldLeft = first.previous;\n    const oldRight = last.next;\n    const newRight = this.byStart[index];\n    if (!newRight && last === this.lastChunk) return this;\n    const newLeft = newRight ? newRight.previous : this.lastChunk;\n    if (oldLeft) oldLeft.next = oldRight;\n    if (oldRight) oldRight.previous = oldLeft;\n    if (newLeft) newLeft.next = first;\n    if (newRight) newRight.previous = last;\n    if (!first.previous) this.firstChunk = last.next;\n\n    if (!last.next) {\n      this.lastChunk = first.previous;\n      this.lastChunk.next = null;\n    }\n\n    first.previous = newLeft;\n    last.next = newRight || null;\n    if (!newLeft) this.firstChunk = first;\n    if (!newRight) this.lastChunk = last;\n    return this;\n  }\n\n  overwrite(start, end, content, options) {\n    if (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    if (end > this.original.length) throw new Error('end is out of bounds');\n    if (start === end) throw new Error('Cannot overwrite a zero-length range – use appendLeft or prependRight instead');\n\n    this._split(start);\n\n    this._split(end);\n\n    if (options === true) {\n      if (!warned.storeName) {\n        console.warn('The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'); // eslint-disable-line no-console\n\n        warned.storeName = true;\n      }\n\n      options = {\n        storeName: true\n      };\n    }\n\n    const storeName = options !== undefined ? options.storeName : false;\n    const contentOnly = options !== undefined ? options.contentOnly : false;\n\n    if (storeName) {\n      const original = this.original.slice(start, end);\n      Object.defineProperty(this.storedNames, original, {\n        writable: true,\n        value: true,\n        enumerable: true\n      });\n    }\n\n    const first = this.byStart[start];\n    const last = this.byEnd[end];\n\n    if (first) {\n      let chunk = first;\n\n      while (chunk !== last) {\n        if (chunk.next !== this.byStart[chunk.end]) {\n          throw new Error('Cannot overwrite across a split point');\n        }\n\n        chunk = chunk.next;\n        chunk.edit('', false);\n      }\n\n      first.edit(content, storeName, contentOnly);\n    } else {\n      // must be inserting at the end\n      const newChunk = new Chunk(start, end, '').edit(content, storeName); // TODO last chunk in the array may not be the last chunk, if it's moved...\n\n      last.next = newChunk;\n      newChunk.previous = last;\n    }\n\n    return this;\n  }\n\n  prepend(content) {\n    if (typeof content !== 'string') throw new TypeError('outro content must be a string');\n    this.intro = content + this.intro;\n    return this;\n  }\n\n  prependLeft(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byEnd[index];\n\n    if (chunk) {\n      chunk.prependLeft(content);\n    } else {\n      this.intro = content + this.intro;\n    }\n\n    return this;\n  }\n\n  prependRight(index, content) {\n    if (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n    this._split(index);\n\n    const chunk = this.byStart[index];\n\n    if (chunk) {\n      chunk.prependRight(content);\n    } else {\n      this.outro = content + this.outro;\n    }\n\n    return this;\n  }\n\n  remove(start, end) {\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    if (start === end) return this;\n    if (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n    if (start > end) throw new Error('end must be greater than start');\n\n    this._split(start);\n\n    this._split(end);\n\n    let chunk = this.byStart[start];\n\n    while (chunk) {\n      chunk.intro = '';\n      chunk.outro = '';\n      chunk.edit('');\n      chunk = end > chunk.end ? this.byStart[chunk.end] : null;\n    }\n\n    return this;\n  }\n\n  lastChar() {\n    if (this.outro.length) return this.outro[this.outro.length - 1];\n    let chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n      if (chunk.content.length) return chunk.content[chunk.content.length - 1];\n      if (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n    } while (chunk = chunk.previous);\n\n    if (this.intro.length) return this.intro[this.intro.length - 1];\n    return '';\n  }\n\n  lastLine() {\n    let lineIndex = this.outro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n    let lineStr = this.outro;\n    let chunk = this.lastChunk;\n\n    do {\n      if (chunk.outro.length > 0) {\n        lineIndex = chunk.outro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.outro + lineStr;\n      }\n\n      if (chunk.content.length > 0) {\n        lineIndex = chunk.content.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.content + lineStr;\n      }\n\n      if (chunk.intro.length > 0) {\n        lineIndex = chunk.intro.lastIndexOf(n);\n        if (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n        lineStr = chunk.intro + lineStr;\n      }\n    } while (chunk = chunk.previous);\n\n    lineIndex = this.intro.lastIndexOf(n);\n    if (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n    return this.intro + lineStr;\n  }\n\n  slice(start = 0, end = this.original.length) {\n    while (start < 0) start += this.original.length;\n\n    while (end < 0) end += this.original.length;\n\n    let result = ''; // find start chunk\n\n    let chunk = this.firstChunk;\n\n    while (chunk && (chunk.start > start || chunk.end <= start)) {\n      // found end chunk before start\n      if (chunk.start < end && chunk.end >= end) {\n        return result;\n      }\n\n      chunk = chunk.next;\n    }\n\n    if (chunk && chunk.edited && chunk.start !== start) throw new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n    const startChunk = chunk;\n\n    while (chunk) {\n      if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n        result += chunk.intro;\n      }\n\n      const containsEnd = chunk.start < end && chunk.end >= end;\n      if (containsEnd && chunk.edited && chunk.end !== end) throw new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n      const sliceStart = startChunk === chunk ? start - chunk.start : 0;\n      const sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n      result += chunk.content.slice(sliceStart, sliceEnd);\n\n      if (chunk.outro && (!containsEnd || chunk.end === end)) {\n        result += chunk.outro;\n      }\n\n      if (containsEnd) {\n        break;\n      }\n\n      chunk = chunk.next;\n    }\n\n    return result;\n  } // TODO deprecate this? not really very useful\n\n\n  snip(start, end) {\n    const clone = this.clone();\n    clone.remove(0, start);\n    clone.remove(end, clone.original.length);\n    return clone;\n  }\n\n  _split(index) {\n    if (this.byStart[index] || this.byEnd[index]) return;\n    let chunk = this.lastSearchedChunk;\n    const searchForward = index > chunk.end;\n\n    while (chunk) {\n      if (chunk.contains(index)) return this._splitChunk(chunk, index);\n      chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n    }\n  }\n\n  _splitChunk(chunk, index) {\n    if (chunk.edited && chunk.content.length) {\n      // zero-length edited chunks are a special case (overlapping replacements)\n      const loc = getLocator(this.original)(index);\n      throw new Error(`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`);\n    }\n\n    const newChunk = chunk.split(index);\n    this.byEnd[index] = chunk;\n    this.byStart[index] = newChunk;\n    this.byEnd[newChunk.end] = newChunk;\n    if (chunk === this.lastChunk) this.lastChunk = newChunk;\n    this.lastSearchedChunk = chunk;\n    return true;\n  }\n\n  toString() {\n    let str = this.intro;\n    let chunk = this.firstChunk;\n\n    while (chunk) {\n      str += chunk.toString();\n      chunk = chunk.next;\n    }\n\n    return str + this.outro;\n  }\n\n  isEmpty() {\n    let chunk = this.firstChunk;\n\n    do {\n      if (chunk.intro.length && chunk.intro.trim() || chunk.content.length && chunk.content.trim() || chunk.outro.length && chunk.outro.trim()) return false;\n    } while (chunk = chunk.next);\n\n    return true;\n  }\n\n  length() {\n    let chunk = this.firstChunk;\n    let length = 0;\n\n    do {\n      length += chunk.intro.length + chunk.content.length + chunk.outro.length;\n    } while (chunk = chunk.next);\n\n    return length;\n  }\n\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n\n  trimEndAborted(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    this.outro = this.outro.replace(rx, '');\n    if (this.outro.length) return true;\n    let chunk = this.lastChunk;\n\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimEnd(rx); // if chunk was trimmed, we have a new lastChunk\n\n      if (chunk.end !== end) {\n        if (this.lastChunk === chunk) {\n          this.lastChunk = chunk.next;\n        }\n\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) return true;\n      chunk = chunk.previous;\n    } while (chunk);\n\n    return false;\n  }\n\n  trimEnd(charType) {\n    this.trimEndAborted(charType);\n    return this;\n  }\n\n  trimStartAborted(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n    if (this.intro.length) return true;\n    let chunk = this.firstChunk;\n\n    do {\n      const end = chunk.end;\n      const aborted = chunk.trimStart(rx);\n\n      if (chunk.end !== end) {\n        // special case...\n        if (chunk === this.lastChunk) this.lastChunk = chunk.next;\n        this.byEnd[chunk.end] = chunk;\n        this.byStart[chunk.next.start] = chunk.next;\n        this.byEnd[chunk.next.end] = chunk.next;\n      }\n\n      if (aborted) return true;\n      chunk = chunk.next;\n    } while (chunk);\n\n    return false;\n  }\n\n  trimStart(charType) {\n    this.trimStartAborted(charType);\n    return this;\n  }\n\n  hasChanged() {\n    return this.original !== this.toString();\n  }\n\n  replace(searchValue, replacement) {\n    function getReplacement(match, str) {\n      if (typeof replacement === 'string') {\n        return replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n          // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n          if (i === '$') return '$';\n          if (i === '&') return match[0];\n          const num = +i;\n          if (num < match.length) return match[+i];\n          return `$${i}`;\n        });\n      } else {\n        return replacement(...match, match.index, str, match.groups);\n      }\n    }\n\n    function matchAll(re, str) {\n      let match;\n      const matches = [];\n\n      while (match = re.exec(str)) {\n        matches.push(match);\n      }\n\n      return matches;\n    }\n\n    if (typeof searchValue !== 'string' && searchValue.global) {\n      const matches = matchAll(searchValue, this.original);\n      matches.forEach(match => {\n        if (match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n      });\n    } else {\n      const match = this.original.match(searchValue);\n      if (match && match.index != null) this.overwrite(match.index, match.index + match[0].length, getReplacement(match, this.original));\n    }\n\n    return this;\n  }\n\n}\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nclass Bundle {\n  constructor(options = {}) {\n    this.intro = options.intro || '';\n    this.separator = options.separator !== undefined ? options.separator : '\\n';\n    this.sources = [];\n    this.uniqueSources = [];\n    this.uniqueSourceIndexByFilename = {};\n  }\n\n  addSource(source) {\n    if (source instanceof MagicString) {\n      return this.addSource({\n        content: source,\n        filename: source.filename,\n        separator: this.separator\n      });\n    }\n\n    if (!isObject(source) || !source.content) {\n      throw new Error('bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`');\n    }\n\n    ['filename', 'indentExclusionRanges', 'separator'].forEach(option => {\n      if (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n    });\n\n    if (source.separator === undefined) {\n      // TODO there's a bunch of this sort of thing, needs cleaning up\n      source.separator = this.separator;\n    }\n\n    if (source.filename) {\n      if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n        this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n        this.uniqueSources.push({\n          filename: source.filename,\n          content: source.content.original\n        });\n      } else {\n        const uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\n        if (source.content.original !== uniqueSource.content) {\n          throw new Error(`Illegal source: same filename (${source.filename}), different contents`);\n        }\n      }\n    }\n\n    this.sources.push(source);\n    return this;\n  }\n\n  append(str, options) {\n    this.addSource({\n      content: new MagicString(str),\n      separator: options && options.separator || ''\n    });\n    return this;\n  }\n\n  clone() {\n    const bundle = new Bundle({\n      intro: this.intro,\n      separator: this.separator\n    });\n    this.sources.forEach(source => {\n      bundle.addSource({\n        filename: source.filename,\n        content: source.content.clone(),\n        separator: source.separator\n      });\n    });\n    return bundle;\n  }\n\n  generateDecodedMap(options = {}) {\n    const names = [];\n    this.sources.forEach(source => {\n      Object.keys(source.content.storedNames).forEach(name => {\n        if (!~names.indexOf(name)) names.push(name);\n      });\n    });\n    const mappings = new Mappings(options.hires);\n\n    if (this.intro) {\n      mappings.advance(this.intro);\n    }\n\n    this.sources.forEach((source, i) => {\n      if (i > 0) {\n        mappings.advance(this.separator);\n      }\n\n      const sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n      const magicString = source.content;\n      const locate = getLocator(magicString.original);\n\n      if (magicString.intro) {\n        mappings.advance(magicString.intro);\n      }\n\n      magicString.firstChunk.eachNext(chunk => {\n        const loc = locate(chunk.start);\n        if (chunk.intro.length) mappings.advance(chunk.intro);\n\n        if (source.filename) {\n          if (chunk.edited) {\n            mappings.addEdit(sourceIndex, chunk.content, loc, chunk.storeName ? names.indexOf(chunk.original) : -1);\n          } else {\n            mappings.addUneditedChunk(sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations);\n          }\n        } else {\n          mappings.advance(chunk.content);\n        }\n\n        if (chunk.outro.length) mappings.advance(chunk.outro);\n      });\n\n      if (magicString.outro) {\n        mappings.advance(magicString.outro);\n      }\n    });\n    return {\n      file: options.file ? options.file.split(/[/\\\\]/).pop() : null,\n      sources: this.uniqueSources.map(source => {\n        return options.file ? getRelativePath(options.file, source.filename) : source.filename;\n      }),\n      sourcesContent: this.uniqueSources.map(source => {\n        return options.includeContent ? source.content : null;\n      }),\n      names,\n      mappings: mappings.raw\n    };\n  }\n\n  generateMap(options) {\n    return new SourceMap(this.generateDecodedMap(options));\n  }\n\n  getIndentString() {\n    const indentStringCounts = {};\n    this.sources.forEach(source => {\n      const indentStr = source.content.indentStr;\n      if (indentStr === null) return;\n      if (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n      indentStringCounts[indentStr] += 1;\n    });\n    return Object.keys(indentStringCounts).sort((a, b) => {\n      return indentStringCounts[a] - indentStringCounts[b];\n    })[0] || '\\t';\n  }\n\n  indent(indentStr) {\n    if (!arguments.length) {\n      indentStr = this.getIndentString();\n    }\n\n    if (indentStr === '') return this; // noop\n\n    let trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n    this.sources.forEach((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const indentStart = trailingNewline || i > 0 && /\\r?\\n$/.test(separator);\n      source.content.indent(indentStr, {\n        exclude: source.indentExclusionRanges,\n        indentStart //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\n      });\n      trailingNewline = source.content.lastChar() === '\\n';\n    });\n\n    if (this.intro) {\n      this.intro = indentStr + this.intro.replace(/^[^\\n]/gm, (match, index) => {\n        return index > 0 ? indentStr + match : match;\n      });\n    }\n\n    return this;\n  }\n\n  prepend(str) {\n    this.intro = str + this.intro;\n    return this;\n  }\n\n  toString() {\n    const body = this.sources.map((source, i) => {\n      const separator = source.separator !== undefined ? source.separator : this.separator;\n      const str = (i > 0 ? separator : '') + source.content.toString();\n      return str;\n    }).join('');\n    return this.intro + body;\n  }\n\n  isEmpty() {\n    if (this.intro.length && this.intro.trim()) return false;\n    if (this.sources.some(source => !source.content.isEmpty())) return false;\n    return true;\n  }\n\n  length() {\n    return this.sources.reduce((length, source) => length + source.content.length(), this.intro.length);\n  }\n\n  trimLines() {\n    return this.trim('[\\\\r\\\\n]');\n  }\n\n  trim(charType) {\n    return this.trimStart(charType).trimEnd(charType);\n  }\n\n  trimStart(charType) {\n    const rx = new RegExp('^' + (charType || '\\\\s') + '+');\n    this.intro = this.intro.replace(rx, '');\n\n    if (!this.intro) {\n      let source;\n      let i = 0;\n\n      do {\n        source = this.sources[i++];\n\n        if (!source) {\n          break;\n        }\n      } while (!source.content.trimStartAborted(charType));\n    }\n\n    return this;\n  }\n\n  trimEnd(charType) {\n    const rx = new RegExp((charType || '\\\\s') + '+$');\n    let source;\n    let i = this.sources.length - 1;\n\n    do {\n      source = this.sources[i--];\n\n      if (!source) {\n        this.intro = this.intro.replace(rx, '');\n        break;\n      }\n    } while (!source.content.trimEndAborted(charType));\n\n    return this;\n  }\n\n}\n\nMagicString.Bundle = Bundle;\nMagicString.SourceMap = SourceMap;\nMagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121\n\nmodule.exports = MagicString; //# sourceMappingURL=magic-string.cjs.js.map","map":null,"metadata":{},"sourceType":"script"}