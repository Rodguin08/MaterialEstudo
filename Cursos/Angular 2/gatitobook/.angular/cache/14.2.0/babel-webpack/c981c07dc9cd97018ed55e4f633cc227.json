{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Fetcher = require('./fetcher.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst pacoteVersion = require('../package.json').version;\n\nconst removeTrailingSlashes = require('./util/trailing-slashes.js');\n\nconst npa = require('npm-package-arg');\n\nconst rpj = require('read-package-json-fast');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst ssri = require('ssri');\n\nconst crypto = require('crypto'); // Corgis are cute. üêïüê∂\n\n\nconst corgiDoc = 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*';\nconst fullDoc = 'application/json';\n\nconst fetch = require('npm-registry-fetch');\n\nconst _headers = Symbol('_headers');\n\nclass RegistryFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // you usually don't want to fetch the same packument multiple times in\n    // the span of a given script or command, no matter how many pacote calls\n    // are made, so this lets us avoid doing that.  It's only relevant for\n    // registry fetchers, because other types simulate their packument from\n    // the manifest, which they memoize on this.package, so it's very cheap\n    // already.\n\n    this.packumentCache = this.opts.packumentCache || null; // handle case when npm-package-arg guesses wrong.\n\n    if (this.spec.type === 'tag' && this.spec.rawSpec === '' && this.defaultTag !== 'latest') {\n      this.spec = npa(`${this.spec.name}@${this.defaultTag}`);\n    }\n\n    this.registry = fetch.pickRegistry(spec, opts);\n    this.packumentUrl = removeTrailingSlashes(this.registry) + '/' + this.spec.escapedName;\n    const parsed = new URL(this.registry);\n    const regKey = `//${parsed.host}${parsed.pathname}`; // unlike the nerf-darted auth keys, this one does *not* allow a mismatch\n    // of trailing slashes.  It must match exactly.\n\n    if (this.opts[`${regKey}:_keys`]) {\n      this.registryKeys = this.opts[`${regKey}:_keys`];\n    } // XXX pacote <=9 has some logic to ignore opts.resolved if\n    // the resolved URL doesn't go to the same registry.\n    // Consider reproducing that here, to throw away this.resolved\n    // in that case.\n\n  }\n\n  resolve() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // fetching the manifest sets resolved and (if present) integrity\n      yield _this.manifest();\n\n      if (!_this.resolved) {\n        throw Object.assign(new Error('Invalid package manifest: no `dist.tarball` field'), {\n          package: _this.spec.toString()\n        });\n      }\n\n      return _this.resolved;\n    })();\n  }\n\n  [_headers]() {\n    return {\n      // npm will override UA, but ensure that we always send *something*\n      'user-agent': this.opts.userAgent || `pacote/${pacoteVersion} node/${process.version}`,\n      ...(this.opts.headers || {}),\n      'pacote-version': pacoteVersion,\n      'pacote-req-type': 'packument',\n      'pacote-pkg-id': `registry:${this.spec.name}`,\n      accept: this.fullMetadata ? fullDoc : corgiDoc\n    };\n  }\n\n  packument() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      // note this might be either an in-flight promise for a request,\n      // or the actual packument, but we never want to make more than\n      // one request at a time for the same thing regardless.\n      if (_this2.packumentCache && _this2.packumentCache.has(_this2.packumentUrl)) {\n        return _this2.packumentCache.get(_this2.packumentUrl);\n      } // npm-registry-fetch the packument\n      // set the appropriate header for corgis if fullMetadata isn't set\n      // return the res.json() promise\n\n\n      try {\n        const res = yield fetch(_this2.packumentUrl, { ..._this2.opts,\n          headers: _this2[_headers](),\n          spec: _this2.spec,\n          // never check integrity for packuments themselves\n          integrity: null\n        });\n        const packument = yield res.json();\n        packument._cached = res.headers.has('x-local-cache');\n        packument._contentLength = +res.headers.get('content-length');\n\n        if (_this2.packumentCache) {\n          _this2.packumentCache.set(_this2.packumentUrl, packument);\n        }\n\n        return packument;\n      } catch (err) {\n        if (_this2.packumentCache) {\n          _this2.packumentCache.delete(_this2.packumentUrl);\n        }\n\n        if (err.code !== 'E404' || _this2.fullMetadata) {\n          throw err;\n        } // possible that corgis are not supported by this registry\n\n\n        _this2.fullMetadata = true;\n        return _this2.packument();\n      }\n    })();\n  }\n\n  manifest() {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this3.package) {\n        return _this3.package;\n      }\n\n      const packument = yield _this3.packument();\n      let mani = yield pickManifest(packument, _this3.spec.fetchSpec, { ..._this3.opts,\n        defaultTag: _this3.defaultTag,\n        before: _this3.before\n      });\n      mani = rpj.normalize(mani);\n      /* XXX add ETARGET and E403 revalidation of cached packuments here */\n      // add _resolved and _integrity from dist object\n\n      const {\n        dist\n      } = mani;\n\n      if (dist) {\n        _this3.resolved = mani._resolved = dist.tarball;\n        mani._from = _this3.from;\n        const distIntegrity = dist.integrity ? ssri.parse(dist.integrity) : dist.shasum ? ssri.fromHex(dist.shasum, 'sha1', { ..._this3.opts\n        }) : null;\n\n        if (distIntegrity) {\n          if (_this3.integrity && !_this3.integrity.match(distIntegrity)) {\n            // only bork if they have algos in common.\n            // otherwise we end up breaking if we have saved a sha512\n            // previously for the tarball, but the manifest only\n            // provides a sha1, which is possible for older publishes.\n            // Otherwise, this is almost certainly a case of holding it\n            // wrong, and will result in weird or insecure behavior\n            // later on when building package tree.\n            for (const algo of Object.keys(_this3.integrity)) {\n              if (distIntegrity[algo]) {\n                throw Object.assign(new Error(`Integrity checksum failed when using ${algo}: ` + `wanted ${_this3.integrity} but got ${distIntegrity}.`), {\n                  code: 'EINTEGRITY'\n                });\n              }\n            }\n          } // made it this far, the integrity is worthwhile.  accept it.\n          // the setter here will take care of merging it into what we already\n          // had.\n\n\n          _this3.integrity = distIntegrity;\n        }\n      }\n\n      if (_this3.integrity) {\n        mani._integrity = String(_this3.integrity);\n\n        if (dist.signatures) {\n          if (_this3.opts.verifySignatures) {\n            // validate and throw on error, then set _signatures\n            const message = `${mani._id}:${mani._integrity}`;\n\n            for (const signature of dist.signatures) {\n              const publicKey = _this3.registryKeys && _this3.registryKeys.filter(key => key.keyid === signature.keyid)[0];\n\n              if (!publicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + 'but no corresponding public key can be found'), {\n                  code: 'EMISSINGSIGNATUREKEY'\n                });\n              }\n\n              const validPublicKey = !publicKey.expires || Date.parse(publicKey.expires) > Date.now();\n\n              if (!validPublicKey) {\n                throw Object.assign(new Error(`${mani._id} has a registry signature with keyid: ${signature.keyid} ` + `but the corresponding public key has expired ${publicKey.expires}`), {\n                  code: 'EEXPIREDSIGNATUREKEY'\n                });\n              }\n\n              const verifier = crypto.createVerify('SHA256');\n              verifier.write(message);\n              verifier.end();\n              const valid = verifier.verify(publicKey.pemkey, signature.sig, 'base64');\n\n              if (!valid) {\n                throw Object.assign(new Error(`${mani._id} has an invalid registry signature with ` + `keyid: ${publicKey.keyid} and signature: ${signature.sig}`), {\n                  code: 'EINTEGRITYSIGNATURE',\n                  keyid: publicKey.keyid,\n                  signature: signature.sig,\n                  resolved: mani._resolved,\n                  integrity: mani._integrity\n                });\n              }\n            }\n\n            mani._signatures = dist.signatures;\n          } else {\n            mani._signatures = dist.signatures;\n          }\n        }\n      }\n\n      _this3.package = mani;\n      return _this3.package;\n    })();\n  }\n\n  [_tarballFromResolved]() {\n    // we use a RemoteFetcher to get the actual tarball stream\n    return new RemoteFetcher(this.resolved, { ...this.opts,\n      resolved: this.resolved,\n      pkgid: `registry:${this.spec.name}@${this.resolved}`\n    })[_tarballFromResolved]();\n  }\n\n  get types() {\n    return ['tag', 'version', 'range'];\n  }\n\n}\n\nmodule.exports = RegistryFetcher;","map":null,"metadata":{},"sourceType":"script"}