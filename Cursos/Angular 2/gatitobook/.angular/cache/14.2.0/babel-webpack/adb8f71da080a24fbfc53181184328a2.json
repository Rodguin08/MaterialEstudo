{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CordHost = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst memory_1 = require(\"./memory\");\n/**\n * A Host that records changes to the underlying Host, while keeping a record of Create, Overwrite,\n * Rename and Delete of files.\n *\n * This is fully compatible with Host, but will keep a staging of every changes asked. That staging\n * follows the principle of the Tree (e.g. can create a file that already exists).\n *\n * Using `create()` and `overwrite()` will force those operations, but using `write` will add\n * the create/overwrite records IIF the files does/doesn't already exist.\n */\n\n\nclass CordHost extends memory_1.SimpleMemoryHost {\n  constructor(_back) {\n    super();\n    this._back = _back;\n    this._filesToCreate = new Set();\n    this._filesToRename = new Map();\n    this._filesToRenameRevert = new Map();\n    this._filesToDelete = new Set();\n    this._filesToOverwrite = new Set();\n  }\n\n  get backend() {\n    return this._back;\n  }\n\n  get capabilities() {\n    // Our own host is always Synchronous, but the backend might not be.\n    return {\n      synchronous: this._back.capabilities.synchronous\n    };\n  }\n  /**\n   * Create a copy of this host, including all actions made.\n   * @returns {CordHost} The carbon copy.\n   */\n\n\n  clone() {\n    const dolly = new CordHost(this._back);\n    dolly._cache = new Map(this._cache);\n    dolly._filesToCreate = new Set(this._filesToCreate);\n    dolly._filesToRename = new Map(this._filesToRename);\n    dolly._filesToRenameRevert = new Map(this._filesToRenameRevert);\n    dolly._filesToDelete = new Set(this._filesToDelete);\n    dolly._filesToOverwrite = new Set(this._filesToOverwrite);\n    return dolly;\n  }\n  /**\n   * Commit the changes recorded to a Host. It is assumed that the host does have the same structure\n   * as the host that was used for backend (could be the same host).\n   * @param host The host to create/delete/rename/overwrite files to.\n   * @param force Whether to skip existence checks when creating/overwriting. This is\n   *   faster but might lead to incorrect states. Because Hosts natively don't support creation\n   *   versus overwriting (it's only writing), we check for existence before completing a request.\n   * @returns An observable that completes when done, or error if an error occured.\n   */\n\n\n  commit(host, force = false) {\n    // Really commit everything to the actual host.\n    return (0, rxjs_1.from)(this.records()).pipe((0, operators_1.concatMap)(record => {\n      switch (record.kind) {\n        case 'delete':\n          return host.delete(record.path);\n\n        case 'rename':\n          return host.rename(record.from, record.to);\n\n        case 'create':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n\n        case 'overwrite':\n          return host.exists(record.path).pipe((0, operators_1.switchMap)(exists => {\n            if (!exists && !force) {\n              return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(record.path));\n            } else {\n              return host.write(record.path, record.content);\n            }\n          }));\n      }\n    }), (0, operators_1.reduce)(() => {}));\n  }\n\n  records() {\n    return [...[...this._filesToDelete.values()].map(path => ({\n      kind: 'delete',\n      path\n    })), ...[...this._filesToRename.entries()].map(([from, to]) => ({\n      kind: 'rename',\n      from,\n      to\n    })), ...[...this._filesToCreate.values()].map(path => ({\n      kind: 'create',\n      path,\n      content: this._read(path)\n    })), ...[...this._filesToOverwrite.values()].map(path => ({\n      kind: 'overwrite',\n      path,\n      content: this._read(path)\n    }))];\n  }\n  /**\n   * Specialized version of {@link CordHost#write} which forces the creation of a file whether it\n   * exists or not.\n   * @param {} path\n   * @param {FileBuffer} content\n   * @returns {Observable<void>}\n   */\n\n\n  create(path, content) {\n    if (super._exists(path)) {\n      throw new exception_1.FileAlreadyExistException(path);\n    }\n\n    if (this._filesToDelete.has(path)) {\n      this._filesToDelete.delete(path);\n\n      this._filesToOverwrite.add(path);\n    } else {\n      this._filesToCreate.add(path);\n    }\n\n    return super.write(path, content);\n  }\n\n  overwrite(path, content) {\n    return this.isDirectory(path).pipe((0, operators_1.switchMap)(isDir => {\n      if (isDir) {\n        return (0, rxjs_1.throwError)(new exception_1.PathIsDirectoryException(path));\n      }\n\n      return this.exists(path);\n    }), (0, operators_1.switchMap)(exists => {\n      if (!exists) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n      }\n\n      if (!this._filesToCreate.has(path)) {\n        this._filesToOverwrite.add(path);\n      }\n\n      return super.write(path, content);\n    }));\n  }\n\n  write(path, content) {\n    return this.exists(path).pipe((0, operators_1.switchMap)(exists => {\n      if (exists) {\n        // It exists, but might be being renamed or deleted. In that case we want to create it.\n        if (this.willRename(path) || this.willDelete(path)) {\n          return this.create(path, content);\n        } else {\n          return this.overwrite(path, content);\n        }\n      } else {\n        return this.create(path, content);\n      }\n    }));\n  }\n\n  read(path) {\n    if (this._exists(path)) {\n      return super.read(path);\n    }\n\n    return this._back.read(path);\n  }\n\n  delete(path) {\n    if (this._exists(path)) {\n      if (this._filesToCreate.has(path)) {\n        this._filesToCreate.delete(path);\n      } else if (this._filesToOverwrite.has(path)) {\n        this._filesToOverwrite.delete(path);\n\n        this._filesToDelete.add(path);\n      } else {\n        const maybeOrigin = this._filesToRenameRevert.get(path);\n\n        if (maybeOrigin) {\n          this._filesToRenameRevert.delete(path);\n\n          this._filesToRename.delete(maybeOrigin);\n\n          this._filesToDelete.add(maybeOrigin);\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.UnknownException(`This should never happen. Path: ${JSON.stringify(path)}.`));\n        }\n      }\n\n      return super.delete(path);\n    } else {\n      return this._back.exists(path).pipe((0, operators_1.switchMap)(exists => {\n        if (exists) {\n          this._filesToDelete.add(path);\n\n          return (0, rxjs_1.of)();\n        } else {\n          return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(path));\n        }\n      }));\n    }\n  }\n\n  rename(from, to) {\n    return (0, rxjs_1.concat)(this.exists(to), this.exists(from)).pipe((0, operators_1.toArray)(), (0, operators_1.switchMap)(([existTo, existFrom]) => {\n      if (!existFrom) {\n        return (0, rxjs_1.throwError)(new exception_1.FileDoesNotExistException(from));\n      }\n\n      if (from === to) {\n        return rxjs_1.EMPTY;\n      }\n\n      if (existTo) {\n        return (0, rxjs_1.throwError)(new exception_1.FileAlreadyExistException(to));\n      } // If we're renaming a file that's been created, shortcircuit to creating the `to` path.\n\n\n      if (this._filesToCreate.has(from)) {\n        this._filesToCreate.delete(from);\n\n        this._filesToCreate.add(to);\n\n        return super.rename(from, to);\n      }\n\n      if (this._filesToOverwrite.has(from)) {\n        this._filesToOverwrite.delete(from); // Recursively call this function. This is so we don't repeat the bottom logic. This\n        // if will be by-passed because we just deleted the `from` path from files to overwrite.\n\n\n        return (0, rxjs_1.concat)(this.rename(from, to), new rxjs_1.Observable(x => {\n          this._filesToOverwrite.add(to);\n\n          x.complete();\n        }));\n      }\n\n      if (this._filesToDelete.has(to)) {\n        this._filesToDelete.delete(to);\n\n        this._filesToDelete.add(from);\n\n        this._filesToOverwrite.add(to); // We need to delete the original and write the new one.\n\n\n        return this.read(from).pipe((0, operators_1.map)(content => this._write(to, content)));\n      }\n\n      const maybeTo1 = this._filesToRenameRevert.get(from);\n\n      if (maybeTo1) {\n        // We already renamed to this file (A => from), let's rename the former to the new\n        // path (A => to).\n        this._filesToRename.delete(maybeTo1);\n\n        this._filesToRenameRevert.delete(from);\n\n        from = maybeTo1;\n      }\n\n      this._filesToRename.set(from, to);\n\n      this._filesToRenameRevert.set(to, from); // If the file is part of our data, just rename it internally.\n\n\n      if (this._exists(from)) {\n        return super.rename(from, to);\n      } else {\n        // Create a file with the same content.\n        return this._back.read(from).pipe((0, operators_1.switchMap)(content => super.write(to, content)));\n      }\n    }));\n  }\n\n  list(path) {\n    return (0, rxjs_1.concat)(super.list(path), this._back.list(path)).pipe((0, operators_1.reduce)((list, curr) => {\n      curr.forEach(elem => list.add(elem));\n      return list;\n    }, new Set()), (0, operators_1.map)(set => [...set]));\n  }\n\n  exists(path) {\n    return this._exists(path) ? (0, rxjs_1.of)(true) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.exists(path);\n  }\n\n  isDirectory(path) {\n    return this._exists(path) ? super.isDirectory(path) : this._back.isDirectory(path);\n  }\n\n  isFile(path) {\n    return this._exists(path) ? super.isFile(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(false) : this._back.isFile(path);\n  }\n\n  stat(path) {\n    return this._exists(path) ? super.stat(path) : this.willDelete(path) || this.willRename(path) ? (0, rxjs_1.of)(null) : this._back.stat(path);\n  }\n\n  watch(path, options) {\n    // Watching not supported.\n    return null;\n  }\n\n  willCreate(path) {\n    return this._filesToCreate.has(path);\n  }\n\n  willOverwrite(path) {\n    return this._filesToOverwrite.has(path);\n  }\n\n  willDelete(path) {\n    return this._filesToDelete.has(path);\n  }\n\n  willRename(path) {\n    return this._filesToRename.has(path);\n  }\n\n  willRenameTo(path, to) {\n    return this._filesToRename.get(path) === to;\n  }\n\n}\n\nexports.CordHost = CordHost;","map":null,"metadata":{},"sourceType":"script"}