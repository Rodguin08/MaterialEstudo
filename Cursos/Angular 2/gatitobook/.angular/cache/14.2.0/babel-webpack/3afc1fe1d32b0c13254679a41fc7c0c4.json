{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar util = require('util');\n\nvar path = require('path');\n\nlet shim;\n\nclass Y18N {\n  constructor(opts) {\n    // configurable options.\n    opts = opts || {};\n    this.directory = opts.directory || './locales';\n    this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true;\n    this.locale = opts.locale || 'en';\n    this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true; // internal stuff.\n\n    this.cache = Object.create(null);\n    this.writeQueue = [];\n  }\n\n  __(...args) {\n    if (typeof arguments[0] !== 'string') {\n      return this._taggedLiteral(arguments[0], ...arguments);\n    }\n\n    const str = args.shift();\n\n    let cb = function () {}; // start with noop.\n\n\n    if (typeof args[args.length - 1] === 'function') cb = args.pop();\n\n    cb = cb || function () {}; // noop.\n\n\n    if (!this.cache[this.locale]) this._readLocaleFile(); // we've observed a new string, update the language file.\n\n    if (!this.cache[this.locale][str] && this.updateFiles) {\n      this.cache[this.locale][str] = str; // include the current directory and locale,\n      // since these values could change before the\n      // write is performed.\n\n      this._enqueueWrite({\n        directory: this.directory,\n        locale: this.locale,\n        cb\n      });\n    } else {\n      cb();\n    }\n\n    return shim.format.apply(shim.format, [this.cache[this.locale][str] || str].concat(args));\n  }\n\n  __n() {\n    const args = Array.prototype.slice.call(arguments);\n    const singular = args.shift();\n    const plural = args.shift();\n    const quantity = args.shift();\n\n    let cb = function () {}; // start with noop.\n\n\n    if (typeof args[args.length - 1] === 'function') cb = args.pop();\n    if (!this.cache[this.locale]) this._readLocaleFile();\n    let str = quantity === 1 ? singular : plural;\n\n    if (this.cache[this.locale][singular]) {\n      const entry = this.cache[this.locale][singular];\n      str = entry[quantity === 1 ? 'one' : 'other'];\n    } // we've observed a new string, update the language file.\n\n\n    if (!this.cache[this.locale][singular] && this.updateFiles) {\n      this.cache[this.locale][singular] = {\n        one: singular,\n        other: plural\n      }; // include the current directory and locale,\n      // since these values could change before the\n      // write is performed.\n\n      this._enqueueWrite({\n        directory: this.directory,\n        locale: this.locale,\n        cb\n      });\n    } else {\n      cb();\n    } // if a %d placeholder is provided, add quantity\n    // to the arguments expanded by util.format.\n\n\n    const values = [str];\n    if (~str.indexOf('%d')) values.push(quantity);\n    return shim.format.apply(shim.format, values.concat(args));\n  }\n\n  setLocale(locale) {\n    this.locale = locale;\n  }\n\n  getLocale() {\n    return this.locale;\n  }\n\n  updateLocale(obj) {\n    if (!this.cache[this.locale]) this._readLocaleFile();\n\n    for (const key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        this.cache[this.locale][key] = obj[key];\n      }\n    }\n  }\n\n  _taggedLiteral(parts, ...args) {\n    let str = '';\n    parts.forEach(function (part, i) {\n      const arg = args[i + 1];\n      str += part;\n\n      if (typeof arg !== 'undefined') {\n        str += '%s';\n      }\n    });\n    return this.__.apply(this, [str].concat([].slice.call(args, 1)));\n  }\n\n  _enqueueWrite(work) {\n    this.writeQueue.push(work);\n    if (this.writeQueue.length === 1) this._processWriteQueue();\n  }\n\n  _processWriteQueue() {\n    const _this = this;\n\n    const work = this.writeQueue[0]; // destructure the enqueued work.\n\n    const directory = work.directory;\n    const locale = work.locale;\n    const cb = work.cb;\n\n    const languageFile = this._resolveLocaleFile(directory, locale);\n\n    const serializedLocale = JSON.stringify(this.cache[locale], null, 2);\n    shim.fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n      _this.writeQueue.shift();\n\n      if (_this.writeQueue.length > 0) _this._processWriteQueue();\n      cb(err);\n    });\n  }\n\n  _readLocaleFile() {\n    let localeLookup = {};\n\n    const languageFile = this._resolveLocaleFile(this.directory, this.locale);\n\n    try {\n      // When using a bundler such as webpack, readFileSync may not be defined:\n      if (shim.fs.readFileSync) {\n        localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, 'utf-8'));\n      }\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        err.message = 'syntax error in ' + languageFile;\n      }\n\n      if (err.code === 'ENOENT') localeLookup = {};else throw err;\n    }\n\n    this.cache[this.locale] = localeLookup;\n  }\n\n  _resolveLocaleFile(directory, locale) {\n    let file = shim.resolve(directory, './', locale + '.json');\n\n    if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n      // attempt fallback to language only\n      const languageFile = shim.resolve(directory, './', locale.split('_')[0] + '.json');\n      if (this._fileExistsSync(languageFile)) file = languageFile;\n    }\n\n    return file;\n  }\n\n  _fileExistsSync(file) {\n    return shim.exists(file);\n  }\n\n}\n\nfunction y18n$1(opts, _shim) {\n  shim = _shim;\n  const y18n = new Y18N(opts);\n  return {\n    __: y18n.__.bind(y18n),\n    __n: y18n.__n.bind(y18n),\n    setLocale: y18n.setLocale.bind(y18n),\n    getLocale: y18n.getLocale.bind(y18n),\n    updateLocale: y18n.updateLocale.bind(y18n),\n    locale: y18n.locale\n  };\n}\n\nvar nodePlatformShim = {\n  fs: {\n    readFileSync: fs.readFileSync,\n    writeFile: fs.writeFile\n  },\n  format: util.format,\n  resolve: path.resolve,\n  exists: file => {\n    try {\n      return fs.statSync(file).isFile();\n    } catch (err) {\n      return false;\n    }\n  }\n};\n\nconst y18n = opts => {\n  return y18n$1(opts, nodePlatformShim);\n};\n\nmodule.exports = y18n;","map":null,"metadata":{},"sourceType":"script"}