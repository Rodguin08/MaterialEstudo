{"ast":null,"code":"'use strict'; // classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\n\nconst {\n  Yargs,\n  processArgv\n} = require('./build/index.cjs');\n\nArgv(processArgv.hideBin(process.argv));\nmodule.exports = Argv;\n\nfunction Argv(processArgs, cwd) {\n  const argv = Yargs(processArgs, cwd, require);\n  singletonify(argv); // TODO(bcoe): warn if argv.parse() or argv.argv is used directly.\n\n  return argv;\n}\n\nfunction defineGetter(obj, key, getter) {\n  Object.defineProperty(obj, key, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  });\n}\n\nfunction lookupGetter(obj, key) {\n  const desc = Object.getOwnPropertyDescriptor(obj, key);\n\n  if (typeof desc !== 'undefined') {\n    return desc.get;\n  }\n}\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\n\n\nfunction singletonify(inst) {\n  [...Object.keys(inst), ...Object.getOwnPropertyNames(inst.constructor.prototype)].forEach(key => {\n    if (key === 'argv') {\n      defineGetter(Argv, key, lookupGetter(inst, key));\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst);\n    } else {\n      defineGetter(Argv, '$0', () => inst.$0);\n      defineGetter(Argv, 'parsed', () => inst.parsed);\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}