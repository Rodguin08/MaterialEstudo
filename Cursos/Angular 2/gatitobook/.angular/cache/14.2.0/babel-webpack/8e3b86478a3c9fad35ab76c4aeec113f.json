{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WorkspaceNodeModulesArchitectHost = void 0;\n\nconst path = __importStar(require(\"path\"));\n\nconst url_1 = require(\"url\");\n\nconst v8_1 = require(\"v8\");\n\nconst internal_1 = require(\"../src/internal\");\n\nfunction clone(obj) {\n  try {\n    return (0, v8_1.deserialize)((0, v8_1.serialize)(obj));\n  } catch {\n    return JSON.parse(JSON.stringify(obj));\n  }\n}\n\nfunction findProjectTarget(workspace, project, target) {\n  const projectDefinition = workspace.projects.get(project);\n\n  if (!projectDefinition) {\n    throw new Error(`Project \"${project}\" does not exist.`);\n  }\n\n  const targetDefinition = projectDefinition.targets.get(target);\n\n  if (!targetDefinition) {\n    throw new Error('Project target does not exist.');\n  }\n\n  return targetDefinition;\n}\n\nclass WorkspaceNodeModulesArchitectHost {\n  constructor(workspaceOrHost, _root) {\n    this._root = _root;\n\n    if ('getBuilderName' in workspaceOrHost) {\n      this.workspaceHost = workspaceOrHost;\n    } else {\n      this.workspaceHost = {\n        getBuilderName(project, target) {\n          return _asyncToGenerator(function* () {\n            const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n            return targetDefinition.builder;\n          })();\n        },\n\n        getOptions(project, target, configuration) {\n          return _asyncToGenerator(function* () {\n            var _a, _b, _c, _d;\n\n            const targetDefinition = findProjectTarget(workspaceOrHost, project, target);\n\n            if (configuration === undefined) {\n              return (_a = targetDefinition.options) !== null && _a !== void 0 ? _a : {};\n            }\n\n            if (!((_b = targetDefinition.configurations) === null || _b === void 0 ? void 0 : _b[configuration])) {\n              throw new Error(`Configuration '${configuration}' is not set in the workspace.`);\n            }\n\n            return (_d = (_c = targetDefinition.configurations) === null || _c === void 0 ? void 0 : _c[configuration]) !== null && _d !== void 0 ? _d : {};\n          })();\n        },\n\n        getMetadata(project) {\n          return _asyncToGenerator(function* () {\n            const projectDefinition = workspaceOrHost.projects.get(project);\n\n            if (!projectDefinition) {\n              throw new Error(`Project \"${project}\" does not exist.`);\n            }\n\n            return {\n              root: projectDefinition.root,\n              sourceRoot: projectDefinition.sourceRoot,\n              prefix: projectDefinition.prefix,\n              ...clone(workspaceOrHost.extensions),\n              ...clone(projectDefinition.extensions)\n            };\n          })();\n        },\n\n        hasTarget(project, target) {\n          return _asyncToGenerator(function* () {\n            var _a;\n\n            return !!((_a = workspaceOrHost.projects.get(project)) === null || _a === void 0 ? void 0 : _a.targets.has(target));\n          })();\n        },\n\n        getDefaultConfigurationName(project, target) {\n          return _asyncToGenerator(function* () {\n            var _a, _b;\n\n            return (_b = (_a = workspaceOrHost.projects.get(project)) === null || _a === void 0 ? void 0 : _a.targets.get(target)) === null || _b === void 0 ? void 0 : _b.defaultConfiguration;\n          })();\n        }\n\n      };\n    }\n  }\n\n  getBuilderNameForTarget(target) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      return _this.workspaceHost.getBuilderName(target.project, target.target);\n    })();\n  }\n  /**\n   * Resolve a builder. This needs to be a string which will be used in a dynamic `import()`\n   * clause. This should throw if no builder can be found. The dynamic import will throw if\n   * it is unsupported.\n   * @param builderStr The name of the builder to be used.\n   * @returns All the info needed for the builder itself.\n   */\n\n\n  resolveBuilder(builderStr) {\n    const [packageName, builderName] = builderStr.split(':', 2);\n\n    if (!builderName) {\n      throw new Error('No builder name specified.');\n    }\n\n    const packageJsonPath = require.resolve(packageName + '/package.json', {\n      paths: [this._root]\n    });\n\n    const packageJson = require(packageJsonPath);\n\n    if (!packageJson['builders']) {\n      throw new Error(`Package ${JSON.stringify(packageName)} has no builders defined.`);\n    }\n\n    const builderJsonPath = path.resolve(path.dirname(packageJsonPath), packageJson['builders']);\n\n    const builderJson = require(builderJsonPath);\n\n    const builder = builderJson.builders && builderJson.builders[builderName];\n\n    if (!builder) {\n      throw new Error(`Cannot find builder ${JSON.stringify(builderStr)}.`);\n    }\n\n    const importPath = builder.implementation;\n\n    if (!importPath) {\n      throw new Error('Could not find the implementation for builder ' + builderStr);\n    }\n\n    return Promise.resolve({\n      name: builderStr,\n      builderName,\n      description: builder['description'],\n      optionSchema: require(path.resolve(path.dirname(builderJsonPath), builder.schema)),\n      import: path.resolve(path.dirname(builderJsonPath), importPath)\n    });\n  }\n\n  getCurrentDirectory() {\n    return _asyncToGenerator(function* () {\n      return process.cwd();\n    })();\n  }\n\n  getWorkspaceRoot() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      return _this2._root;\n    })();\n  }\n\n  getOptionsForTarget(target) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!(yield _this3.workspaceHost.hasTarget(target.project, target.target))) {\n        return null;\n      }\n\n      let options = yield _this3.workspaceHost.getOptions(target.project, target.target);\n      const targetConfiguration = target.configuration || (yield _this3.workspaceHost.getDefaultConfigurationName(target.project, target.target));\n\n      if (targetConfiguration) {\n        const configurations = targetConfiguration.split(',').map(c => c.trim());\n\n        for (const configuration of configurations) {\n          options = { ...options,\n            ...(yield _this3.workspaceHost.getOptions(target.project, target.target, configuration))\n          };\n        }\n      }\n\n      return clone(options);\n    })();\n  }\n\n  getProjectMetadata(target) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const projectName = typeof target === 'string' ? target : target.project;\n\n      const metadata = _this4.workspaceHost.getMetadata(projectName);\n\n      return metadata;\n    })();\n  }\n\n  loadBuilder(info) {\n    return _asyncToGenerator(function* () {\n      const builder = yield getBuilder(info.import);\n\n      if (builder[internal_1.BuilderSymbol]) {\n        return builder;\n      } // Default handling code is for old builders that incorrectly export `default` with non-ESM module\n\n\n      if (builder === null || builder === void 0 ? void 0 : builder.default[internal_1.BuilderSymbol]) {\n        return builder.default;\n      }\n\n      throw new Error('Builder is not a builder');\n    })();\n  }\n\n}\n\nexports.WorkspaceNodeModulesArchitectHost = WorkspaceNodeModulesArchitectHost;\n/**\n * This uses a dynamic import to load a module which may be ESM.\n * CommonJS code can load ESM code via a dynamic import. Unfortunately, TypeScript\n * will currently, unconditionally downlevel dynamic import into a require call.\n * require calls cannot load ESM code and will result in a runtime error. To workaround\n * this, a Function constructor is used to prevent TypeScript from changing the dynamic import.\n * Once TypeScript provides support for keeping the dynamic import this workaround can\n * be dropped.\n *\n * @param modulePath The path of the module to load.\n * @returns A Promise that resolves to the dynamically imported module.\n */\n\nfunction loadEsmModule(modulePath) {\n  return new Function('modulePath', `return import(modulePath);`)(modulePath);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction getBuilder(_x) {\n  return _getBuilder.apply(this, arguments);\n}\n\nfunction _getBuilder() {\n  _getBuilder = _asyncToGenerator(function* (builderPath) {\n    switch (path.extname(builderPath)) {\n      case '.mjs':\n        // Load the ESM configuration file using the TypeScript dynamic import workaround.\n        // Once TypeScript provides support for keeping the dynamic import this workaround can be\n        // changed to a direct dynamic import.\n        return (yield loadEsmModule((0, url_1.pathToFileURL)(builderPath))).default;\n\n      case '.cjs':\n        return require(builderPath);\n\n      default:\n        // The file could be either CommonJS or ESM.\n        // CommonJS is tried first then ESM if loading fails.\n        try {\n          return require(builderPath);\n        } catch (e) {\n          if (e.code === 'ERR_REQUIRE_ESM') {\n            // Load the ESM configuration file using the TypeScript dynamic import workaround.\n            // Once TypeScript provides support for keeping the dynamic import this workaround can be\n            // changed to a direct dynamic import.\n            return (yield loadEsmModule((0, url_1.pathToFileURL)(builderPath))).default;\n          }\n\n          throw e;\n        }\n\n    }\n  });\n  return _getBuilder.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}