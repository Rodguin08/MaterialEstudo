{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleScheduler = exports.JobOutputSchemaValidationError = exports.JobInboundMessageSchemaValidationError = exports.JobArgumentSchemaValidationError = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst json_1 = require(\"../../json\");\n\nconst api_1 = require(\"./api\");\n\nconst exception_1 = require(\"./exception\");\n\nclass JobArgumentSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Argument failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobArgumentSchemaValidationError = JobArgumentSchemaValidationError;\n\nclass JobInboundMessageSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Inbound Message failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobInboundMessageSchemaValidationError = JobInboundMessageSchemaValidationError;\n\nclass JobOutputSchemaValidationError extends json_1.schema.SchemaValidationException {\n  constructor(errors) {\n    super(errors, 'Job Output failed to validate. Errors: ');\n  }\n\n}\n\nexports.JobOutputSchemaValidationError = JobOutputSchemaValidationError;\n\nfunction _jobShare() {\n  // This is the same code as a `shareReplay()` operator, but uses a dumber Subject rather than a\n  // ReplaySubject.\n  return source => {\n    let refCount = 0;\n    let subject;\n    let hasError = false;\n    let isComplete = false;\n    let subscription;\n    return new rxjs_1.Observable(subscriber => {\n      let innerSub;\n      refCount++;\n\n      if (!subject) {\n        subject = new rxjs_1.Subject();\n        innerSub = subject.subscribe(subscriber);\n        subscription = source.subscribe({\n          next(value) {\n            subject.next(value);\n          },\n\n          error(err) {\n            hasError = true;\n            subject.error(err);\n          },\n\n          complete() {\n            isComplete = true;\n            subject.complete();\n          }\n\n        });\n      } else {\n        innerSub = subject.subscribe(subscriber);\n      }\n\n      return () => {\n        refCount--;\n        innerSub.unsubscribe();\n\n        if (subscription && refCount === 0 && (isComplete || hasError)) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n}\n/**\n * Simple scheduler. Should be the base of all registries and schedulers.\n */\n\n\nclass SimpleScheduler {\n  constructor(_jobRegistry, _schemaRegistry = new json_1.schema.CoreSchemaRegistry()) {\n    this._jobRegistry = _jobRegistry;\n    this._schemaRegistry = _schemaRegistry;\n    this._internalJobDescriptionMap = new Map();\n    this._queue = [];\n    this._pauseCounter = 0;\n  }\n\n  _getInternalDescription(name) {\n    const maybeHandler = this._internalJobDescriptionMap.get(name);\n\n    if (maybeHandler !== undefined) {\n      return (0, rxjs_1.of)(maybeHandler);\n    }\n\n    const handler = this._jobRegistry.get(name);\n\n    return handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        return (0, rxjs_1.of)(null);\n      }\n\n      const description = { // Make a copy of it to be sure it's proper JSON.\n        ...JSON.parse(JSON.stringify(handler.jobDescription)),\n        name: handler.jobDescription.name || name,\n        argument: handler.jobDescription.argument || true,\n        input: handler.jobDescription.input || true,\n        output: handler.jobDescription.output || true,\n        channels: handler.jobDescription.channels || {}\n      };\n      const handlerWithExtra = Object.assign(handler.bind(undefined), {\n        jobDescription: description,\n        argumentV: this._schemaRegistry.compile(description.argument).pipe((0, operators_1.shareReplay)(1)),\n        inputV: this._schemaRegistry.compile(description.input).pipe((0, operators_1.shareReplay)(1)),\n        outputV: this._schemaRegistry.compile(description.output).pipe((0, operators_1.shareReplay)(1))\n      });\n\n      this._internalJobDescriptionMap.set(name, handlerWithExtra);\n\n      return (0, rxjs_1.of)(handlerWithExtra);\n    }));\n  }\n  /**\n   * Get a job description for a named job.\n   *\n   * @param name The name of the job.\n   * @returns A description, or null if the job is not registered.\n   */\n\n\n  getDescription(name) {\n    return (0, rxjs_1.concat)(this._getInternalDescription(name).pipe((0, operators_1.map)(x => x && x.jobDescription)), (0, rxjs_1.of)(null)).pipe((0, operators_1.first)());\n  }\n  /**\n   * Returns true if the job name has been registered.\n   * @param name The name of the job.\n   * @returns True if the job exists, false otherwise.\n   */\n\n\n  has(name) {\n    return this.getDescription(name).pipe((0, operators_1.map)(x => x !== null));\n  }\n  /**\n   * Pause the scheduler, temporary queueing _new_ jobs. Returns a resume function that should be\n   * used to resume execution. If multiple `pause()` were called, all their resume functions must\n   * be called before the Scheduler actually starts new jobs. Additional calls to the same resume\n   * function will have no effect.\n   *\n   * Jobs already running are NOT paused. This is pausing the scheduler only.\n   */\n\n\n  pause() {\n    let called = false;\n    this._pauseCounter++;\n    return () => {\n      if (!called) {\n        called = true;\n\n        if (--this._pauseCounter == 0) {\n          // Resume the queue.\n          const q = this._queue;\n          this._queue = [];\n          q.forEach(fn => fn());\n        }\n      }\n    };\n  }\n  /**\n   * Schedule a job to be run, using its name.\n   * @param name The name of job to be run.\n   * @param argument The argument to send to the job when starting it.\n   * @param options Scheduling options.\n   * @returns The Job being run.\n   */\n\n\n  schedule(name, argument, options) {\n    if (this._pauseCounter > 0) {\n      const waitable = new rxjs_1.Subject();\n\n      this._queue.push(() => waitable.complete());\n\n      return this._scheduleJob(name, argument, options || {}, waitable);\n    }\n\n    return this._scheduleJob(name, argument, options || {}, rxjs_1.EMPTY);\n  }\n  /**\n   * Filter messages.\n   * @private\n   */\n\n\n  _filterJobOutboundMessages(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return state == api_1.JobState.Queued;\n\n      case api_1.JobOutboundMessageKind.Start:\n        return state == api_1.JobState.Ready;\n\n      case api_1.JobOutboundMessageKind.End:\n        return state == api_1.JobState.Started || state == api_1.JobState.Ready;\n    }\n\n    return true;\n  }\n  /**\n   * Return a new state. This is just to simplify the reading of the _createJob method.\n   * @private\n   */\n\n\n  _updateState(message, state) {\n    switch (message.kind) {\n      case api_1.JobOutboundMessageKind.OnReady:\n        return api_1.JobState.Ready;\n\n      case api_1.JobOutboundMessageKind.Start:\n        return api_1.JobState.Started;\n\n      case api_1.JobOutboundMessageKind.End:\n        return api_1.JobState.Ended;\n    }\n\n    return state;\n  }\n  /**\n   * Create the job.\n   * @private\n   */\n\n\n  _createJob(name, argument, handler, inboundBus, outboundBus) {\n    const schemaRegistry = this._schemaRegistry;\n    const channelsSubject = new Map();\n    const channels = new Map();\n    let state = api_1.JobState.Queued;\n    let pingId = 0; // Create the input channel by having a filter.\n\n    const input = new rxjs_1.Subject();\n    input.pipe((0, operators_1.concatMap)(message => handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler === null) {\n        throw new exception_1.JobDoesNotExistException(name);\n      } else {\n        return handler.inputV.pipe((0, operators_1.switchMap)(validate => validate(message)));\n      }\n    }))), (0, operators_1.filter)(result => result.success), (0, operators_1.map)(result => result.data)).subscribe(value => inboundBus.next({\n      kind: api_1.JobInboundMessageKind.Input,\n      value\n    }));\n    outboundBus = (0, rxjs_1.concat)(outboundBus, // Add an End message at completion. This will be filtered out if the job actually send an\n    // End.\n    handler.pipe((0, operators_1.switchMap)(handler => {\n      if (handler) {\n        return (0, rxjs_1.of)({\n          kind: api_1.JobOutboundMessageKind.End,\n          description: handler.jobDescription\n        });\n      } else {\n        return rxjs_1.EMPTY;\n      }\n    }))).pipe((0, operators_1.filter)(message => this._filterJobOutboundMessages(message, state)), // Update internal logic and Job<> members.\n    (0, operators_1.tap)(message => {\n      // Update the state.\n      state = this._updateState(message, state);\n\n      switch (message.kind) {\n        case api_1.JobOutboundMessageKind.ChannelCreate:\n          {\n            const maybeSubject = channelsSubject.get(message.name); // If it doesn't exist or it's closed on the other end.\n\n            if (!maybeSubject) {\n              const s = new rxjs_1.Subject();\n              channelsSubject.set(message.name, s);\n              channels.set(message.name, s.asObservable());\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelMessage:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.next(message.message);\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelComplete:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.complete();\n              channelsSubject.delete(message.name);\n            }\n\n            break;\n          }\n\n        case api_1.JobOutboundMessageKind.ChannelError:\n          {\n            const maybeSubject = channelsSubject.get(message.name);\n\n            if (maybeSubject) {\n              maybeSubject.error(message.error);\n              channelsSubject.delete(message.name);\n            }\n\n            break;\n          }\n      }\n    }, () => {\n      state = api_1.JobState.Errored;\n    }), // Do output validation (might include default values so this might have side\n    // effects). We keep all messages in order.\n    (0, operators_1.concatMap)(message => {\n      if (message.kind !== api_1.JobOutboundMessageKind.Output) {\n        return (0, rxjs_1.of)(message);\n      }\n\n      return handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return handler.outputV.pipe((0, operators_1.switchMap)(validate => validate(message.value)), (0, operators_1.switchMap)(output => {\n            if (!output.success) {\n              throw new JobOutputSchemaValidationError(output.errors);\n            }\n\n            return (0, rxjs_1.of)({ ...message,\n              output: output.data\n            });\n          }));\n        }\n      }));\n    }), _jobShare());\n    const output = outboundBus.pipe((0, operators_1.filter)(x => x.kind == api_1.JobOutboundMessageKind.Output), (0, operators_1.map)(x => x.value), (0, operators_1.shareReplay)(1)); // Return the Job.\n\n    return {\n      get state() {\n        return state;\n      },\n\n      argument,\n      description: handler.pipe((0, operators_1.switchMap)(handler => {\n        if (handler === null) {\n          throw new exception_1.JobDoesNotExistException(name);\n        } else {\n          return (0, rxjs_1.of)(handler.jobDescription);\n        }\n      })),\n      output,\n\n      getChannel(name, schema = true) {\n        let maybeObservable = channels.get(name);\n\n        if (!maybeObservable) {\n          const s = new rxjs_1.Subject();\n          channelsSubject.set(name, s);\n          channels.set(name, s.asObservable());\n          maybeObservable = s.asObservable();\n        }\n\n        return maybeObservable.pipe( // Keep the order of messages.\n        (0, operators_1.concatMap)(message => {\n          return schemaRegistry.compile(schema).pipe((0, operators_1.switchMap)(validate => validate(message)), (0, operators_1.filter)(x => x.success), (0, operators_1.map)(x => x.data));\n        }));\n      },\n\n      ping() {\n        const id = pingId++;\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Ping,\n          id\n        });\n        return outboundBus.pipe((0, operators_1.filter)(x => x.kind === api_1.JobOutboundMessageKind.Pong && x.id == id), (0, operators_1.first)(), (0, operators_1.ignoreElements)());\n      },\n\n      stop() {\n        inboundBus.next({\n          kind: api_1.JobInboundMessageKind.Stop\n        });\n      },\n\n      input,\n      inboundBus,\n      outboundBus\n    };\n  }\n\n  _scheduleJob(name, argument, options, waitable) {\n    // Get handler first, since this can error out if there's no handler for the job name.\n    const handler = this._getInternalDescription(name);\n\n    const optionsDeps = options && options.dependencies || [];\n    const dependencies = Array.isArray(optionsDeps) ? optionsDeps : [optionsDeps];\n    const inboundBus = new rxjs_1.Subject();\n    const outboundBus = (0, rxjs_1.concat)( // Wait for dependencies, make sure to not report messages from dependencies. Subscribe to\n    // all dependencies at the same time so they run concurrently.\n    (0, rxjs_1.merge)(...dependencies.map(x => x.outboundBus)).pipe((0, operators_1.ignoreElements)()), // Wait for pause() to clear (if necessary).\n    waitable, (0, rxjs_1.from)(handler).pipe((0, operators_1.switchMap)(handler => new rxjs_1.Observable(subscriber => {\n      if (!handler) {\n        throw new exception_1.JobDoesNotExistException(name);\n      } // Validate the argument.\n\n\n      return handler.argumentV.pipe((0, operators_1.switchMap)(validate => validate(argument)), (0, operators_1.switchMap)(output => {\n        if (!output.success) {\n          throw new JobArgumentSchemaValidationError(output.errors);\n        }\n\n        const argument = output.data;\n        const description = handler.jobDescription;\n        subscriber.next({\n          kind: api_1.JobOutboundMessageKind.OnReady,\n          description\n        });\n        const context = {\n          description,\n          dependencies: [...dependencies],\n          inboundBus: inboundBus.asObservable(),\n          scheduler: this\n        };\n        return handler(argument, context);\n      })).subscribe(subscriber);\n    }))));\n    return this._createJob(name, argument, handler, inboundBus, outboundBus);\n  }\n\n}\n\nexports.SimpleScheduler = SimpleScheduler;","map":null,"metadata":{},"sourceType":"script"}