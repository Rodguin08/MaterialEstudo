{"ast":null,"code":"const Minipass = require('minipass');\n\nclass SizeError extends Error {\n  constructor(found, expect) {\n    super(`Bad data size: expected ${expect} bytes, but got ${found}`);\n    this.expect = expect;\n    this.found = found;\n    this.code = 'EBADSIZE';\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  get name() {\n    return 'SizeError';\n  }\n\n}\n\nlet MinipassSized = /*#__PURE__*/(() => {\n  class MinipassSized extends Minipass {\n    constructor(options = {}) {\n      super(options);\n      if (options.objectMode) throw new TypeError(`${this.constructor.name} streams only work with string and buffer data`);\n      this.found = 0;\n      this.expect = options.size;\n      if (typeof this.expect !== 'number' || this.expect > Number.MAX_SAFE_INTEGER || isNaN(this.expect) || this.expect < 0 || !isFinite(this.expect) || this.expect !== Math.floor(this.expect)) throw new Error('invalid expected size: ' + this.expect);\n    }\n\n    write(chunk, encoding, cb) {\n      const buffer = Buffer.isBuffer(chunk) ? chunk : typeof chunk === 'string' ? Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8') : chunk;\n\n      if (!Buffer.isBuffer(buffer)) {\n        this.emit('error', new TypeError(`${this.constructor.name} streams only work with string and buffer data`));\n        return false;\n      }\n\n      this.found += buffer.length;\n      if (this.found > this.expect) this.emit('error', new SizeError(this.found, this.expect));\n      return super.write(chunk, encoding, cb);\n    }\n\n    emit(ev, ...data) {\n      if (ev === 'end') {\n        if (this.found !== this.expect) this.emit('error', new SizeError(this.found, this.expect));\n      }\n\n      return super.emit(ev, ...data);\n    }\n\n  }\n\n  MinipassSized.SizeError = SizeError;\n  return MinipassSized;\n})();\nmodule.exports = MinipassSized;","map":null,"metadata":{},"sourceType":"script"}