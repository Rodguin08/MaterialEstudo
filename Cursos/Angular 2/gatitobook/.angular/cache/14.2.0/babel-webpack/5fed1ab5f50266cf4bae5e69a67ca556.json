{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst readline = require('readline');\n\nconst chalk = require('chalk');\n\nconst cliCursor = require('cli-cursor');\n\nconst cliSpinners = require('cli-spinners');\n\nconst logSymbols = require('log-symbols');\n\nconst stripAnsi = require('strip-ansi');\n\nconst wcwidth = require('wcwidth');\n\nconst isInteractive = require('is-interactive');\n\nconst isUnicodeSupported = require('is-unicode-supported');\n\nconst {\n  BufferListStream\n} = require('bl');\n\nconst TEXT = Symbol('text');\nconst PREFIX_TEXT = Symbol('prefixText');\nconst ASCII_ETX_CODE = 0x03; // Ctrl+C emits this code\n\nclass StdinDiscarder {\n  constructor() {\n    this.requests = 0;\n    this.mutedStream = new BufferListStream();\n    this.mutedStream.pipe(process.stdout);\n    const self = this; // eslint-disable-line unicorn/no-this-assignment\n\n    this.ourEmit = function (event, data, ...args) {\n      const {\n        stdin\n      } = process;\n\n      if (self.requests > 0 || stdin.emit === self.ourEmit) {\n        if (event === 'keypress') {\n          // Fixes readline behavior\n          return;\n        }\n\n        if (event === 'data' && data.includes(ASCII_ETX_CODE)) {\n          process.emit('SIGINT');\n        }\n\n        Reflect.apply(self.oldEmit, this, [event, data, ...args]);\n      } else {\n        Reflect.apply(process.stdin.emit, this, [event, data, ...args]);\n      }\n    };\n  }\n\n  start() {\n    this.requests++;\n\n    if (this.requests === 1) {\n      this.realStart();\n    }\n  }\n\n  stop() {\n    if (this.requests <= 0) {\n      throw new Error('`stop` called more times than `start`');\n    }\n\n    this.requests--;\n\n    if (this.requests === 0) {\n      this.realStop();\n    }\n  }\n\n  realStart() {\n    // No known way to make it work reliably on Windows\n    if (process.platform === 'win32') {\n      return;\n    }\n\n    this.rl = readline.createInterface({\n      input: process.stdin,\n      output: this.mutedStream\n    });\n    this.rl.on('SIGINT', () => {\n      if (process.listenerCount('SIGINT') === 0) {\n        process.emit('SIGINT');\n      } else {\n        this.rl.close();\n        process.kill(process.pid, 'SIGINT');\n      }\n    });\n  }\n\n  realStop() {\n    if (process.platform === 'win32') {\n      return;\n    }\n\n    this.rl.close();\n    this.rl = undefined;\n  }\n\n}\n\nlet stdinDiscarder;\n\nclass Ora {\n  constructor(options) {\n    if (!stdinDiscarder) {\n      stdinDiscarder = new StdinDiscarder();\n    }\n\n    if (typeof options === 'string') {\n      options = {\n        text: options\n      };\n    }\n\n    this.options = {\n      text: '',\n      color: 'cyan',\n      stream: process.stderr,\n      discardStdin: true,\n      ...options\n    };\n    this.spinner = this.options.spinner;\n    this.color = this.options.color;\n    this.hideCursor = this.options.hideCursor !== false;\n    this.interval = this.options.interval || this.spinner.interval || 100;\n    this.stream = this.options.stream;\n    this.id = undefined;\n    this.isEnabled = typeof this.options.isEnabled === 'boolean' ? this.options.isEnabled : isInteractive({\n      stream: this.stream\n    });\n    this.isSilent = typeof this.options.isSilent === 'boolean' ? this.options.isSilent : false; // Set *after* `this.stream`\n\n    this.text = this.options.text;\n    this.prefixText = this.options.prefixText;\n    this.linesToClear = 0;\n    this.indent = this.options.indent;\n    this.discardStdin = this.options.discardStdin;\n    this.isDiscardingStdin = false;\n  }\n\n  get indent() {\n    return this._indent;\n  }\n\n  set indent(indent = 0) {\n    if (!(indent >= 0 && Number.isInteger(indent))) {\n      throw new Error('The `indent` option must be an integer from 0 and up');\n    }\n\n    this._indent = indent;\n  }\n\n  _updateInterval(interval) {\n    if (interval !== undefined) {\n      this.interval = interval;\n    }\n  }\n\n  get spinner() {\n    return this._spinner;\n  }\n\n  set spinner(spinner) {\n    this.frameIndex = 0;\n\n    if (typeof spinner === 'object') {\n      if (spinner.frames === undefined) {\n        throw new Error('The given spinner must have a `frames` property');\n      }\n\n      this._spinner = spinner;\n    } else if (!isUnicodeSupported()) {\n      this._spinner = cliSpinners.line;\n    } else if (spinner === undefined) {\n      // Set default spinner\n      this._spinner = cliSpinners.dots;\n    } else if (spinner !== 'default' && cliSpinners[spinner]) {\n      this._spinner = cliSpinners[spinner];\n    } else {\n      throw new Error(`There is no built-in spinner named '${spinner}'. See https://github.com/sindresorhus/cli-spinners/blob/main/spinners.json for a full list.`);\n    }\n\n    this._updateInterval(this._spinner.interval);\n  }\n\n  get text() {\n    return this[TEXT];\n  }\n\n  set text(value) {\n    this[TEXT] = value;\n    this.updateLineCount();\n  }\n\n  get prefixText() {\n    return this[PREFIX_TEXT];\n  }\n\n  set prefixText(value) {\n    this[PREFIX_TEXT] = value;\n    this.updateLineCount();\n  }\n\n  get isSpinning() {\n    return this.id !== undefined;\n  }\n\n  getFullPrefixText(prefixText = this[PREFIX_TEXT], postfix = ' ') {\n    if (typeof prefixText === 'string') {\n      return prefixText + postfix;\n    }\n\n    if (typeof prefixText === 'function') {\n      return prefixText() + postfix;\n    }\n\n    return '';\n  }\n\n  updateLineCount() {\n    const columns = this.stream.columns || 80;\n    const fullPrefixText = this.getFullPrefixText(this.prefixText, '-');\n    this.lineCount = 0;\n\n    for (const line of stripAnsi(fullPrefixText + '--' + this[TEXT]).split('\\n')) {\n      this.lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));\n    }\n  }\n\n  get isEnabled() {\n    return this._isEnabled && !this.isSilent;\n  }\n\n  set isEnabled(value) {\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The `isEnabled` option must be a boolean');\n    }\n\n    this._isEnabled = value;\n  }\n\n  get isSilent() {\n    return this._isSilent;\n  }\n\n  set isSilent(value) {\n    if (typeof value !== 'boolean') {\n      throw new TypeError('The `isSilent` option must be a boolean');\n    }\n\n    this._isSilent = value;\n  }\n\n  frame() {\n    const {\n      frames\n    } = this.spinner;\n    let frame = frames[this.frameIndex];\n\n    if (this.color) {\n      frame = chalk[this.color](frame);\n    }\n\n    this.frameIndex = ++this.frameIndex % frames.length;\n    const fullPrefixText = typeof this.prefixText === 'string' && this.prefixText !== '' ? this.prefixText + ' ' : '';\n    const fullText = typeof this.text === 'string' ? ' ' + this.text : '';\n    return fullPrefixText + frame + fullText;\n  }\n\n  clear() {\n    if (!this.isEnabled || !this.stream.isTTY) {\n      return this;\n    }\n\n    for (let i = 0; i < this.linesToClear; i++) {\n      if (i > 0) {\n        this.stream.moveCursor(0, -1);\n      }\n\n      this.stream.clearLine();\n      this.stream.cursorTo(this.indent);\n    }\n\n    this.linesToClear = 0;\n    return this;\n  }\n\n  render() {\n    if (this.isSilent) {\n      return this;\n    }\n\n    this.clear();\n    this.stream.write(this.frame());\n    this.linesToClear = this.lineCount;\n    return this;\n  }\n\n  start(text) {\n    if (text) {\n      this.text = text;\n    }\n\n    if (this.isSilent) {\n      return this;\n    }\n\n    if (!this.isEnabled) {\n      if (this.text) {\n        this.stream.write(`- ${this.text}\\n`);\n      }\n\n      return this;\n    }\n\n    if (this.isSpinning) {\n      return this;\n    }\n\n    if (this.hideCursor) {\n      cliCursor.hide(this.stream);\n    }\n\n    if (this.discardStdin && process.stdin.isTTY) {\n      this.isDiscardingStdin = true;\n      stdinDiscarder.start();\n    }\n\n    this.render();\n    this.id = setInterval(this.render.bind(this), this.interval);\n    return this;\n  }\n\n  stop() {\n    if (!this.isEnabled) {\n      return this;\n    }\n\n    clearInterval(this.id);\n    this.id = undefined;\n    this.frameIndex = 0;\n    this.clear();\n\n    if (this.hideCursor) {\n      cliCursor.show(this.stream);\n    }\n\n    if (this.discardStdin && process.stdin.isTTY && this.isDiscardingStdin) {\n      stdinDiscarder.stop();\n      this.isDiscardingStdin = false;\n    }\n\n    return this;\n  }\n\n  succeed(text) {\n    return this.stopAndPersist({\n      symbol: logSymbols.success,\n      text\n    });\n  }\n\n  fail(text) {\n    return this.stopAndPersist({\n      symbol: logSymbols.error,\n      text\n    });\n  }\n\n  warn(text) {\n    return this.stopAndPersist({\n      symbol: logSymbols.warning,\n      text\n    });\n  }\n\n  info(text) {\n    return this.stopAndPersist({\n      symbol: logSymbols.info,\n      text\n    });\n  }\n\n  stopAndPersist(options = {}) {\n    if (this.isSilent) {\n      return this;\n    }\n\n    const prefixText = options.prefixText || this.prefixText;\n    const text = options.text || this.text;\n    const fullText = typeof text === 'string' ? ' ' + text : '';\n    this.stop();\n    this.stream.write(`${this.getFullPrefixText(prefixText, ' ')}${options.symbol || ' '}${fullText}\\n`);\n    return this;\n  }\n\n}\n\nconst oraFactory = function (options) {\n  return new Ora(options);\n};\n\nmodule.exports = oraFactory;\n\nmodule.exports.promise = (action, options) => {\n  // eslint-disable-next-line promise/prefer-await-to-then\n  if (typeof action.then !== 'function') {\n    throw new TypeError('Parameter `action` must be a Promise');\n  }\n\n  const spinner = new Ora(options);\n  spinner.start();\n\n  _asyncToGenerator(function* () {\n    try {\n      yield action;\n      spinner.succeed();\n    } catch {\n      spinner.fail();\n    }\n  })();\n\n  return spinner;\n};","map":null,"metadata":{},"sourceType":"script"}