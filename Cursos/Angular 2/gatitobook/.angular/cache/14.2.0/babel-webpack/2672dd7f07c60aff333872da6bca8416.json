{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  dirname,\n  join,\n  resolve,\n  relative,\n  isAbsolute\n} = require('path');\n\nconst rimraf_ = require('rimraf');\n\nconst {\n  promisify\n} = require('util');\n\nconst {\n  access: access_,\n  accessSync,\n  copyFile: copyFile_,\n  copyFileSync,\n  readdir: readdir_,\n  readdirSync,\n  rename: rename_,\n  renameSync,\n  stat: stat_,\n  statSync,\n  lstat: lstat_,\n  lstatSync,\n  symlink: symlink_,\n  symlinkSync,\n  readlink: readlink_,\n  readlinkSync\n} = require('fs');\n\nconst access = promisify(access_);\nconst copyFile = promisify(copyFile_);\nconst readdir = promisify(readdir_);\nconst rename = promisify(rename_);\nconst stat = promisify(stat_);\nconst lstat = promisify(lstat_);\nconst symlink = promisify(symlink_);\nconst readlink = promisify(readlink_);\nconst rimraf = promisify(rimraf_);\nconst rimrafSync = rimraf_.sync;\n\nconst mkdirp = require('mkdirp');\n\nconst pathExists = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path) {\n    try {\n      yield access(path);\n      return true;\n    } catch (er) {\n      return er.code !== 'ENOENT';\n    }\n  });\n\n  return function pathExists(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst pathExistsSync = path => {\n  try {\n    accessSync(path);\n    return true;\n  } catch (er) {\n    return er.code !== 'ENOENT';\n  }\n};\n\nconst moveFile = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (source, destination, options = {}, root = true, symlinks = []) {\n    if (!source || !destination) {\n      throw new TypeError('`source` and `destination` file required');\n    }\n\n    options = {\n      overwrite: true,\n      ...options\n    };\n\n    if (!options.overwrite && (yield pathExists(destination))) {\n      throw new Error(`The destination file exists: ${destination}`);\n    }\n\n    yield mkdirp(dirname(destination));\n\n    try {\n      yield rename(source, destination);\n    } catch (error) {\n      if (error.code === 'EXDEV' || error.code === 'EPERM') {\n        const sourceStat = yield lstat(source);\n\n        if (sourceStat.isDirectory()) {\n          const files = yield readdir(source);\n          yield Promise.all(files.map(file => moveFile(join(source, file), join(destination, file), options, false, symlinks)));\n        } else if (sourceStat.isSymbolicLink()) {\n          symlinks.push({\n            source,\n            destination\n          });\n        } else {\n          yield copyFile(source, destination);\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    if (root) {\n      yield Promise.all(symlinks.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* ({\n          source: symSource,\n          destination: symDestination\n        }) {\n          let target = yield readlink(symSource); // junction symlinks in windows will be absolute paths, so we need to\n          // make sure they point to the symlink destination\n\n          if (isAbsolute(target)) {\n            target = resolve(symDestination, relative(symSource, target));\n          } // try to determine what the actual file is so we can create the correct\n          // type of symlink in windows\n\n\n          let targetStat = 'file';\n\n          try {\n            targetStat = yield stat(resolve(dirname(symSource), target));\n\n            if (targetStat.isDirectory()) {\n              targetStat = 'junction';\n            }\n          } catch {// targetStat remains 'file'\n          }\n\n          yield symlink(target, symDestination, targetStat);\n        });\n\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      yield rimraf(source);\n    }\n  });\n\n  return function moveFile(_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nconst moveFileSync = (source, destination, options = {}, root = true, symlinks = []) => {\n  if (!source || !destination) {\n    throw new TypeError('`source` and `destination` file required');\n  }\n\n  options = {\n    overwrite: true,\n    ...options\n  };\n\n  if (!options.overwrite && pathExistsSync(destination)) {\n    throw new Error(`The destination file exists: ${destination}`);\n  }\n\n  mkdirp.sync(dirname(destination));\n\n  try {\n    renameSync(source, destination);\n  } catch (error) {\n    if (error.code === 'EXDEV' || error.code === 'EPERM') {\n      const sourceStat = lstatSync(source);\n\n      if (sourceStat.isDirectory()) {\n        const files = readdirSync(source);\n\n        for (const file of files) {\n          moveFileSync(join(source, file), join(destination, file), options, false, symlinks);\n        }\n      } else if (sourceStat.isSymbolicLink()) {\n        symlinks.push({\n          source,\n          destination\n        });\n      } else {\n        copyFileSync(source, destination);\n      }\n    } else {\n      throw error;\n    }\n  }\n\n  if (root) {\n    for (const {\n      source: symSource,\n      destination: symDestination\n    } of symlinks) {\n      let target = readlinkSync(symSource); // junction symlinks in windows will be absolute paths, so we need to\n      // make sure they point to the symlink destination\n\n      if (isAbsolute(target)) {\n        target = resolve(symDestination, relative(symSource, target));\n      } // try to determine what the actual file is so we can create the correct\n      // type of symlink in windows\n\n\n      let targetStat = 'file';\n\n      try {\n        targetStat = statSync(resolve(dirname(symSource), target));\n\n        if (targetStat.isDirectory()) {\n          targetStat = 'junction';\n        }\n      } catch {// targetStat remains 'file'\n      }\n\n      symlinkSync(target, symDestination, targetStat);\n    }\n\n    rimrafSync(source);\n  }\n};\n\nmodule.exports = moveFile;\nmodule.exports.sync = moveFileSync;","map":null,"metadata":{},"sourceType":"script"}