{"ast":null,"code":"// put javascript in here\n'use strict';\n\nconst Parser = require('jsonparse');\n\nconst Minipass = require('minipass');\n\nclass JSONStreamError extends Error {\n  constructor(err, caller) {\n    super(err.message);\n    Error.captureStackTrace(this, caller || this.constructor);\n  }\n\n  get name() {\n    return 'JSONStreamError';\n  }\n\n  set name(n) {}\n\n}\n\nconst check = (x, y) => typeof x === 'string' ? String(y) === x : x && typeof x.test === 'function' ? x.test(y) : typeof x === 'boolean' || typeof x === 'object' ? x : typeof x === 'function' ? x(y) : false;\n\nconst _parser = Symbol('_parser');\n\nconst _onValue = Symbol('_onValue');\n\nconst _onTokenOriginal = Symbol('_onTokenOriginal');\n\nconst _onToken = Symbol('_onToken');\n\nconst _onError = Symbol('_onError');\n\nconst _count = Symbol('_count');\n\nconst _path = Symbol('_path');\n\nconst _map = Symbol('_map');\n\nconst _root = Symbol('_root');\n\nconst _header = Symbol('_header');\n\nconst _footer = Symbol('_footer');\n\nconst _setHeaderFooter = Symbol('_setHeaderFooter');\n\nconst _ending = Symbol('_ending');\n\nclass JSONStream extends Minipass {\n  constructor(opts = {}) {\n    super({ ...opts,\n      objectMode: true\n    });\n    this[_ending] = false;\n    const parser = this[_parser] = new Parser();\n\n    parser.onValue = value => this[_onValue](value);\n\n    this[_onTokenOriginal] = parser.onToken;\n\n    parser.onToken = (token, value) => this[_onToken](token, value);\n\n    parser.onError = er => this[_onError](er);\n\n    this[_count] = 0;\n    this[_path] = typeof opts.path === 'string' ? opts.path.split('.').map(e => e === '$*' ? {\n      emitKey: true\n    } : e === '*' ? true : e === '' ? {\n      recurse: true\n    } : e) : Array.isArray(opts.path) && opts.path.length ? opts.path : null;\n    this[_map] = typeof opts.map === 'function' ? opts.map : null;\n    this[_root] = null;\n    this[_header] = null;\n    this[_footer] = null;\n    this[_count] = 0;\n  }\n\n  [_setHeaderFooter](key, value) {\n    // header has not been emitted yet\n    if (this[_header] !== false) {\n      this[_header] = this[_header] || {};\n      this[_header][key] = value;\n    } // footer has not been emitted yet but header has\n\n\n    if (this[_footer] !== false && this[_header] === false) {\n      this[_footer] = this[_footer] || {};\n      this[_footer][key] = value;\n    }\n  }\n\n  [_onError](er) {\n    // error will always happen during a write() call.\n    const caller = this[_ending] ? this.end : this.write;\n    this[_ending] = false;\n    return this.emit('error', new JSONStreamError(er, caller));\n  }\n\n  [_onToken](token, value) {\n    const parser = this[_parser];\n\n    this[_onTokenOriginal].call(parser, token, value);\n\n    if (parser.stack.length === 0) {\n      if (this[_root]) {\n        const root = this[_root];\n        if (!this[_path]) super.write(root);\n        this[_root] = null;\n        this[_count] = 0;\n      }\n    }\n  }\n\n  [_onValue](value) {\n    const parser = this[_parser]; // the LAST onValue encountered is the root object.\n    // just overwrite it each time.\n\n    this[_root] = value;\n    if (!this[_path]) return;\n    let i = 0; // iterates on path\n\n    let j = 0; // iterates on stack\n\n    let emitKey = false;\n    let emitPath = false;\n\n    while (i < this[_path].length) {\n      const key = this[_path][i];\n      j++;\n\n      if (key && !key.recurse) {\n        const c = j === parser.stack.length ? parser : parser.stack[j];\n        if (!c) return;\n\n        if (!check(key, c.key)) {\n          this[_setHeaderFooter](c.key, value);\n\n          return;\n        }\n\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        if (i >= this[_path].length) return;\n        const nextKey = this[_path][i];\n        if (!nextKey) return;\n\n        while (true) {\n          const c = j === parser.stack.length ? parser : parser.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(parser.stack[j])) parser.stack[j].value = null;\n            break;\n          } else {\n            this[_setHeaderFooter](c.key, value);\n          }\n\n          j++;\n        }\n      }\n    } // emit header\n\n\n    if (this[_header]) {\n      const header = this[_header];\n      this[_header] = false;\n      this.emit('header', header);\n    }\n\n    if (j !== parser.stack.length) return;\n    this[_count]++;\n    const actualPath = parser.stack.slice(1).map(e => e.key).concat([parser.key]);\n\n    if (value !== null && value !== undefined) {\n      const data = this[_map] ? this[_map](value, actualPath) : value;\n\n      if (data !== null && data !== undefined) {\n        const emit = emitKey || emitPath ? {\n          value: data\n        } : data;\n        if (emitKey) emit.key = parser.key;\n        if (emitPath) emit.path = actualPath;\n        super.write(emit);\n      }\n    }\n\n    if (parser.value) delete parser.value[parser.key];\n\n    for (const k of parser.stack) {\n      k.value = null;\n    }\n  }\n\n  write(chunk, encoding, cb) {\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);else if (!Buffer.isBuffer(chunk)) return this.emit('error', new TypeError('Can only parse JSON from string or buffer input'));\n\n    this[_parser].write(chunk);\n\n    if (cb) cb();\n    return this.flowing;\n  }\n\n  end(chunk, encoding, cb) {\n    this[_ending] = true;\n    if (typeof encoding === 'function') cb = encoding, encoding = null;\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    const h = this[_header];\n    this[_header] = null;\n    const f = this[_footer];\n    this[_footer] = null;\n    if (h) this.emit('header', h);\n    if (f) this.emit('footer', f);\n    return super.end();\n  }\n\n  static get JSONStreamError() {\n    return JSONStreamError;\n  }\n\n  static parse(path, map) {\n    return new JSONStream({\n      path,\n      map\n    });\n  }\n\n}\n\nmodule.exports = JSONStream;","map":null,"metadata":{},"sourceType":"script"}