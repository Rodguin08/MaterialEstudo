{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyTemplates = exports.template = exports.renameTemplateFiles = exports.pathTemplate = exports.applyPathTemplate = exports.contentTemplate = exports.applyContentTemplate = exports.InvalidPipeException = exports.UnknownPipeException = exports.OptionIsNotDefinedException = exports.TEMPLATE_FILENAME_RE = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst util_1 = require(\"util\");\n\nconst base_1 = require(\"./base\");\n\nconst rename_1 = require(\"./rename\");\n\nexports.TEMPLATE_FILENAME_RE = /\\.template$/;\n\nclass OptionIsNotDefinedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Option \"${name}\" is not defined.`);\n  }\n\n}\n\nexports.OptionIsNotDefinedException = OptionIsNotDefinedException;\n\nclass UnknownPipeException extends core_1.BaseException {\n  constructor(name) {\n    super(`Pipe \"${name}\" is not defined.`);\n  }\n\n}\n\nexports.UnknownPipeException = UnknownPipeException;\n\nclass InvalidPipeException extends core_1.BaseException {\n  constructor(name) {\n    super(`Pipe \"${name}\" is invalid.`);\n  }\n\n}\n\nexports.InvalidPipeException = InvalidPipeException;\nconst decoder = new util_1.TextDecoder('utf-8', {\n  fatal: true\n});\n\nfunction applyContentTemplate(options) {\n  return entry => {\n    const {\n      path,\n      content\n    } = entry;\n\n    try {\n      const decodedContent = decoder.decode(content);\n      return {\n        path,\n        content: Buffer.from((0, core_1.template)(decodedContent, {})(options))\n      };\n    } catch (e) {\n      if (e.code === 'ERR_ENCODING_INVALID_ENCODED_DATA') {\n        return entry;\n      }\n\n      throw e;\n    }\n  };\n}\n\nexports.applyContentTemplate = applyContentTemplate;\n\nfunction contentTemplate(options) {\n  return (0, base_1.forEach)(applyContentTemplate(options));\n}\n\nexports.contentTemplate = contentTemplate;\n\nfunction applyPathTemplate(data, options = {\n  interpolationStart: '__',\n  interpolationEnd: '__',\n  pipeSeparator: '@'\n}) {\n  const is = options.interpolationStart;\n  const ie = options.interpolationEnd;\n  const isL = is.length;\n  const ieL = ie.length;\n  return entry => {\n    let path = entry.path;\n    const content = entry.content;\n    const original = path;\n    let start = path.indexOf(is); // + 1 to have at least a length 1 name. `____` is not valid.\n\n    let end = path.indexOf(ie, start + isL + 1);\n\n    while (start != -1 && end != -1) {\n      const match = path.substring(start + isL, end);\n      let replacement = data[match];\n\n      if (!options.pipeSeparator) {\n        if (typeof replacement == 'function') {\n          replacement = replacement.call(data, original);\n        }\n\n        if (replacement === undefined) {\n          throw new OptionIsNotDefinedException(match);\n        }\n      } else {\n        const [name, ...pipes] = match.split(options.pipeSeparator);\n        replacement = data[name];\n\n        if (typeof replacement == 'function') {\n          replacement = replacement.call(data, original);\n        }\n\n        if (replacement === undefined) {\n          throw new OptionIsNotDefinedException(name);\n        }\n\n        replacement = pipes.reduce((acc, pipe) => {\n          if (!pipe) {\n            return acc;\n          }\n\n          if (!(pipe in data)) {\n            throw new UnknownPipeException(pipe);\n          }\n\n          if (typeof data[pipe] != 'function') {\n            throw new InvalidPipeException(pipe);\n          } // Coerce to string.\n\n\n          return '' + data[pipe](acc);\n        }, '' + replacement);\n      }\n\n      path = path.substring(0, start) + replacement + path.substring(end + ieL);\n      start = path.indexOf(options.interpolationStart); // See above.\n\n      end = path.indexOf(options.interpolationEnd, start + isL + 1);\n    }\n\n    return {\n      path: (0, core_1.normalize)(path),\n      content\n    };\n  };\n}\n\nexports.applyPathTemplate = applyPathTemplate;\n\nfunction pathTemplate(options) {\n  return (0, base_1.forEach)(applyPathTemplate(options));\n}\n\nexports.pathTemplate = pathTemplate;\n/**\n * Remove every `.template` suffix from file names.\n */\n\nfunction renameTemplateFiles() {\n  return (0, rename_1.rename)(path => !!path.match(exports.TEMPLATE_FILENAME_RE), path => path.replace(exports.TEMPLATE_FILENAME_RE, ''));\n}\n\nexports.renameTemplateFiles = renameTemplateFiles;\n\nfunction template(options) {\n  return (0, base_1.chain)([contentTemplate(options), // Force cast to PathTemplateData. We need the type for the actual pathTemplate() call,\n  // but in this case we cannot do anything as contentTemplate are more permissive.\n  // Since values are coerced to strings in PathTemplates it will be fine in the end.\n  pathTemplate(options)]);\n}\n\nexports.template = template;\n\nfunction applyTemplates(options) {\n  return (0, base_1.forEach)((0, base_1.when)(path => path.endsWith('.template'), (0, base_1.composeFileOperators)([applyContentTemplate(options), // See above for this weird cast.\n  applyPathTemplate(options), entry => {\n    return {\n      content: entry.content,\n      path: entry.path.replace(exports.TEMPLATE_FILENAME_RE, '')\n    };\n  }])));\n}\n\nexports.applyTemplates = applyTemplates;","map":null,"metadata":{},"sourceType":"script"}