{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('graceful-fs');\n\nconst os = require('os');\n\nconst tar = require('tar');\n\nconst path = require('path');\n\nconst util = require('util');\n\nconst stream = require('stream');\n\nconst crypto = require('crypto');\n\nconst log = require('npmlog');\n\nconst semver = require('semver');\n\nconst fetch = require('make-fetch-happen');\n\nconst processRelease = require('./process-release');\n\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\n\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release); // Determine which node dev files version we are installing\n\n    log.verbose('install', 'input version string %j', release.version);\n\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    } // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n\n\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    } // flatten version into String\n\n\n    log.verbose('install', 'installing version: %s', release.versionDir); // the directory where the dev files will be installed\n\n    const devDir = path.resolve(gyp.devDir, release.versionDir); // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n\n        throw err;\n      }\n\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n\n      log.verbose('install', 'version is good');\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n\n\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring nodedir is created', devDir); // first create the dir for the node dev files\n\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n\n          if (created) {\n            log.verbose('created nodedir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n\n          throw err;\n        } // now download the node tarball\n\n\n        const tarPath = gyp.opts.tarball;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {}; // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n\n        function isValid(path) {\n          const isValid = valid(path);\n\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n\n          return isValid;\n        } // download the tarball and extract!\n\n\n        if (tarPath) {\n          yield tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            cwd: devDir\n          });\n        } else {\n          try {\n            const res = yield download(gyp, release.tarballUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n            }\n\n            yield streamPipeline(res.body, // content checksum\n            new ShaSum((_, checksum) => {\n              const filename = path.basename(release.tarballUrl).trim();\n              contentShasums[filename] = checksum;\n              log.verbose('content checksum', filename, checksum);\n            }), tar.extract({\n              strip: 1,\n              cwd: devDir,\n              filter: isValid\n            }));\n          } catch (err) {\n            // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n            }\n\n            throw err;\n          }\n        } // invoked after the tarball has finished being extracted\n\n\n        if (extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball');\n        }\n\n        log.verbose('tarball', 'done parsing tarball');\n        const installVersionPath = path.resolve(devDir, 'installVersion');\n        yield Promise.all([// need to download node.lib\n        ...(win ? downloadNodeLib() : []), // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'), // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])]);\n        log.verbose('download contents checksum', JSON.stringify(contentShasums)); // check content shasums\n\n        for (const k in contentShasums) {\n          log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n\n          if (contentShasums[k] !== expectShasums[k]) {\n            throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n          }\n        }\n\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n\n              if (items.length !== 2) {\n                return;\n              } // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n\n\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n\n        function downloadNodeLib() {\n          log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n          const archs = ['ia32', 'x64', 'arm64'];\n          return archs.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (arch) {\n              const dir = path.resolve(devDir, arch);\n              const targetLibPath = path.resolve(dir, release.name + '.lib');\n              const {\n                libUrl,\n                libPath\n              } = release[arch];\n              const name = `${arch} ${release.name}.lib`;\n              log.verbose(name, 'dir', dir);\n              log.verbose(name, 'url', libUrl);\n              yield fs.promises.mkdir(dir, {\n                recursive: true\n              });\n              log.verbose('streaming', name, 'to:', targetLibPath);\n              const res = yield download(gyp, libUrl);\n\n              if (res.status === 403 || res.status === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n\n                return;\n              } else if (res.status !== 200) {\n                throw new Error(`${res.status} status code downloading ${name}`);\n              }\n\n              return streamPipeline(res.body, new ShaSum((_, checksum) => {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              }), fs.createWriteStream(targetLibPath));\n            });\n\n            return function (_x9) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        } // downloadNodeLib()\n\n      });\n      return _go.apply(this, arguments);\n    }\n\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n\n    function rollback(_x7) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n\n\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install'); // roll-back the install if anything went wrong\n\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n\n    function eaccesFallback(_x8) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\n\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n\n    callback(null, chunk);\n  }\n\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n\n    callback();\n  }\n\n}\n\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\n\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\n\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\n\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\n\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":null,"metadata":{},"sourceType":"script"}