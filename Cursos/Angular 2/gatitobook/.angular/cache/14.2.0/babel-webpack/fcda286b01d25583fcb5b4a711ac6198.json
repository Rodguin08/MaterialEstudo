{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseWorkflow = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst engine_1 = require(\"../engine\");\n\nconst exception_1 = require(\"../exception/exception\");\n\nconst formats_1 = require(\"../formats\");\n\nconst dryrun_1 = require(\"../sink/dryrun\");\n\nconst host_1 = require(\"../sink/host\");\n\nconst host_tree_1 = require(\"../tree/host-tree\");\n/**\n * Base class for workflows. Even without abstract methods, this class should not be used without\n * surrounding some initialization for the registry and host. This class only adds life cycle and\n * dryrun/force support. You need to provide any registry and task executors that you need to\n * support.\n * See {@see NodeWorkflow} implementation for how to make a specialized subclass of this.\n * TODO: add default set of CoreSchemaRegistry transforms. Once the job refactor is done, use that\n *       as the support for tasks.\n *\n * @public\n */\n\n\nclass BaseWorkflow {\n  constructor(options) {\n    this._reporter = new rxjs_1.Subject();\n    this._lifeCycle = new rxjs_1.Subject();\n    this._host = options.host;\n    this._engineHost = options.engineHost;\n\n    if (options.registry) {\n      this._registry = options.registry;\n    } else {\n      this._registry = new core_1.schema.CoreSchemaRegistry(formats_1.standardFormats);\n\n      this._registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);\n    }\n\n    this._engine = new engine_1.SchematicEngine(this._engineHost, this);\n    this._context = [];\n    this._force = options.force || false;\n    this._dryRun = options.dryRun || false;\n  }\n\n  get context() {\n    const maybeContext = this._context[this._context.length - 1];\n\n    if (!maybeContext) {\n      throw new Error('Cannot get context when workflow is not executing...');\n    }\n\n    return maybeContext;\n  }\n\n  get engine() {\n    return this._engine;\n  }\n\n  get engineHost() {\n    return this._engineHost;\n  }\n\n  get registry() {\n    return this._registry;\n  }\n\n  get reporter() {\n    return this._reporter.asObservable();\n  }\n\n  get lifeCycle() {\n    return this._lifeCycle.asObservable();\n  }\n\n  _createSinks() {\n    let error = false;\n    const dryRunSink = new dryrun_1.DryRunSink(this._host, this._force);\n    const dryRunSubscriber = dryRunSink.reporter.subscribe(event => {\n      this._reporter.next(event);\n\n      error = error || event.kind == 'error';\n    }); // We need two sinks if we want to output what will happen, and actually do the work.\n\n    return [dryRunSink, // Add a custom sink that clean ourselves and throws an error if an error happened.\n    {\n      commit() {\n        dryRunSubscriber.unsubscribe();\n\n        if (error) {\n          return (0, rxjs_1.throwError)(new exception_1.UnsuccessfulWorkflowExecution());\n        }\n\n        return (0, rxjs_1.of)();\n      }\n\n    }, // Only add a HostSink if this is not a dryRun.\n    ...(!this._dryRun ? [new host_1.HostSink(this._host, this._force)] : [])];\n  }\n\n  execute(options) {\n    const parentContext = this._context[this._context.length - 1];\n\n    if (!parentContext) {\n      this._lifeCycle.next({\n        kind: 'start'\n      });\n    }\n    /** Create the collection and the schematic. */\n\n\n    const collection = this._engine.createCollection(options.collection); // Only allow private schematics if called from the same collection.\n\n\n    const allowPrivate = options.allowPrivate || parentContext && parentContext.collection === options.collection;\n    const schematic = collection.createSchematic(options.schematic, allowPrivate);\n\n    const sinks = this._createSinks();\n\n    this._lifeCycle.next({\n      kind: 'workflow-start'\n    });\n\n    const context = { ...options,\n      debug: options.debug || false,\n      logger: options.logger || parentContext && parentContext.logger || new core_1.logging.NullLogger(),\n      parentContext\n    };\n\n    this._context.push(context);\n\n    return schematic.call(options.options, (0, rxjs_1.of)(new host_tree_1.HostTree(this._host)), {\n      logger: context.logger\n    }).pipe((0, operators_1.concatMap)(tree => {\n      // Process all sinks.\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(sinks).pipe((0, operators_1.concatMap)(sink => sink.commit(tree)), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(tree));\n    }), (0, operators_1.concatMap)(() => {\n      if (this._dryRun) {\n        return rxjs_1.EMPTY;\n      }\n\n      this._lifeCycle.next({\n        kind: 'post-tasks-start'\n      });\n\n      return this._engine.executePostTasks().pipe((0, operators_1.tap)({\n        complete: () => this._lifeCycle.next({\n          kind: 'post-tasks-end'\n        })\n      }), (0, operators_1.defaultIfEmpty)(), (0, operators_1.last)());\n    }), (0, operators_1.tap)({\n      complete: () => {\n        this._lifeCycle.next({\n          kind: 'workflow-end'\n        });\n\n        this._context.pop();\n\n        if (this._context.length == 0) {\n          this._lifeCycle.next({\n            kind: 'end'\n          });\n        }\n      }\n    }));\n  }\n\n}\n\nexports.BaseWorkflow = BaseWorkflow;","map":null,"metadata":{},"sourceType":"script"}