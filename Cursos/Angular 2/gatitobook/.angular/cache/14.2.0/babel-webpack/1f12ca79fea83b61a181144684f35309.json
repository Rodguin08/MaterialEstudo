{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSystemPath = exports.asPosixPath = exports.asWindowsPath = exports.path = exports.noCacheNormalize = exports.normalize = exports.resetNormalizeCache = exports.fragment = exports.resolve = exports.relative = exports.isAbsolute = exports.join = exports.dirname = exports.basename = exports.extname = exports.split = exports.NormalizedRoot = exports.NormalizedSep = exports.PathCannotBeFragmentException = exports.PathMustBeAbsoluteException = exports.InvalidPathException = void 0;\n\nconst exception_1 = require(\"../exception\");\n\nclass InvalidPathException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} is invalid.`);\n  }\n\n}\n\nexports.InvalidPathException = InvalidPathException;\n\nclass PathMustBeAbsoluteException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} must be absolute.`);\n  }\n\n}\n\nexports.PathMustBeAbsoluteException = PathMustBeAbsoluteException;\n\nclass PathCannotBeFragmentException extends exception_1.BaseException {\n  constructor(path) {\n    super(`Path ${JSON.stringify(path)} cannot be made a fragment.`);\n  }\n\n}\n\nexports.PathCannotBeFragmentException = PathCannotBeFragmentException;\n/**\n * The Separator for normalized path.\n * @type {Path}\n */\n\nexports.NormalizedSep = '/';\n/**\n * The root of a normalized path.\n * @type {Path}\n */\n\nexports.NormalizedRoot = exports.NormalizedSep;\n/**\n * Split a path into multiple path fragments. Each fragments except the last one will end with\n * a path separator.\n * @param {Path} path The path to split.\n * @returns {Path[]} An array of path fragments.\n */\n\nfunction split(path) {\n  const fragments = path.split(exports.NormalizedSep).map(x => fragment(x));\n\n  if (fragments[fragments.length - 1].length === 0) {\n    fragments.pop();\n  }\n\n  return fragments;\n}\n\nexports.split = split;\n/**\n *\n */\n\nfunction extname(path) {\n  const base = basename(path);\n  const i = base.lastIndexOf('.');\n\n  if (i < 1) {\n    return '';\n  } else {\n    return base.slice(i);\n  }\n}\n\nexports.extname = extname;\n/**\n * Return the basename of the path, as a Path. See path.basename\n */\n\nfunction basename(path) {\n  const i = path.lastIndexOf(exports.NormalizedSep);\n\n  if (i == -1) {\n    return fragment(path);\n  } else {\n    return fragment(path.slice(path.lastIndexOf(exports.NormalizedSep) + 1));\n  }\n}\n\nexports.basename = basename;\n/**\n * Return the dirname of the path, as a Path. See path.dirname\n */\n\nfunction dirname(path) {\n  const index = path.lastIndexOf(exports.NormalizedSep);\n\n  if (index === -1) {\n    return '';\n  }\n\n  const endIndex = index === 0 ? 1 : index; // case of file under root: '/file'\n\n  return normalize(path.slice(0, endIndex));\n}\n\nexports.dirname = dirname;\n/**\n * Join multiple paths together, and normalize the result. Accepts strings that will be\n * normalized as well (but the original must be a path).\n */\n\nfunction join(p1, ...others) {\n  if (others.length > 0) {\n    return normalize((p1 ? p1 + exports.NormalizedSep : '') + others.join(exports.NormalizedSep));\n  } else {\n    return p1;\n  }\n}\n\nexports.join = join;\n/**\n * Returns true if a path is absolute.\n */\n\nfunction isAbsolute(p) {\n  return p.startsWith(exports.NormalizedSep);\n}\n\nexports.isAbsolute = isAbsolute;\n/**\n * Returns a path such that `join(from, relative(from, to)) == to`.\n * Both paths must be absolute, otherwise it does not make much sense.\n */\n\nfunction relative(from, to) {\n  if (!isAbsolute(from)) {\n    throw new PathMustBeAbsoluteException(from);\n  }\n\n  if (!isAbsolute(to)) {\n    throw new PathMustBeAbsoluteException(to);\n  }\n\n  let p;\n\n  if (from == to) {\n    p = '';\n  } else {\n    const splitFrom = split(from);\n    const splitTo = split(to);\n\n    while (splitFrom.length > 0 && splitTo.length > 0 && splitFrom[0] == splitTo[0]) {\n      splitFrom.shift();\n      splitTo.shift();\n    }\n\n    if (splitFrom.length == 0) {\n      p = splitTo.join(exports.NormalizedSep);\n    } else {\n      p = splitFrom.map(() => '..').concat(splitTo).join(exports.NormalizedSep);\n    }\n  }\n\n  return normalize(p);\n}\n\nexports.relative = relative;\n/**\n * Returns a Path that is the resolution of p2, from p1. If p2 is absolute, it will return p2,\n * otherwise will join both p1 and p2.\n */\n\nfunction resolve(p1, p2) {\n  if (isAbsolute(p2)) {\n    return p2;\n  } else {\n    return join(p1, p2);\n  }\n}\n\nexports.resolve = resolve;\n\nfunction fragment(path) {\n  if (path.indexOf(exports.NormalizedSep) != -1) {\n    throw new PathCannotBeFragmentException(path);\n  }\n\n  return path;\n}\n\nexports.fragment = fragment;\n/**\n * normalize() cache to reduce computation. For now this grows and we never flush it, but in the\n * future we might want to add a few cache flush to prevent this from growing too large.\n */\n\nlet normalizedCache = new Map();\n/**\n * Reset the cache. This is only useful for testing.\n * @private\n */\n\nfunction resetNormalizeCache() {\n  normalizedCache = new Map();\n}\n\nexports.resetNormalizeCache = resetNormalizeCache;\n/**\n * Normalize a string into a Path. This is the only mean to get a Path type from a string that\n * represents a system path. This method cache the results as real world paths tend to be\n * duplicated often.\n * Normalization includes:\n *   - Windows backslashes `\\\\` are replaced with `/`.\n *   - Windows drivers are replaced with `/X/`, where X is the drive letter.\n *   - Absolute paths starts with `/`.\n *   - Multiple `/` are replaced by a single one.\n *   - Path segments `.` are removed.\n *   - Path segments `..` are resolved.\n *   - If a path is absolute, having a `..` at the start is invalid (and will throw).\n * @param path The path to be normalized.\n */\n\nfunction normalize(path) {\n  let maybePath = normalizedCache.get(path);\n\n  if (!maybePath) {\n    maybePath = noCacheNormalize(path);\n    normalizedCache.set(path, maybePath);\n  }\n\n  return maybePath;\n}\n\nexports.normalize = normalize;\n/**\n * The no cache version of the normalize() function. Used for benchmarking and testing.\n */\n\nfunction noCacheNormalize(path) {\n  if (path == '' || path == '.') {\n    return '';\n  } else if (path == exports.NormalizedRoot) {\n    return exports.NormalizedRoot;\n  } // Match absolute windows path.\n\n\n  const original = path;\n\n  if (path.match(/^[A-Z]:[/\\\\]/i)) {\n    path = '\\\\' + path[0] + '\\\\' + path.slice(3);\n  } // We convert Windows paths as well here.\n\n\n  const p = path.split(/[/\\\\]/g);\n  let relative = false;\n  let i = 1; // Special case the first one.\n\n  if (p[0] != '') {\n    p.unshift('.');\n    relative = true;\n  }\n\n  while (i < p.length) {\n    if (p[i] == '.') {\n      p.splice(i, 1);\n    } else if (p[i] == '..') {\n      if (i < 2 && !relative) {\n        throw new InvalidPathException(original);\n      } else if (i >= 2 && p[i - 1] != '..') {\n        p.splice(i - 1, 2);\n        i--;\n      } else {\n        i++;\n      }\n    } else if (p[i] == '') {\n      p.splice(i, 1);\n    } else {\n      i++;\n    }\n  }\n\n  if (p.length == 1) {\n    return p[0] == '' ? exports.NormalizedSep : '';\n  } else {\n    if (p[0] == '.') {\n      p.shift();\n    }\n\n    return p.join(exports.NormalizedSep);\n  }\n}\n\nexports.noCacheNormalize = noCacheNormalize;\n\nconst path = (strings, ...values) => {\n  return normalize(String.raw(strings, ...values));\n};\n\nexports.path = path;\n\nfunction asWindowsPath(path) {\n  const drive = path.match(/^\\/(\\w)(?:\\/(.*))?$/);\n\n  if (drive) {\n    const subPath = drive[2] ? drive[2].replace(/\\//g, '\\\\') : '';\n    return `${drive[1]}:\\\\${subPath}`;\n  }\n\n  return path.replace(/\\//g, '\\\\');\n}\n\nexports.asWindowsPath = asWindowsPath;\n\nfunction asPosixPath(path) {\n  return path;\n}\n\nexports.asPosixPath = asPosixPath;\n\nfunction getSystemPath(path) {\n  if (process.platform.startsWith('win32')) {\n    return asWindowsPath(path);\n  } else {\n    return asPosixPath(path);\n  }\n}\n\nexports.getSystemPath = getSystemPath;","map":null,"metadata":{},"sourceType":"script"}