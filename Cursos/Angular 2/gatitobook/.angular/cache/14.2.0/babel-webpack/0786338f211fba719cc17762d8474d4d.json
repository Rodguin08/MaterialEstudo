{"ast":null,"code":"'use strict';\n\nconst Minipass = require('minipass');\n\nconst TYPE = Symbol('type');\nconst BUFFER = Symbol('buffer');\n\nclass Blob {\n  constructor(blobParts, options) {\n    this[TYPE] = '';\n    const buffers = [];\n    let size = 0;\n\n    if (blobParts) {\n      const a = blobParts;\n      const length = Number(a.length);\n\n      for (let i = 0; i < length; i++) {\n        const element = a[i];\n        const buffer = element instanceof Buffer ? element : ArrayBuffer.isView(element) ? Buffer.from(element.buffer, element.byteOffset, element.byteLength) : element instanceof ArrayBuffer ? Buffer.from(element) : element instanceof Blob ? element[BUFFER] : typeof element === 'string' ? Buffer.from(element) : Buffer.from(String(element));\n        size += buffer.length;\n        buffers.push(buffer);\n      }\n    }\n\n    this[BUFFER] = Buffer.concat(buffers, size);\n    const type = options && options.type !== undefined && String(options.type).toLowerCase();\n\n    if (type && !/[^\\u0020-\\u007E]/.test(type)) {\n      this[TYPE] = type;\n    }\n  }\n\n  get size() {\n    return this[BUFFER].length;\n  }\n\n  get type() {\n    return this[TYPE];\n  }\n\n  text() {\n    return Promise.resolve(this[BUFFER].toString());\n  }\n\n  arrayBuffer() {\n    const buf = this[BUFFER];\n    const off = buf.byteOffset;\n    const len = buf.byteLength;\n    const ab = buf.buffer.slice(off, off + len);\n    return Promise.resolve(ab);\n  }\n\n  stream() {\n    return new Minipass().end(this[BUFFER]);\n  }\n\n  slice(start, end, type) {\n    const size = this.size;\n    const relativeStart = start === undefined ? 0 : start < 0 ? Math.max(size + start, 0) : Math.min(start, size);\n    const relativeEnd = end === undefined ? size : end < 0 ? Math.max(size + end, 0) : Math.min(end, size);\n    const span = Math.max(relativeEnd - relativeStart, 0);\n    const buffer = this[BUFFER];\n    const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n    const blob = new Blob([], {\n      type\n    });\n    blob[BUFFER] = slicedBuffer;\n    return blob;\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Blob';\n  }\n\n  static get BUFFER() {\n    return BUFFER;\n  }\n\n}\n\nObject.defineProperties(Blob.prototype, {\n  size: {\n    enumerable: true\n  },\n  type: {\n    enumerable: true\n  }\n});\nmodule.exports = Blob;","map":null,"metadata":{},"sourceType":"script"}