{"ast":null,"code":"const {\n  hasOwnProperty\n} = Object.prototype;\n/* istanbul ignore next */\n\nconst eol = typeof process !== 'undefined' && process.platform === 'win32' ? '\\r\\n' : '\\n';\n\nconst encode = (obj, opt) => {\n  const children = [];\n  let out = '';\n\n  if (typeof opt === 'string') {\n    opt = {\n      section: opt,\n      whitespace: false\n    };\n  } else {\n    opt = opt || Object.create(null);\n    opt.whitespace = opt.whitespace === true;\n  }\n\n  const separator = opt.whitespace ? ' = ' : '=';\n\n  for (const k of Object.keys(obj)) {\n    const val = obj[k];\n\n    if (val && Array.isArray(val)) {\n      for (const item of val) {\n        out += safe(k + '[]') + separator + safe(item) + eol;\n      }\n    } else if (val && typeof val === 'object') {\n      children.push(k);\n    } else {\n      out += safe(k) + separator + safe(val) + eol;\n    }\n  }\n\n  if (opt.section && out.length) {\n    out = '[' + safe(opt.section) + ']' + eol + out;\n  }\n\n  for (const k of children) {\n    const nk = dotSplit(k).join('\\\\.');\n    const section = (opt.section ? opt.section + '.' : '') + nk;\n    const {\n      whitespace\n    } = opt;\n    const child = encode(obj[k], {\n      section,\n      whitespace\n    });\n\n    if (out.length && child.length) {\n      out += eol;\n    }\n\n    out += child;\n  }\n\n  return out;\n};\n\nconst dotSplit = str => str.replace(/\\1/g, '\\u0002LITERAL\\\\1LITERAL\\u0002').replace(/\\\\\\./g, '\\u0001').split(/\\./).map(part => part.replace(/\\1/g, '\\\\.').replace(/\\2LITERAL\\\\1LITERAL\\2/g, '\\u0001'));\n\nconst decode = str => {\n  const out = Object.create(null);\n  let p = out;\n  let section = null; //          section     |key      = value\n\n  const re = /^\\[([^\\]]*)\\]$|^([^=]+)(=(.*))?$/i;\n  const lines = str.split(/[\\r\\n]+/g);\n\n  for (const line of lines) {\n    if (!line || line.match(/^\\s*[;#]/)) {\n      continue;\n    }\n\n    const match = line.match(re);\n\n    if (!match) {\n      continue;\n    }\n\n    if (match[1] !== undefined) {\n      section = unsafe(match[1]);\n\n      if (section === '__proto__') {\n        // not allowed\n        // keep parsing the section, but don't attach it.\n        p = Object.create(null);\n        continue;\n      }\n\n      p = out[section] = out[section] || Object.create(null);\n      continue;\n    }\n\n    const keyRaw = unsafe(match[2]);\n    const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === '[]';\n    const key = isArray ? keyRaw.slice(0, -2) : keyRaw;\n\n    if (key === '__proto__') {\n      continue;\n    }\n\n    const valueRaw = match[3] ? unsafe(match[4]) : true;\n    const value = valueRaw === 'true' || valueRaw === 'false' || valueRaw === 'null' ? JSON.parse(valueRaw) : valueRaw; // Convert keys with '[]' suffix to an array\n\n    if (isArray) {\n      if (!hasOwnProperty.call(p, key)) {\n        p[key] = [];\n      } else if (!Array.isArray(p[key])) {\n        p[key] = [p[key]];\n      }\n    } // safeguard against resetting a previously defined\n    // array by accidentally forgetting the brackets\n\n\n    if (Array.isArray(p[key])) {\n      p[key].push(value);\n    } else {\n      p[key] = value;\n    }\n  } // {a:{y:1},\"a.b\":{x:2}} --> {a:{y:1,b:{x:2}}}\n  // use a filter to return the keys that have to be deleted.\n\n\n  const remove = [];\n\n  for (const k of Object.keys(out)) {\n    if (!hasOwnProperty.call(out, k) || typeof out[k] !== 'object' || Array.isArray(out[k])) {\n      continue;\n    } // see if the parent section is also an object.\n    // if so, add it to that, and mark this one for deletion\n\n\n    const parts = dotSplit(k);\n    p = out;\n    const l = parts.pop();\n    const nl = l.replace(/\\\\\\./g, '.');\n\n    for (const part of parts) {\n      if (part === '__proto__') {\n        continue;\n      }\n\n      if (!hasOwnProperty.call(p, part) || typeof p[part] !== 'object') {\n        p[part] = Object.create(null);\n      }\n\n      p = p[part];\n    }\n\n    if (p === out && nl === l) {\n      continue;\n    }\n\n    p[nl] = out[k];\n    remove.push(k);\n  }\n\n  for (const del of remove) {\n    delete out[del];\n  }\n\n  return out;\n};\n\nconst isQuoted = val => {\n  return val.startsWith('\"') && val.endsWith('\"') || val.startsWith(\"'\") && val.endsWith(\"'\");\n};\n\nconst safe = val => {\n  if (typeof val !== 'string' || val.match(/[=\\r\\n]/) || val.match(/^\\[/) || val.length > 1 && isQuoted(val) || val !== val.trim()) {\n    return JSON.stringify(val);\n  }\n\n  return val.split(';').join('\\\\;').split('#').join('\\\\#');\n};\n\nconst unsafe = (val, doUnesc) => {\n  val = (val || '').trim();\n\n  if (isQuoted(val)) {\n    // remove the single quotes before calling JSON.parse\n    if (val.charAt(0) === \"'\") {\n      val = val.slice(1, -1);\n    }\n\n    try {\n      val = JSON.parse(val);\n    } catch (_) {}\n  } else {\n    // walk the val to find the first not-escaped ; character\n    let esc = false;\n    let unesc = '';\n\n    for (let i = 0, l = val.length; i < l; i++) {\n      const c = val.charAt(i);\n\n      if (esc) {\n        if ('\\\\;#'.indexOf(c) !== -1) {\n          unesc += c;\n        } else {\n          unesc += '\\\\' + c;\n        }\n\n        esc = false;\n      } else if (';#'.indexOf(c) !== -1) {\n        break;\n      } else if (c === '\\\\') {\n        esc = true;\n      } else {\n        unesc += c;\n      }\n    }\n\n    if (esc) {\n      unesc += '\\\\';\n    }\n\n    return unesc.trim();\n  }\n\n  return val;\n};\n\nmodule.exports = {\n  parse: decode,\n  decode,\n  stringify: encode,\n  encode,\n  safe,\n  unsafe\n};","map":null,"metadata":{},"sourceType":"script"}