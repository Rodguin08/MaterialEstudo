{"ast":null,"code":"'use strict';\n\nconst url = require('url');\n\nconst gitHosts = require('./git-host-info.js');\n\nconst GitHost = module.exports = require('./git-host.js');\n\nconst LRU = require('lru-cache');\n\nconst cache = new LRU({\n  max: 1000\n});\nconst protocolToRepresentationMap = {\n  'git+ssh:': 'sshurl',\n  'git+https:': 'https',\n  'ssh:': 'sshurl',\n  'git:': 'git'\n};\n\nfunction protocolToRepresentation(protocol) {\n  return protocolToRepresentationMap[protocol] || protocol.slice(0, -1);\n}\n\nconst authProtocols = {\n  'git:': true,\n  'https:': true,\n  'git+https:': true,\n  'http:': true,\n  'git+http:': true\n};\nconst knownProtocols = Object.keys(gitHosts.byShortcut).concat(['http:', 'https:', 'git:', 'git+ssh:', 'git+https:', 'ssh:']);\n\nmodule.exports.fromUrl = function (giturl, opts) {\n  if (typeof giturl !== 'string') {\n    return;\n  }\n\n  const key = giturl + JSON.stringify(opts || {});\n\n  if (!cache.has(key)) {\n    cache.set(key, fromUrl(giturl, opts));\n  }\n\n  return cache.get(key);\n};\n\nfunction fromUrl(giturl, opts) {\n  if (!giturl) {\n    return;\n  }\n\n  const correctedUrl = isGitHubShorthand(giturl) ? 'github:' + giturl : correctProtocol(giturl);\n  const parsed = parseGitUrl(correctedUrl);\n\n  if (!parsed) {\n    return parsed;\n  }\n\n  const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];\n  const gitHostDomain = gitHosts.byDomain[parsed.hostname.startsWith('www.') ? parsed.hostname.slice(4) : parsed.hostname];\n  const gitHostName = gitHostShortcut || gitHostDomain;\n\n  if (!gitHostName) {\n    return;\n  }\n\n  const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];\n  let auth = null;\n\n  if (authProtocols[parsed.protocol] && (parsed.username || parsed.password)) {\n    auth = `${parsed.username}${parsed.password ? ':' + parsed.password : ''}`;\n  }\n\n  let committish = null;\n  let user = null;\n  let project = null;\n  let defaultRepresentation = null;\n\n  try {\n    if (gitHostShortcut) {\n      let pathname = parsed.pathname.startsWith('/') ? parsed.pathname.slice(1) : parsed.pathname;\n      const firstAt = pathname.indexOf('@'); // we ignore auth for shortcuts, so just trim it out\n\n      if (firstAt > -1) {\n        pathname = pathname.slice(firstAt + 1);\n      }\n\n      const lastSlash = pathname.lastIndexOf('/');\n\n      if (lastSlash > -1) {\n        user = decodeURIComponent(pathname.slice(0, lastSlash)); // we want nulls only, never empty strings\n\n        if (!user) {\n          user = null;\n        }\n\n        project = decodeURIComponent(pathname.slice(lastSlash + 1));\n      } else {\n        project = decodeURIComponent(pathname);\n      }\n\n      if (project.endsWith('.git')) {\n        project = project.slice(0, -4);\n      }\n\n      if (parsed.hash) {\n        committish = decodeURIComponent(parsed.hash.slice(1));\n      }\n\n      defaultRepresentation = 'shortcut';\n    } else {\n      if (!gitHostInfo.protocols.includes(parsed.protocol)) {\n        return;\n      }\n\n      const segments = gitHostInfo.extract(parsed);\n\n      if (!segments) {\n        return;\n      }\n\n      user = segments.user && decodeURIComponent(segments.user);\n      project = decodeURIComponent(segments.project);\n      committish = decodeURIComponent(segments.committish);\n      defaultRepresentation = protocolToRepresentation(parsed.protocol);\n    }\n  } catch (err) {\n    /* istanbul ignore else */\n    if (err instanceof URIError) {\n      return;\n    } else {\n      throw err;\n    }\n  }\n\n  return new GitHost(gitHostName, user, auth, project, committish, defaultRepresentation, opts);\n} // accepts input like git:github.com:user/repo and inserts the // after the first :\n\n\nconst correctProtocol = arg => {\n  const firstColon = arg.indexOf(':');\n  const proto = arg.slice(0, firstColon + 1);\n\n  if (knownProtocols.includes(proto)) {\n    return arg;\n  }\n\n  const firstAt = arg.indexOf('@');\n\n  if (firstAt > -1) {\n    if (firstAt > firstColon) {\n      return `git+ssh://${arg}`;\n    } else {\n      return arg;\n    }\n  }\n\n  const doubleSlash = arg.indexOf('//');\n\n  if (doubleSlash === firstColon + 1) {\n    return arg;\n  }\n\n  return arg.slice(0, firstColon + 1) + '//' + arg.slice(firstColon + 1);\n}; // look for github shorthand inputs, such as npm/cli\n\n\nconst isGitHubShorthand = arg => {\n  // it cannot contain whitespace before the first #\n  // it cannot start with a / because that's probably an absolute file path\n  // but it must include a slash since repos are username/repository\n  // it cannot start with a . because that's probably a relative file path\n  // it cannot start with an @ because that's a scoped package if it passes the other tests\n  // it cannot contain a : before a # because that tells us that there's a protocol\n  // a second / may not exist before a #\n  const firstHash = arg.indexOf('#');\n  const firstSlash = arg.indexOf('/');\n  const secondSlash = arg.indexOf('/', firstSlash + 1);\n  const firstColon = arg.indexOf(':');\n  const firstSpace = /\\s/.exec(arg);\n  const firstAt = arg.indexOf('@');\n  const spaceOnlyAfterHash = !firstSpace || firstHash > -1 && firstSpace.index > firstHash;\n  const atOnlyAfterHash = firstAt === -1 || firstHash > -1 && firstAt > firstHash;\n  const colonOnlyAfterHash = firstColon === -1 || firstHash > -1 && firstColon > firstHash;\n  const secondSlashOnlyAfterHash = secondSlash === -1 || firstHash > -1 && secondSlash > firstHash;\n  const hasSlash = firstSlash > 0; // if a # is found, what we really want to know is that the character\n  // immediately before # is not a /\n\n  const doesNotEndWithSlash = firstHash > -1 ? arg[firstHash - 1] !== '/' : !arg.endsWith('/');\n  const doesNotStartWithDot = !arg.startsWith('.');\n  return spaceOnlyAfterHash && hasSlash && doesNotEndWithSlash && doesNotStartWithDot && atOnlyAfterHash && colonOnlyAfterHash && secondSlashOnlyAfterHash;\n}; // attempt to correct an scp style url so that it will parse with `new URL()`\n\n\nconst correctUrl = giturl => {\n  const firstAt = giturl.indexOf('@');\n  const lastHash = giturl.lastIndexOf('#');\n  let firstColon = giturl.indexOf(':');\n  let lastColon = giturl.lastIndexOf(':', lastHash > -1 ? lastHash : Infinity);\n  let corrected;\n\n  if (lastColon > firstAt) {\n    // the last : comes after the first @ (or there is no @)\n    // like it would in:\n    // proto://hostname.com:user/repo\n    // username@hostname.com:user/repo\n    // :password@hostname.com:user/repo\n    // username:password@hostname.com:user/repo\n    // proto://username@hostname.com:user/repo\n    // proto://:password@hostname.com:user/repo\n    // proto://username:password@hostname.com:user/repo\n    // then we replace the last : with a / to create a valid path\n    corrected = giturl.slice(0, lastColon) + '/' + giturl.slice(lastColon + 1); // // and we find our new : positions\n\n    firstColon = corrected.indexOf(':');\n    lastColon = corrected.lastIndexOf(':');\n  }\n\n  if (firstColon === -1 && giturl.indexOf('//') === -1) {\n    // we have no : at all\n    // as it would be in:\n    // username@hostname.com/user/repo\n    // then we prepend a protocol\n    corrected = `git+ssh://${corrected}`;\n  }\n\n  return corrected;\n}; // try to parse the url as its given to us, if that throws\n// then we try to clean the url and parse that result instead\n// THIS FUNCTION SHOULD NEVER THROW\n\n\nconst parseGitUrl = giturl => {\n  let result;\n\n  try {\n    result = new url.URL(giturl);\n  } catch {// this fn should never throw\n  }\n\n  if (result) {\n    return result;\n  }\n\n  const correctedUrl = correctUrl(giturl);\n\n  try {\n    result = new url.URL(correctedUrl);\n  } catch {// this fn should never throw\n  }\n\n  return result;\n};","map":null,"metadata":{},"sourceType":"script"}