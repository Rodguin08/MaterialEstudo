{"ast":null,"code":"'use strict';\n\nconst LRU = require('lru-cache');\n\nconst url = require('url');\n\nconst isLambda = require('is-lambda');\n\nconst dns = require('./dns.js');\n\nconst AGENT_CACHE = new LRU({\n  max: 50\n});\n\nconst HttpAgent = require('agentkeepalive');\n\nconst HttpsAgent = HttpAgent.HttpsAgent;\nmodule.exports = getAgent;\n\nconst getAgentTimeout = timeout => typeof timeout !== 'number' || !timeout ? 0 : timeout + 1;\n\nconst getMaxSockets = maxSockets => maxSockets || 15;\n\nfunction getAgent(uri, opts) {\n  const parsedUri = new url.URL(typeof uri === 'string' ? uri : uri.url);\n  const isHttps = parsedUri.protocol === 'https:';\n  const pxuri = getProxyUri(parsedUri.href, opts); // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout\n  // of zero disables the timeout behavior (OS limits still apply). Else, if\n  // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that\n  // the node-fetch-npm timeout will always fire first, giving us more\n  // consistent errors.\n\n  const agentTimeout = getAgentTimeout(opts.timeout);\n  const agentMaxSockets = getMaxSockets(opts.maxSockets);\n  const key = [`https:${isHttps}`, pxuri ? `proxy:${pxuri.protocol}//${pxuri.host}:${pxuri.port}` : '>no-proxy<', `local-address:${opts.localAddress || '>no-local-address<'}`, `strict-ssl:${isHttps ? opts.rejectUnauthorized : '>no-strict-ssl<'}`, `ca:${isHttps && opts.ca || '>no-ca<'}`, `cert:${isHttps && opts.cert || '>no-cert<'}`, `key:${isHttps && opts.key || '>no-key<'}`, `timeout:${agentTimeout}`, `maxSockets:${agentMaxSockets}`].join(':');\n\n  if (opts.agent != null) {\n    // `agent: false` has special behavior!\n    return opts.agent;\n  } // keep alive in AWS lambda makes no sense\n\n\n  const lambdaAgent = !isLambda ? null : isHttps ? require('https').globalAgent : require('http').globalAgent;\n\n  if (isLambda && !pxuri) {\n    return lambdaAgent;\n  }\n\n  if (AGENT_CACHE.peek(key)) {\n    return AGENT_CACHE.get(key);\n  }\n\n  if (pxuri) {\n    const pxopts = isLambda ? { ...opts,\n      agent: lambdaAgent\n    } : opts;\n    const proxy = getProxy(pxuri, pxopts, isHttps);\n    AGENT_CACHE.set(key, proxy);\n    return proxy;\n  }\n\n  const agent = isHttps ? new HttpsAgent({\n    maxSockets: agentMaxSockets,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    localAddress: opts.localAddress,\n    rejectUnauthorized: opts.rejectUnauthorized,\n    timeout: agentTimeout,\n    freeSocketTimeout: 15000,\n    lookup: dns.getLookup(opts.dns)\n  }) : new HttpAgent({\n    maxSockets: agentMaxSockets,\n    localAddress: opts.localAddress,\n    timeout: agentTimeout,\n    freeSocketTimeout: 15000,\n    lookup: dns.getLookup(opts.dns)\n  });\n  AGENT_CACHE.set(key, agent);\n  return agent;\n}\n\nfunction checkNoProxy(uri, opts) {\n  const host = new url.URL(uri).hostname.split('.').reverse();\n  let noproxy = opts.noProxy || getProcessEnv('no_proxy');\n\n  if (typeof noproxy === 'string') {\n    noproxy = noproxy.split(',').map(n => n.trim());\n  }\n\n  return noproxy && noproxy.some(no => {\n    const noParts = no.split('.').filter(x => x).reverse();\n\n    if (!noParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < noParts.length; i++) {\n      if (host[i] !== noParts[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n\nmodule.exports.getProcessEnv = getProcessEnv;\n\nfunction getProcessEnv(env) {\n  if (!env) {\n    return;\n  }\n\n  let value;\n\n  if (Array.isArray(env)) {\n    for (const e of env) {\n      value = process.env[e] || process.env[e.toUpperCase()] || process.env[e.toLowerCase()];\n\n      if (typeof value !== 'undefined') {\n        break;\n      }\n    }\n  }\n\n  if (typeof env === 'string') {\n    value = process.env[env] || process.env[env.toUpperCase()] || process.env[env.toLowerCase()];\n  }\n\n  return value;\n}\n\nmodule.exports.getProxyUri = getProxyUri;\n\nfunction getProxyUri(uri, opts) {\n  const protocol = new url.URL(uri).protocol;\n  const proxy = opts.proxy || protocol === 'https:' && getProcessEnv('https_proxy') || protocol === 'http:' && getProcessEnv(['https_proxy', 'http_proxy', 'proxy']);\n\n  if (!proxy) {\n    return null;\n  }\n\n  const parsedProxy = typeof proxy === 'string' ? new url.URL(proxy) : proxy;\n  return !checkNoProxy(uri, opts) && parsedProxy;\n}\n\nconst getAuth = u => u.username && u.password ? decodeURIComponent(`${u.username}:${u.password}`) : u.username ? decodeURIComponent(u.username) : null;\n\nconst getPath = u => u.pathname + u.search + u.hash;\n\nconst HttpProxyAgent = require('http-proxy-agent');\n\nconst HttpsProxyAgent = require('https-proxy-agent');\n\nconst {\n  SocksProxyAgent\n} = require('socks-proxy-agent');\n\nmodule.exports.getProxy = getProxy;\n\nfunction getProxy(proxyUrl, opts, isHttps) {\n  // our current proxy agents do not support an overridden dns lookup method, so will not\n  // benefit from the dns cache\n  const popts = {\n    host: proxyUrl.hostname,\n    port: proxyUrl.port,\n    protocol: proxyUrl.protocol,\n    path: getPath(proxyUrl),\n    auth: getAuth(proxyUrl),\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    timeout: getAgentTimeout(opts.timeout),\n    localAddress: opts.localAddress,\n    maxSockets: getMaxSockets(opts.maxSockets),\n    rejectUnauthorized: opts.rejectUnauthorized\n  };\n\n  if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {\n    if (!isHttps) {\n      return new HttpProxyAgent(popts);\n    } else {\n      return new HttpsProxyAgent(popts);\n    }\n  } else if (proxyUrl.protocol.startsWith('socks')) {\n    // socks-proxy-agent uses hostname not host\n    popts.hostname = popts.host;\n    delete popts.host;\n    return new SocksProxyAgent(popts);\n  } else {\n    throw Object.assign(new Error(`unsupported proxy protocol: '${proxyUrl.protocol}'`), {\n      code: 'EUNSUPPORTEDPROXY',\n      url: proxyUrl.href\n    });\n  }\n}","map":null,"metadata":{},"sourceType":"script"}