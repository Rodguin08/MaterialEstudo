{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseJsonSchemaToOptions = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nfunction parseJsonSchemaToOptions(_x, _x2) {\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nfunction _parseJsonSchemaToOptions() {\n  _parseJsonSchemaToOptions = _asyncToGenerator(function* (registry, schema, interactive = true) {\n    const options = [];\n\n    function visitor(current, pointer, parentSchema) {\n      if (!parentSchema) {\n        // Ignore root.\n        return;\n      } else if (pointer.split(/\\/(?:properties|items|definitions)\\//g).length > 2) {\n        // Ignore subitems (objects or arrays).\n        return;\n      } else if (core_1.json.isJsonArray(current)) {\n        return;\n      }\n\n      if (pointer.indexOf('/not/') != -1) {\n        // We don't support anyOf/not.\n        throw new Error('The \"not\" keyword is not supported in JSON Schema.');\n      }\n\n      const ptr = core_1.json.schema.parseJsonPointer(pointer);\n      const name = ptr[ptr.length - 1];\n\n      if (ptr[ptr.length - 2] != 'properties') {\n        // Skip any non-property items.\n        return;\n      }\n\n      const typeSet = core_1.json.schema.getTypesOfSchema(current);\n\n      if (typeSet.size == 0) {\n        throw new Error('Cannot find type of schema.');\n      } // We only support number, string or boolean (or array of those), so remove everything else.\n\n\n      const types = [...typeSet].filter(x => {\n        switch (x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          case 'array':\n            // Only include arrays if they're boolean, string or number.\n            if (core_1.json.isJsonObject(current.items) && typeof current.items.type == 'string' && ['boolean', 'number', 'string'].includes(current.items.type)) {\n              return true;\n            }\n\n            return false;\n\n          default:\n            return false;\n        }\n      });\n\n      if (types.length == 0) {\n        // This means it's not usable on the command line. e.g. an Object.\n        return;\n      } // Only keep enum values we support (booleans, numbers and strings).\n\n\n      const enumValues = (core_1.json.isJsonArray(current.enum) && current.enum || []).filter(x => {\n        switch (typeof x) {\n          case 'boolean':\n          case 'number':\n          case 'string':\n            return true;\n\n          default:\n            return false;\n        }\n      });\n      let defaultValue = undefined;\n\n      if (current.default !== undefined) {\n        switch (types[0]) {\n          case 'string':\n            if (typeof current.default == 'string') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'number':\n            if (typeof current.default == 'number') {\n              defaultValue = current.default;\n            }\n\n            break;\n\n          case 'boolean':\n            if (typeof current.default == 'boolean') {\n              defaultValue = current.default;\n            }\n\n            break;\n        }\n      }\n\n      const type = types[0];\n      const $default = current.$default;\n      const $defaultIndex = core_1.json.isJsonObject($default) && $default['$source'] == 'argv' ? $default['index'] : undefined;\n      const positional = typeof $defaultIndex == 'number' ? $defaultIndex : undefined;\n      let required = core_1.json.isJsonArray(schema.required) ? schema.required.includes(name) : false;\n\n      if (required && interactive && current['x-prompt']) {\n        required = false;\n      }\n\n      const alias = core_1.json.isJsonArray(current.aliases) ? [...current.aliases].map(x => '' + x) : current.alias ? ['' + current.alias] : [];\n      const format = typeof current.format == 'string' ? current.format : undefined;\n      const visible = current.visible === undefined || current.visible === true;\n      const hidden = !!current.hidden || !visible;\n      const xUserAnalytics = current['x-user-analytics'];\n      const userAnalytics = typeof xUserAnalytics == 'number' ? xUserAnalytics : undefined; // Deprecated is set only if it's true or a string.\n\n      const xDeprecated = current['x-deprecated'];\n      const deprecated = xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : undefined;\n      const option = {\n        name,\n        description: '' + (current.description === undefined ? '' : current.description),\n        type,\n        default: defaultValue,\n        choices: enumValues.length ? enumValues : undefined,\n        required,\n        alias,\n        format,\n        hidden,\n        userAnalytics,\n        deprecated,\n        positional\n      };\n      options.push(option);\n    }\n\n    const flattenedSchema = yield registry.flatten(schema).toPromise();\n    core_1.json.schema.visitJsonSchema(flattenedSchema, visitor); // Sort by positional and name.\n\n    return options.sort((a, b) => {\n      if (a.positional) {\n        return b.positional ? a.positional - b.positional : a.name.localeCompare(b.name);\n      } else if (b.positional) {\n        return -1;\n      }\n\n      return a.name.localeCompare(b.name);\n    });\n  });\n  return _parseJsonSchemaToOptions.apply(this, arguments);\n}\n\nexports.parseJsonSchemaToOptions = parseJsonSchemaToOptions;","map":null,"metadata":{},"sourceType":"script"}