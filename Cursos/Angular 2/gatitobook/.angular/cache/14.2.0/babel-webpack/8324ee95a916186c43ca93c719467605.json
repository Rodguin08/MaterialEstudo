{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArchitectCommandModule = void 0;\n\nconst config_1 = /*#__PURE__*/require(\"../utilities/config\");\n\nconst memoize_1 = /*#__PURE__*/require(\"../utilities/memoize\");\n\nconst architect_base_command_module_1 = /*#__PURE__*/require(\"./architect-base-command-module\");\n\nconst command_module_1 = /*#__PURE__*/require(\"./command-module\");\n\nclass ArchitectCommandModule extends architect_base_command_module_1.ArchitectBaseCommandModule {\n  builder(argv) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const project = _this.getArchitectProject();\n\n      const {\n        jsonHelp,\n        getYargsCompletions,\n        help\n      } = _this.context.args.options;\n      const localYargs = argv.positional('project', {\n        describe: 'The name of the project to build. Can be an application or a library.',\n        type: 'string',\n        // Hide choices from JSON help so that we don't display them in AIO.\n        choices: jsonHelp ? undefined : _this.getProjectChoices()\n      }).option('configuration', {\n        describe: `One or more named builder configurations as a comma-separated ` + `list as specified in the \"configurations\" section in angular.json.\\n` + `The builder uses the named configurations to run the given target.\\n` + `For more information, see https://angular.io/guide/workspace-config#alternate-build-configurations.`,\n        alias: 'c',\n        type: 'string',\n        // Show only in when using --help and auto completion because otherwise comma seperated configuration values will be invalid.\n        // Also, hide choices from JSON help so that we don't display them in AIO.\n        choices: (getYargsCompletions || help) && !jsonHelp && project ? _this.getConfigurationChoices(project) : undefined\n      }).strict();\n\n      if (!project) {\n        return localYargs;\n      }\n\n      const target = _this.getArchitectTarget();\n\n      const schemaOptions = yield _this.getArchitectTargetOptions({\n        project,\n        target\n      });\n      return _this.addSchemaOptionsToCommand(localYargs, schemaOptions);\n    })();\n  }\n\n  run(options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const target = _this2.getArchitectTarget();\n\n      const {\n        configuration = '',\n        project,\n        ...architectOptions\n      } = options;\n\n      if (!project) {\n        // This runs each target sequentially.\n        // Running them in parallel would jumble the log messages.\n        let result = 0;\n\n        const projectNames = _this2.getProjectNamesByTarget(target);\n\n        if (!projectNames) {\n          return _this2.onMissingTarget('Cannot determine project or target for command.');\n        }\n\n        for (const project of projectNames) {\n          result |= yield _this2.runSingleTarget({\n            configuration,\n            target,\n            project\n          }, architectOptions);\n        }\n\n        return result;\n      } else {\n        return yield _this2.runSingleTarget({\n          configuration,\n          target,\n          project\n        }, architectOptions);\n      }\n    })();\n  }\n\n  getArchitectProject() {\n    const {\n      options,\n      positional\n    } = this.context.args;\n    const [, projectName] = positional;\n\n    if (projectName) {\n      return projectName;\n    } // Yargs allows positional args to be used as flags.\n\n\n    if (typeof options['project'] === 'string') {\n      return options['project'];\n    }\n\n    const target = this.getArchitectTarget();\n    const projectFromTarget = this.getProjectNamesByTarget(target);\n    return (projectFromTarget === null || projectFromTarget === void 0 ? void 0 : projectFromTarget.length) ? projectFromTarget[0] : undefined;\n  }\n\n  getProjectNamesByTarget(target) {\n    const workspace = this.getWorkspaceOrThrow();\n    const allProjectsForTargetName = [];\n\n    for (const [name, project] of workspace.projects) {\n      if (project.targets.has(target)) {\n        allProjectsForTargetName.push(name);\n      }\n    }\n\n    if (allProjectsForTargetName.length === 0) {\n      return undefined;\n    }\n\n    if (this.multiTarget) {\n      // For multi target commands, we always list all projects that have the target.\n      return allProjectsForTargetName;\n    } else {\n      if (allProjectsForTargetName.length === 1) {\n        return allProjectsForTargetName;\n      }\n\n      const maybeProject = (0, config_1.getProjectByCwd)(workspace);\n\n      if (maybeProject) {\n        return allProjectsForTargetName.includes(maybeProject) ? [maybeProject] : undefined;\n      }\n\n      const {\n        getYargsCompletions,\n        help\n      } = this.context.args.options;\n\n      if (!getYargsCompletions && !help) {\n        // Only issue the below error when not in help / completion mode.\n        throw new command_module_1.CommandModuleError('Cannot determine project for command.\\n' + 'This is a multi-project workspace and more than one project supports this command. ' + `Run \"ng ${this.command}\" to execute the command for a specific project or change the current ` + 'working directory to a project directory.\\n\\n' + `Available projects are:\\n${allProjectsForTargetName.sort().map(p => `- ${p}`).join('\\n')}`);\n      }\n    }\n\n    return undefined;\n  }\n  /** @returns a sorted list of project names to be used for auto completion. */\n\n\n  getProjectChoices() {\n    const {\n      workspace\n    } = this.context;\n    return workspace ? [...workspace.projects.keys()].sort() : undefined;\n  }\n  /** @returns a sorted list of configuration names to be used for auto completion. */\n\n\n  getConfigurationChoices(project) {\n    var _a, _b;\n\n    const projectDefinition = (_a = this.context.workspace) === null || _a === void 0 ? void 0 : _a.projects.get(project);\n\n    if (!projectDefinition) {\n      return undefined;\n    }\n\n    const target = this.getArchitectTarget();\n    const configurations = (_b = projectDefinition.targets.get(target)) === null || _b === void 0 ? void 0 : _b.configurations;\n    return configurations ? Object.keys(configurations).sort() : undefined;\n  }\n\n}\n\n__decorate([memoize_1.memoize], ArchitectCommandModule.prototype, \"getProjectNamesByTarget\", null);\n\nexports.ArchitectCommandModule = ArchitectCommandModule;","map":null,"metadata":{},"sourceType":"script"}