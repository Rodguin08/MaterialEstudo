{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyToSubtree = exports.composeFileOperators = exports.forEach = exports.partitionApplyMerge = exports.when = exports.branchAndMerge = exports.asSource = exports.filter = exports.noop = exports.mergeWith = exports.apply = exports.chain = exports.empty = exports.source = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../exception/exception\");\n\nconst host_tree_1 = require(\"../tree/host-tree\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nconst scoped_1 = require(\"../tree/scoped\");\n\nconst static_1 = require(\"../tree/static\");\n\nconst call_1 = require(\"./call\");\n/**\n * A Source that returns an tree as its single value.\n */\n\n\nfunction source(tree) {\n  return () => tree;\n}\n\nexports.source = source;\n/**\n * A source that returns an empty tree.\n */\n\nfunction empty() {\n  return () => (0, static_1.empty)();\n}\n\nexports.empty = empty;\n/**\n * Chain multiple rules into a single rule.\n */\n\nfunction chain(rules) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (initialTree, context) {\n      let intermediateTree;\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(rules), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const rule = _step.value;\n          intermediateTree = (0, call_1.callRule)(rule, intermediateTree !== null && intermediateTree !== void 0 ? intermediateTree : initialTree, context);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return () => intermediateTree;\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}\n\nexports.chain = chain;\n/**\n * Apply multiple rules to a source, and returns the source transformed.\n */\n\nfunction apply(source, rules) {\n  return context => (0, call_1.callRule)(chain(rules), (0, call_1.callSource)(source, context), context);\n}\n\nexports.apply = apply;\n/**\n * Merge an input tree with the source passed in.\n */\n\nfunction mergeWith(source, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callSource)(source, context).pipe((0, operators_1.map)(sourceTree => tree.merge(sourceTree, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\n\nexports.mergeWith = mergeWith;\n\nfunction noop() {\n  return () => {};\n}\n\nexports.noop = noop;\n\nfunction filter(predicate) {\n  return tree => {\n    if (host_tree_1.HostTree.isHostTree(tree)) {\n      return new host_tree_1.FilterHostTree(tree, predicate);\n    } else {\n      throw new exception_1.SchematicsException('Tree type is not supported.');\n    }\n  };\n}\n\nexports.filter = filter;\n\nfunction asSource(rule) {\n  return context => (0, call_1.callRule)(rule, (0, static_1.empty)(), context);\n}\n\nexports.asSource = asSource;\n\nfunction branchAndMerge(rule, strategy = interface_1.MergeStrategy.Default) {\n  return (tree, context) => {\n    return (0, call_1.callRule)(rule, tree.branch(), context).pipe((0, operators_1.map)(branch => tree.merge(branch, strategy || context.strategy)), (0, operators_1.mapTo)(tree));\n  };\n}\n\nexports.branchAndMerge = branchAndMerge;\n\nfunction when(predicate, operator) {\n  return entry => {\n    if (predicate(entry.path, entry)) {\n      return operator(entry);\n    } else {\n      return entry;\n    }\n  };\n}\n\nexports.when = when;\n\nfunction partitionApplyMerge(predicate, ruleYes, ruleNo) {\n  return (tree, context) => {\n    const [yes, no] = (0, static_1.partition)(tree, predicate);\n    return (0, rxjs_1.concat)((0, call_1.callRule)(ruleYes, yes, context), (0, call_1.callRule)(ruleNo || noop(), no, context)).pipe((0, operators_1.toArray)(), (0, operators_1.map)(([yesTree, noTree]) => {\n      yesTree.merge(noTree, context.strategy);\n      return yesTree;\n    }));\n  };\n}\n\nexports.partitionApplyMerge = partitionApplyMerge;\n\nfunction forEach(operator) {\n  return tree => {\n    tree.visit((path, entry) => {\n      if (!entry) {\n        return;\n      }\n\n      const newEntry = operator(entry);\n\n      if (newEntry === entry) {\n        return;\n      }\n\n      if (newEntry === null) {\n        tree.delete(path);\n        return;\n      }\n\n      if (newEntry.path != path) {\n        tree.rename(path, newEntry.path);\n      }\n\n      if (!newEntry.content.equals(entry.content)) {\n        tree.overwrite(newEntry.path, newEntry.content);\n      }\n    });\n  };\n}\n\nexports.forEach = forEach;\n\nfunction composeFileOperators(operators) {\n  return entry => {\n    let current = entry;\n\n    for (const op of operators) {\n      current = op(current);\n\n      if (current === null) {\n        // Deleted, just return.\n        return null;\n      }\n    }\n\n    return current;\n  };\n}\n\nexports.composeFileOperators = composeFileOperators;\n\nfunction applyToSubtree(path, rules) {\n  return (tree, context) => {\n    const scoped = new scoped_1.ScopedTree(tree, path);\n    return (0, call_1.callRule)(chain(rules), scoped, context).pipe((0, operators_1.map)(result => {\n      if (result === scoped) {\n        return tree;\n      } else {\n        throw new exception_1.SchematicsException('Original tree must be returned from all rules when using \"applyToSubtree\".');\n      }\n    }));\n  };\n}\n\nexports.applyToSubtree = applyToSubtree;","map":null,"metadata":{},"sourceType":"script"}