{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandModuleError = exports.CommandModule = exports.CommandScope = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst path = __importStar( /*#__PURE__*/require(\"path\"));\n\nconst helpers_1 = /*#__PURE__*/require(\"yargs/helpers\");\n\nconst analytics_1 = /*#__PURE__*/require(\"../analytics/analytics\");\n\nconst completion_1 = /*#__PURE__*/require(\"../utilities/completion\");\n\nconst memoize_1 = /*#__PURE__*/require(\"../utilities/memoize\");\n\nvar CommandScope;\n\n(function (CommandScope) {\n  /** Command can only run inside an Angular workspace. */\n  CommandScope[CommandScope[\"In\"] = 0] = \"In\";\n  /** Command can only run outside an Angular workspace. */\n\n  CommandScope[CommandScope[\"Out\"] = 1] = \"Out\";\n  /** Command can run inside and outside an Angular workspace. */\n\n  CommandScope[CommandScope[\"Both\"] = 2] = \"Both\";\n})(CommandScope = exports.CommandScope || (exports.CommandScope = {}));\n\nclass CommandModule {\n  constructor(context) {\n    this.context = context;\n    this.shouldReportAnalytics = true;\n    this.scope = CommandScope.Both;\n    this.optionsWithAnalytics = new Map();\n  }\n  /**\n   * Description object which contains the long command descroption.\n   * This is used to generate JSON help wich is used in AIO.\n   *\n   * `false` will result in a hidden command.\n   */\n\n\n  get fullDescribe() {\n    return this.describe === false ? false : {\n      describe: this.describe,\n      ...(this.longDescriptionPath ? {\n        longDescriptionRelativePath: path.relative(path.join(__dirname, '../../../../'), this.longDescriptionPath).replace(/\\\\/g, path.posix.sep),\n        longDescription: (0, fs_1.readFileSync)(this.longDescriptionPath, 'utf8').replace(/\\r\\n/g, '\\n')\n      } : {})\n    };\n  }\n\n  get commandName() {\n    return this.command.split(' ', 1)[0];\n  }\n\n  handler(args) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        _,\n        $0,\n        ...options\n      } = args; // Camelize options as yargs will return the object in kebab-case when camel casing is disabled.\n\n      const camelCasedOptions = {};\n\n      for (const [key, value] of Object.entries(options)) {\n        camelCasedOptions[helpers_1.Parser.camelCase(key)] = value;\n      } // Set up autocompletion if appropriate.\n\n\n      const autocompletionExitCode = yield (0, completion_1.considerSettingUpAutocompletion)(_this.commandName, _this.context.logger);\n\n      if (autocompletionExitCode !== undefined) {\n        process.exitCode = autocompletionExitCode;\n        return;\n      } // Gather and report analytics.\n\n\n      const analytics = yield _this.getAnalytics();\n\n      if (_this.shouldReportAnalytics) {\n        yield _this.reportAnalytics(camelCasedOptions);\n      }\n\n      let exitCode;\n\n      try {\n        // Run and time command.\n        const startTime = Date.now();\n        exitCode = yield _this.run(camelCasedOptions);\n        const endTime = Date.now();\n        analytics.timing(_this.commandName, 'duration', endTime - startTime);\n        yield analytics.flush();\n      } catch (e) {\n        if (e instanceof core_1.schema.SchemaValidationException) {\n          _this.context.logger.fatal(`Error: ${e.message}`);\n\n          exitCode = 1;\n        } else {\n          throw e;\n        }\n      } finally {\n        if (typeof exitCode === 'number' && exitCode > 0) {\n          process.exitCode = exitCode;\n        }\n      }\n    })();\n  }\n\n  reportAnalytics(options, paths = [], dimensions = []) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const [name, ua] of _this2.optionsWithAnalytics) {\n        const value = options[name];\n\n        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {\n          dimensions[ua] = value;\n        }\n      }\n\n      const analytics = yield _this2.getAnalytics();\n      analytics.pageview('/command/' + [_this2.commandName, ...paths].join('/'), {\n        dimensions,\n        metrics: []\n      });\n    })();\n  }\n\n  getAnalytics() {\n    return (0, analytics_1.createAnalytics)(!!this.context.workspace, // Don't prompt for `ng update` and `ng analytics` commands.\n    ['update', 'analytics'].includes(this.commandName));\n  }\n  /**\n   * Adds schema options to a command also this keeps track of options that are required for analytics.\n   * **Note:** This method should be called from the command bundler method.\n   */\n\n\n  addSchemaOptionsToCommand(localYargs, options) {\n    const booleanOptionsWithNoPrefix = new Set();\n\n    for (const option of options) {\n      const {\n        default: defaultVal,\n        positional,\n        deprecated,\n        description,\n        alias,\n        userAnalytics,\n        type,\n        hidden,\n        name,\n        choices\n      } = option;\n      const sharedOptions = {\n        alias,\n        hidden,\n        description,\n        deprecated,\n        choices,\n        // This should only be done when `--help` is used otherwise default will override options set in angular.json.\n        ...(this.context.args.options.help ? {\n          default: defaultVal\n        } : {})\n      };\n      let dashedName = core_1.strings.dasherize(name); // Handle options which have been defined in the schema with `no` prefix.\n\n      if (type === 'boolean' && dashedName.startsWith('no-')) {\n        dashedName = dashedName.slice(3);\n        booleanOptionsWithNoPrefix.add(dashedName);\n      }\n\n      if (positional === undefined) {\n        localYargs = localYargs.option(dashedName, {\n          type,\n          ...sharedOptions\n        });\n      } else {\n        localYargs = localYargs.positional(dashedName, {\n          type: type === 'array' || type === 'count' ? 'string' : type,\n          ...sharedOptions\n        });\n      } // Record option of analytics.\n\n\n      if (userAnalytics !== undefined) {\n        this.optionsWithAnalytics.set(name, userAnalytics);\n      }\n    } // Handle options which have been defined in the schema with `no` prefix.\n\n\n    if (booleanOptionsWithNoPrefix.size) {\n      localYargs.middleware(options => {\n        for (const key of booleanOptionsWithNoPrefix) {\n          if (key in options) {\n            options[`no-${key}`] = !options[key];\n            delete options[key];\n          }\n        }\n      }, false);\n    }\n\n    return localYargs;\n  }\n\n  getWorkspaceOrThrow() {\n    const {\n      workspace\n    } = this.context;\n\n    if (!workspace) {\n      throw new CommandModuleError('A workspace is required for this command.');\n    }\n\n    return workspace;\n  }\n\n}\n\n__decorate([memoize_1.memoize], CommandModule.prototype, \"getAnalytics\", null);\n\nexports.CommandModule = CommandModule;\n/**\n * Creates an known command module error.\n * This is used so during executation we can filter between known validation error and real non handled errors.\n */\n\nclass CommandModuleError extends Error {}\n\nexports.CommandModuleError = CommandModuleError;","map":null,"metadata":{},"sourceType":"script"}