{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CoreSchemaRegistry = exports.SchemaValidationException = void 0;\n\nconst ajv_1 = __importDefault(require(\"ajv\"));\n\nconst ajv_formats_1 = __importDefault(require(\"ajv-formats\"));\n\nconst http = __importStar(require(\"http\"));\n\nconst https = __importStar(require(\"https\"));\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst Url = __importStar(require(\"url\"));\n\nconst exception_1 = require(\"../../exception\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst utils_2 = require(\"../utils\");\n\nconst utility_1 = require(\"./utility\");\n\nconst visitor_1 = require(\"./visitor\");\n\nclass SchemaValidationException extends exception_1.BaseException {\n  constructor(errors, baseMessage = 'Schema validation failed with the following errors:') {\n    if (!errors || errors.length === 0) {\n      super('Schema validation failed.');\n      this.errors = [];\n      return;\n    }\n\n    const messages = SchemaValidationException.createMessages(errors);\n    super(`${baseMessage}\\n  ${messages.join('\\n  ')}`);\n    this.errors = errors;\n  }\n\n  static createMessages(errors) {\n    if (!errors || errors.length === 0) {\n      return [];\n    }\n\n    const messages = errors.map(err => {\n      var _a;\n\n      let message = `Data path ${JSON.stringify(err.instancePath)} ${err.message}`;\n\n      if (err.params) {\n        switch (err.keyword) {\n          case 'additionalProperties':\n            message += `(${err.params.additionalProperty})`;\n            break;\n\n          case 'enum':\n            message += `. Allowed values are: ${(_a = err.params.allowedValues) === null || _a === void 0 ? void 0 : _a.map(v => `\"${v}\"`).join(', ')}`;\n            break;\n        }\n      }\n\n      return message + '.';\n    });\n    return messages;\n  }\n\n}\n\nexports.SchemaValidationException = SchemaValidationException;\n\nclass CoreSchemaRegistry {\n  constructor(formats = []) {\n    this._uriCache = new Map();\n    this._uriHandlers = new Set();\n    this._pre = new utils_1.PartiallyOrderedSet();\n    this._post = new utils_1.PartiallyOrderedSet();\n    this._smartDefaultKeyword = false;\n    this._sourceMap = new Map();\n    this._ajv = new ajv_1.default({\n      strict: false,\n      loadSchema: uri => this._fetch(uri),\n      passContext: true\n    });\n    (0, ajv_formats_1.default)(this._ajv);\n\n    for (const format of formats) {\n      this.addFormat(format);\n    }\n  }\n\n  _fetch(uri) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const maybeSchema = _this._uriCache.get(uri);\n\n      if (maybeSchema) {\n        return maybeSchema;\n      } // Try all handlers, one after the other.\n\n\n      for (const handler of _this._uriHandlers) {\n        let handlerResult = handler(uri);\n\n        if (handlerResult === null || handlerResult === undefined) {\n          continue;\n        }\n\n        if ((0, rxjs_1.isObservable)(handlerResult)) {\n          handlerResult = handlerResult.toPromise();\n        }\n\n        const value = yield handlerResult;\n\n        _this._uriCache.set(uri, value);\n\n        return value;\n      } // If none are found, handle using http client.\n\n\n      return new Promise((resolve, reject) => {\n        const url = new Url.URL(uri);\n        const client = url.protocol === 'https:' ? https : http;\n        client.get(url, res => {\n          if (!res.statusCode || res.statusCode >= 300) {\n            // Consume the rest of the data to free memory.\n            res.resume();\n            reject(new Error(`Request failed. Status Code: ${res.statusCode}`));\n          } else {\n            res.setEncoding('utf8');\n            let data = '';\n            res.on('data', chunk => {\n              data += chunk;\n            });\n            res.on('end', () => {\n              try {\n                const json = JSON.parse(data);\n\n                _this._uriCache.set(uri, json);\n\n                resolve(json);\n              } catch (err) {\n                reject(err);\n              }\n            });\n          }\n        });\n      });\n    })();\n  }\n  /**\n   * Add a transformation step before the validation of any Json.\n   * @param {JsonVisitor} visitor The visitor to transform every value.\n   * @param {JsonVisitor[]} deps A list of other visitors to run before.\n   */\n\n\n  addPreTransform(visitor, deps) {\n    this._pre.add(visitor, deps);\n  }\n  /**\n   * Add a transformation step after the validation of any Json. The JSON will not be validated\n   * after the POST, so if transformations are not compatible with the Schema it will not result\n   * in an error.\n   * @param {JsonVisitor} visitor The visitor to transform every value.\n   * @param {JsonVisitor[]} deps A list of other visitors to run before.\n   */\n\n\n  addPostTransform(visitor, deps) {\n    this._post.add(visitor, deps);\n  }\n\n  _resolver(ref, validate) {\n    if (!validate || !ref) {\n      return {};\n    }\n\n    const schema = validate.schemaEnv.root.schema;\n    const id = typeof schema === 'object' ? schema.$id : null;\n    let fullReference = ref;\n\n    if (typeof id === 'string') {\n      fullReference = Url.resolve(id, ref);\n\n      if (ref.startsWith('#')) {\n        fullReference = id + fullReference;\n      }\n    }\n\n    const resolvedSchema = this._ajv.getSchema(fullReference);\n\n    return {\n      context: resolvedSchema === null || resolvedSchema === void 0 ? void 0 : resolvedSchema.schemaEnv.validate,\n      schema: resolvedSchema === null || resolvedSchema === void 0 ? void 0 : resolvedSchema.schema\n    };\n  }\n  /**\n   * Flatten the Schema, resolving and replacing all the refs. Makes it into a synchronous schema\n   * that is also easier to traverse. Does not cache the result.\n   *\n   * @param schema The schema or URI to flatten.\n   * @returns An Observable of the flattened schema object.\n   * @deprecated since 11.2 without replacement.\n   * Producing a flatten schema document does not in all cases produce a schema with identical behavior to the original.\n   * See: https://json-schema.org/draft/2019-09/json-schema-core.html#rfc.appendix.B.2\n   */\n\n\n  flatten(schema) {\n    return (0, rxjs_1.from)(this._flatten(schema));\n  }\n\n  _flatten(schema) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2._ajv.removeSchema(schema);\n\n      _this2._currentCompilationSchemaInfo = undefined;\n      const validate = yield _this2._ajv.compileAsync(schema); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      const self = _this2;\n\n      function visitor(current, pointer, parentSchema, index) {\n        if (current && parentSchema && index && (0, utils_2.isJsonObject)(current) && Object.prototype.hasOwnProperty.call(current, '$ref') && typeof current['$ref'] == 'string') {\n          const resolved = self._resolver(current['$ref'], validate);\n\n          if (resolved.schema) {\n            parentSchema[index] = resolved.schema;\n          }\n        }\n      }\n\n      const schemaCopy = (0, utils_1.deepCopy)(validate.schema);\n      (0, visitor_1.visitJsonSchema)(schemaCopy, visitor);\n      return schemaCopy;\n    })();\n  }\n  /**\n   * Compile and return a validation function for the Schema.\n   *\n   * @param schema The schema to validate. If a string, will fetch the schema before compiling it\n   * (using schema as a URI).\n   * @returns An Observable of the Validation function.\n   */\n\n\n  compile(schema) {\n    return (0, rxjs_1.from)(this._compile(schema)).pipe((0, operators_1.map)(validate => (value, options) => (0, rxjs_1.from)(validate(value, options))));\n  }\n\n  _compile(schema) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (typeof schema === 'boolean') {\n        return /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (data) {\n            return {\n              success: schema,\n              data\n            };\n          });\n\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n      }\n\n      const schemaInfo = {\n        smartDefaultRecord: new Map(),\n        promptDefinitions: []\n      };\n\n      _this3._ajv.removeSchema(schema);\n\n      let validator;\n\n      try {\n        _this3._currentCompilationSchemaInfo = schemaInfo;\n        validator = _this3._ajv.compile(schema);\n      } catch (e) {\n        // This should eventually be refactored so that we we handle race condition where the same schema is validated at the same time.\n        if (!(e instanceof ajv_1.default.MissingRefError)) {\n          throw e;\n        }\n\n        validator = yield _this3._ajv.compileAsync(schema);\n      } finally {\n        _this3._currentCompilationSchemaInfo = undefined;\n      }\n\n      return /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (data, options) {\n          var _a;\n\n          const validationOptions = {\n            withPrompts: true,\n            applyPostTransforms: true,\n            applyPreTransforms: true,\n            ...options\n          };\n          const validationContext = {\n            promptFieldsWithValue: new Set()\n          }; // Apply pre-validation transforms\n\n          if (validationOptions.applyPreTransforms) {\n            for (const visitor of _this3._pre.values()) {\n              data = yield (0, visitor_1.visitJson)(data, visitor, schema, _this3._resolver.bind(_this3), validator).toPromise();\n            }\n          } // Apply smart defaults\n\n\n          yield _this3._applySmartDefaults(data, schemaInfo.smartDefaultRecord); // Apply prompts\n\n          if (validationOptions.withPrompts) {\n            const visitor = (value, pointer) => {\n              if (value !== undefined) {\n                validationContext.promptFieldsWithValue.add(pointer);\n              }\n\n              return value;\n            };\n\n            if (typeof schema === 'object') {\n              yield (0, visitor_1.visitJson)(data, visitor, schema, _this3._resolver.bind(_this3), validator).toPromise();\n            }\n\n            const definitions = schemaInfo.promptDefinitions.filter(def => !validationContext.promptFieldsWithValue.has(def.id));\n\n            if (definitions.length > 0) {\n              yield _this3._applyPrompts(data, definitions);\n            }\n          } // Validate using ajv\n\n\n          try {\n            const success = yield validator.call(validationContext, data);\n\n            if (!success) {\n              return {\n                data,\n                success,\n                errors: (_a = validator.errors) !== null && _a !== void 0 ? _a : []\n              };\n            }\n          } catch (error) {\n            if (error instanceof ajv_1.default.ValidationError) {\n              return {\n                data,\n                success: false,\n                errors: error.errors\n              };\n            }\n\n            throw error;\n          } // Apply post-validation transforms\n\n\n          if (validationOptions.applyPostTransforms) {\n            for (const visitor of _this3._post.values()) {\n              data = yield (0, visitor_1.visitJson)(data, visitor, schema, _this3._resolver.bind(_this3), validator).toPromise();\n            }\n          }\n\n          return {\n            data,\n            success: true\n          };\n        });\n\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n    })();\n  }\n\n  addFormat(format) {\n    this._ajv.addFormat(format.name, format.formatter);\n  }\n\n  addSmartDefaultProvider(source, provider) {\n    if (this._sourceMap.has(source)) {\n      throw new Error(source);\n    }\n\n    this._sourceMap.set(source, provider);\n\n    if (!this._smartDefaultKeyword) {\n      this._smartDefaultKeyword = true;\n\n      this._ajv.addKeyword({\n        keyword: '$default',\n        errors: false,\n        valid: true,\n        compile: (schema, _parentSchema, it) => {\n          const compilationSchemInfo = this._currentCompilationSchemaInfo;\n\n          if (compilationSchemInfo === undefined) {\n            return () => true;\n          } // We cheat, heavily.\n\n\n          const pathArray = this.normalizeDataPathArr(it);\n          compilationSchemInfo.smartDefaultRecord.set(JSON.stringify(pathArray), schema);\n          return () => true;\n        },\n        metaSchema: {\n          type: 'object',\n          properties: {\n            '$source': {\n              type: 'string'\n            }\n          },\n          additionalProperties: true,\n          required: ['$source']\n        }\n      });\n    }\n  }\n\n  registerUriHandler(handler) {\n    this._uriHandlers.add(handler);\n  }\n\n  usePromptProvider(provider) {\n    const isSetup = !!this._promptProvider;\n    this._promptProvider = provider;\n\n    if (isSetup) {\n      return;\n    }\n\n    this._ajv.addKeyword({\n      keyword: 'x-prompt',\n      errors: false,\n      valid: true,\n      compile: (schema, parentSchema, it) => {\n        const compilationSchemInfo = this._currentCompilationSchemaInfo;\n\n        if (!compilationSchemInfo) {\n          return () => true;\n        }\n\n        const path = '/' + this.normalizeDataPathArr(it).join('/');\n        let type;\n        let items;\n        let message;\n\n        if (typeof schema == 'string') {\n          message = schema;\n        } else {\n          message = schema.message;\n          type = schema.type;\n          items = schema.items;\n        }\n\n        const propertyTypes = (0, utility_1.getTypesOfSchema)(parentSchema);\n\n        if (!type) {\n          if (propertyTypes.size === 1 && propertyTypes.has('boolean')) {\n            type = 'confirmation';\n          } else if (Array.isArray(parentSchema.enum)) {\n            type = 'list';\n          } else if (propertyTypes.size === 1 && propertyTypes.has('array') && parentSchema.items && Array.isArray(parentSchema.items.enum)) {\n            type = 'list';\n          } else {\n            type = 'input';\n          }\n        }\n\n        let multiselect;\n\n        if (type === 'list') {\n          multiselect = schema.multiselect === undefined ? propertyTypes.size === 1 && propertyTypes.has('array') : schema.multiselect;\n          const enumValues = multiselect ? parentSchema.items && parentSchema.items.enum : parentSchema.enum;\n\n          if (!items && Array.isArray(enumValues)) {\n            items = [];\n\n            for (const value of enumValues) {\n              if (typeof value == 'string') {\n                items.push(value);\n              } else if (typeof value == 'object') {// Invalid\n              } else {\n                items.push({\n                  label: value.toString(),\n                  value\n                });\n              }\n            }\n          }\n        }\n\n        const definition = {\n          id: path,\n          type,\n          message,\n          raw: schema,\n          items,\n          multiselect,\n          propertyTypes,\n          default: typeof parentSchema.default == 'object' && parentSchema.default !== null && !Array.isArray(parentSchema.default) ? undefined : parentSchema.default,\n\n          validator(data) {\n            return _asyncToGenerator(function* () {\n              var _a;\n\n              try {\n                const result = yield it.self.validate(parentSchema, data); // If the schema is sync then false will be returned on validation failure\n\n                if (result) {\n                  return result;\n                } else if ((_a = it.self.errors) === null || _a === void 0 ? void 0 : _a.length) {\n                  // Validation errors will be present on the Ajv instance when sync\n                  return it.self.errors[0].message;\n                }\n              } catch (e) {\n                const validationError = e; // If the schema is async then an error will be thrown on validation failure\n\n                if (Array.isArray(validationError.errors) && validationError.errors.length) {\n                  return validationError.errors[0].message;\n                }\n              }\n\n              return false;\n            })();\n          }\n\n        };\n        compilationSchemInfo.promptDefinitions.push(definition);\n        return function () {\n          // If 'this' is undefined in the call, then it defaults to the global\n          // 'this'.\n          if (this && this.promptFieldsWithValue) {\n            this.promptFieldsWithValue.add(path);\n          }\n\n          return true;\n        };\n      },\n      metaSchema: {\n        oneOf: [{\n          type: 'string'\n        }, {\n          type: 'object',\n          properties: {\n            'type': {\n              type: 'string'\n            },\n            'message': {\n              type: 'string'\n            }\n          },\n          additionalProperties: true,\n          required: ['message']\n        }]\n      }\n    });\n  }\n\n  _applyPrompts(data, prompts) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const provider = _this4._promptProvider;\n\n      if (!provider) {\n        return;\n      }\n\n      const answers = yield (0, rxjs_1.from)(provider(prompts)).toPromise();\n\n      for (const path in answers) {\n        const pathFragments = path.split('/').slice(1);\n\n        CoreSchemaRegistry._set(data, pathFragments, answers[path], null, undefined, true);\n      }\n    })();\n  }\n\n  static _set( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data, fragments, value, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parent = null, parentProperty, force) {\n    for (let index = 0; index < fragments.length; index++) {\n      const fragment = fragments[index];\n\n      if (/^i\\d+$/.test(fragment)) {\n        if (!Array.isArray(data)) {\n          return;\n        }\n\n        for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {\n          CoreSchemaRegistry._set(data[dataIndex], fragments.slice(index + 1), value, data, `${dataIndex}`);\n        }\n\n        return;\n      }\n\n      if (!data && parent !== null && parentProperty) {\n        data = parent[parentProperty] = {};\n      }\n\n      parent = data;\n      parentProperty = fragment;\n      data = data[fragment];\n    }\n\n    if (parent && parentProperty && (force || parent[parentProperty] === undefined)) {\n      parent[parentProperty] = value;\n    }\n  }\n\n  _applySmartDefaults(data, smartDefaults) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const [pointer, schema] of smartDefaults.entries()) {\n        const fragments = JSON.parse(pointer);\n\n        const source = _this5._sourceMap.get(schema.$source);\n\n        if (!source) {\n          continue;\n        }\n\n        let value = source(schema);\n\n        if ((0, rxjs_1.isObservable)(value)) {\n          value = yield value.toPromise();\n        }\n\n        CoreSchemaRegistry._set(data, fragments, value);\n      }\n    })();\n  }\n\n  useXDeprecatedProvider(onUsage) {\n    this._ajv.addKeyword({\n      keyword: 'x-deprecated',\n      validate: (schema, _data, _parentSchema, dataCxt) => {\n        if (schema) {\n          onUsage(`Option \"${dataCxt === null || dataCxt === void 0 ? void 0 : dataCxt.parentDataProperty}\" is deprecated${typeof schema == 'string' ? ': ' + schema : '.'}`);\n        }\n\n        return true;\n      },\n      errors: false\n    });\n  }\n\n  normalizeDataPathArr(it) {\n    return it.dataPathArr.slice(1, it.dataLevel + 1).map(p => typeof p === 'number' ? p : p.str.replace(/\"/g, ''));\n  }\n\n}\n\nexports.CoreSchemaRegistry = CoreSchemaRegistry;","map":null,"metadata":{},"sourceType":"script"}