{"ast":null,"code":"// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE\n} = require('../errors.js');\n\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = require('os');\n\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes\n} = require('../fs.js');\n\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath\n} = require('path');\n\nconst {\n  fileURLToPath\n} = require('url');\n\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false\n};\n\nfunction cp(_x, _x2, _x3) {\n  return _cp.apply(this, arguments);\n}\n\nfunction _cp() {\n  _cp = _asyncToGenerator(function* (src, dest, opts) {\n    if (opts != null && typeof opts !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts);\n    }\n\n    return cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), { ...defaultOptions,\n      ...opts\n    });\n  });\n  return _cp.apply(this, arguments);\n}\n\nfunction getValidatedPath(fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;\n  return path;\n}\n\nfunction cpFn(_x4, _x5, _x6) {\n  return _cpFn.apply(this, arguments);\n}\n\nfunction _cpFn() {\n  _cpFn = _asyncToGenerator(function* (src, dest, opts) {\n    // Warn about using preserveTimestamps on 32-bit node\n    // istanbul ignore next\n    if (opts.preserveTimestamps && process.arch === 'ia32') {\n      const warning = 'Using the preserveTimestamps option in 32-bit ' + 'node is not recommended';\n      process.emitWarning(warning, 'TimestampPrecisionWarning');\n    }\n\n    const stats = yield checkPaths(src, dest, opts);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n    yield checkParentPaths(src, srcStat, dest);\n\n    if (opts.filter) {\n      return handleFilter(checkParentDir, destStat, src, dest, opts);\n    }\n\n    return checkParentDir(destStat, src, dest, opts);\n  });\n  return _cpFn.apply(this, arguments);\n}\n\nfunction checkPaths(_x7, _x8, _x9) {\n  return _checkPaths.apply(this, arguments);\n}\n\nfunction _checkPaths() {\n  _checkPaths = _asyncToGenerator(function* (src, dest, opts) {\n    const {\n      0: srcStat,\n      1: destStat\n    } = yield getStats(src, dest, opts);\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        throw new ERR_FS_CP_EINVAL({\n          message: 'src and dest cannot be the same',\n          path: dest,\n          syscall: 'cp',\n          errno: EINVAL\n        });\n      }\n\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        throw new ERR_FS_CP_DIR_TO_NON_DIR({\n          message: `cannot overwrite directory ${src} ` + `with non-directory ${dest}`,\n          path: dest,\n          syscall: 'cp',\n          errno: EISDIR\n        });\n      }\n\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        throw new ERR_FS_CP_NON_DIR_TO_DIR({\n          message: `cannot overwrite non-directory ${src} ` + `with directory ${dest}`,\n          path: dest,\n          syscall: 'cp',\n          errno: ENOTDIR\n        });\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n\n    return {\n      srcStat,\n      destStat\n    };\n  });\n  return _checkPaths.apply(this, arguments);\n}\n\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\n\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => stat(file, {\n    bigint: true\n  }) : file => lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    // istanbul ignore next: unsure how to cover.\n    if (err.code === 'ENOENT') {\n      return null;\n    } // istanbul ignore next: unsure how to cover.\n\n\n    throw err;\n  })]);\n}\n\nfunction checkParentDir(_x10, _x11, _x12, _x13) {\n  return _checkParentDir.apply(this, arguments);\n}\n\nfunction _checkParentDir() {\n  _checkParentDir = _asyncToGenerator(function* (destStat, src, dest, opts) {\n    const destParent = dirname(dest);\n    const dirExists = yield pathExists(destParent);\n\n    if (dirExists) {\n      return getStatsForCopy(destStat, src, dest, opts);\n    }\n\n    yield mkdir(destParent, {\n      recursive: true\n    });\n    return getStatsForCopy(destStat, src, dest, opts);\n  });\n  return _checkParentDir.apply(this, arguments);\n}\n\nfunction pathExists(dest) {\n  return stat(dest).then(() => true, // istanbul ignore next: not sure when this would occur\n  err => err.code === 'ENOENT' ? false : Promise.reject(err));\n} // Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\n\n\nfunction checkParentPaths(_x14, _x15, _x16) {\n  return _checkParentPaths.apply(this, arguments);\n}\n\nfunction _checkParentPaths() {\n  _checkParentPaths = _asyncToGenerator(function* (src, srcStat, dest) {\n    const srcParent = resolve(dirname(src));\n    const destParent = resolve(dirname(dest));\n\n    if (destParent === srcParent || destParent === parse(destParent).root) {\n      return;\n    }\n\n    let destStat;\n\n    try {\n      destStat = yield stat(destParent, {\n        bigint: true\n      });\n    } catch (err) {\n      // istanbul ignore else: not sure when this would occur\n      if (err.code === 'ENOENT') {\n        return;\n      } // istanbul ignore next: not sure when this would occur\n\n\n      throw err;\n    }\n\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n\n    return checkParentPaths(src, srcStat, destParent);\n  });\n  return _checkParentPaths.apply(this, arguments);\n}\n\nconst normalizePathToArray = path => resolve(path).split(sep).filter(Boolean); // Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\n\n\nfunction isSrcSubdir(src, dest) {\n  const srcArr = normalizePathToArray(src);\n  const destArr = normalizePathToArray(dest);\n  return srcArr.every((cur, i) => destArr[i] === cur);\n}\n\nfunction handleFilter(_x17, _x18, _x19, _x20, _x21, _x22) {\n  return _handleFilter.apply(this, arguments);\n}\n\nfunction _handleFilter() {\n  _handleFilter = _asyncToGenerator(function* (onInclude, destStat, src, dest, opts, cb) {\n    const include = yield opts.filter(src, dest);\n\n    if (include) {\n      return onInclude(destStat, src, dest, opts, cb);\n    }\n  });\n  return _handleFilter.apply(this, arguments);\n}\n\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts);\n  }\n\n  return getStatsForCopy(destStat, src, dest, opts);\n}\n\nfunction getStatsForCopy(_x23, _x24, _x25, _x26) {\n  return _getStatsForCopy.apply(this, arguments);\n}\n\nfunction _getStatsForCopy() {\n  _getStatsForCopy = _asyncToGenerator(function* (destStat, src, dest, opts) {\n    const statFn = opts.dereference ? stat : lstat;\n    const srcStat = yield statFn(src); // istanbul ignore else: can't portably test FIFO\n\n    if (srcStat.isDirectory() && opts.recursive) {\n      return onDir(srcStat, destStat, src, dest, opts);\n    } else if (srcStat.isDirectory()) {\n      throw new ERR_FS_EISDIR({\n        message: `${src} is a directory (not copied)`,\n        path: src,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n      return onFile(srcStat, destStat, src, dest, opts);\n    } else if (srcStat.isSymbolicLink()) {\n      return onLink(destStat, src, dest);\n    } else if (srcStat.isSocket()) {\n      throw new ERR_FS_CP_SOCKET({\n        message: `cannot copy a socket file: ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } else if (srcStat.isFIFO()) {\n      throw new ERR_FS_CP_FIFO_PIPE({\n        message: `cannot copy a FIFO pipe: ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } // istanbul ignore next: should be unreachable\n\n\n    throw new ERR_FS_CP_UNKNOWN({\n      message: `cannot copy an unknown file type: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  });\n  return _getStatsForCopy.apply(this, arguments);\n}\n\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts);\n  }\n\n  return mayCopyFile(srcStat, src, dest, opts);\n}\n\nfunction mayCopyFile(_x27, _x28, _x29, _x30) {\n  return _mayCopyFile.apply(this, arguments);\n}\n\nfunction _mayCopyFile() {\n  _mayCopyFile = _asyncToGenerator(function* (srcStat, src, dest, opts) {\n    if (opts.force) {\n      yield unlink(dest);\n      return _copyFile(srcStat, src, dest, opts);\n    } else if (opts.errorOnExist) {\n      throw new ERR_FS_CP_EEXIST({\n        message: `${dest} already exists`,\n        path: dest,\n        syscall: 'cp',\n        errno: EEXIST\n      });\n    }\n  });\n  return _mayCopyFile.apply(this, arguments);\n}\n\nfunction _copyFile(_x31, _x32, _x33, _x34) {\n  return _copyFile2.apply(this, arguments);\n}\n\nfunction _copyFile2() {\n  _copyFile2 = _asyncToGenerator(function* (srcStat, src, dest, opts) {\n    yield copyFile(src, dest);\n\n    if (opts.preserveTimestamps) {\n      return handleTimestampsAndMode(srcStat.mode, src, dest);\n    }\n\n    return setDestMode(dest, srcStat.mode);\n  });\n  return _copyFile2.apply(this, arguments);\n}\n\nfunction handleTimestampsAndMode(_x35, _x36, _x37) {\n  return _handleTimestampsAndMode.apply(this, arguments);\n}\n\nfunction _handleTimestampsAndMode() {\n  _handleTimestampsAndMode = _asyncToGenerator(function* (srcMode, src, dest) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcMode)) {\n      yield makeFileWritable(dest, srcMode);\n      return setDestTimestampsAndMode(srcMode, src, dest);\n    }\n\n    return setDestTimestampsAndMode(srcMode, src, dest);\n  });\n  return _handleTimestampsAndMode.apply(this, arguments);\n}\n\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\n\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\n\nfunction setDestTimestampsAndMode(_x38, _x39, _x40) {\n  return _setDestTimestampsAndMode.apply(this, arguments);\n}\n\nfunction _setDestTimestampsAndMode() {\n  _setDestTimestampsAndMode = _asyncToGenerator(function* (srcMode, src, dest) {\n    yield setDestTimestamps(src, dest);\n    return setDestMode(dest, srcMode);\n  });\n  return _setDestTimestampsAndMode.apply(this, arguments);\n}\n\nfunction setDestMode(dest, srcMode) {\n  return chmod(dest, srcMode);\n}\n\nfunction setDestTimestamps(_x41, _x42) {\n  return _setDestTimestamps.apply(this, arguments);\n}\n\nfunction _setDestTimestamps() {\n  _setDestTimestamps = _asyncToGenerator(function* (src, dest) {\n    // The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = yield stat(src);\n    return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  });\n  return _setDestTimestamps.apply(this, arguments);\n}\n\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  }\n\n  return copyDir(src, dest, opts);\n}\n\nfunction mkDirAndCopy(_x43, _x44, _x45, _x46) {\n  return _mkDirAndCopy.apply(this, arguments);\n}\n\nfunction _mkDirAndCopy() {\n  _mkDirAndCopy = _asyncToGenerator(function* (srcMode, src, dest, opts) {\n    yield mkdir(dest);\n    yield copyDir(src, dest, opts);\n    return setDestMode(dest, srcMode);\n  });\n  return _mkDirAndCopy.apply(this, arguments);\n}\n\nfunction copyDir(_x47, _x48, _x49) {\n  return _copyDir.apply(this, arguments);\n}\n\nfunction _copyDir() {\n  _copyDir = _asyncToGenerator(function* (src, dest, opts) {\n    const dir = yield readdir(src);\n\n    for (let i = 0; i < dir.length; i++) {\n      const item = dir[i];\n      const srcItem = join(src, item);\n      const destItem = join(dest, item);\n      const {\n        destStat\n      } = yield checkPaths(srcItem, destItem, opts);\n      yield startCopy(destStat, srcItem, destItem, opts);\n    }\n  });\n  return _copyDir.apply(this, arguments);\n}\n\nfunction onLink(_x50, _x51, _x52) {\n  return _onLink.apply(this, arguments);\n}\n\nfunction _onLink() {\n  _onLink = _asyncToGenerator(function* (destStat, src, dest) {\n    let resolvedSrc = yield readlink(src);\n\n    if (!isAbsolute(resolvedSrc)) {\n      resolvedSrc = resolve(dirname(src), resolvedSrc);\n    }\n\n    if (!destStat) {\n      return symlink(resolvedSrc, dest);\n    }\n\n    let resolvedDest;\n\n    try {\n      resolvedDest = yield readlink(dest);\n    } catch (err) {\n      // Dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      // istanbul ignore next: can only test on windows\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n        return symlink(resolvedSrc, dest);\n      } // istanbul ignore next: should not be possible\n\n\n      throw err;\n    }\n\n    if (!isAbsolute(resolvedDest)) {\n      resolvedDest = resolve(dirname(dest), resolvedDest);\n    }\n\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${resolvedSrc} to a subdirectory of self ` + `${resolvedDest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } // Do not copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n\n\n    const srcStat = yield stat(src);\n\n    if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n        message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n\n    return copyLink(resolvedSrc, dest);\n  });\n  return _onLink.apply(this, arguments);\n}\n\nfunction copyLink(_x53, _x54) {\n  return _copyLink.apply(this, arguments);\n}\n\nfunction _copyLink() {\n  _copyLink = _asyncToGenerator(function* (resolvedSrc, dest) {\n    yield unlink(dest);\n    return symlink(resolvedSrc, dest);\n  });\n  return _copyLink.apply(this, arguments);\n}\n\nmodule.exports = cp;","map":null,"metadata":{},"sourceType":"script"}