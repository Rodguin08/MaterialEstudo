{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeSchemas = exports.isJsonSchema = void 0;\n\nconst utils_1 = require(\"../utils\");\n\nfunction isJsonSchema(value) {\n  return (0, utils_1.isJsonObject)(value) || value === false || value === true;\n}\n\nexports.isJsonSchema = isJsonSchema;\n/**\n * Return a schema that is the merge of all subschemas, ie. it should validate all the schemas\n * that were passed in. It is possible to make an invalid schema this way, e.g. by using\n * `mergeSchemas({ type: 'number' }, { type: 'string' })`, which will never validate.\n * @param schemas All schemas to be merged.\n */\n\nfunction mergeSchemas(...schemas) {\n  return schemas.reduce((prev, curr) => {\n    if (curr === undefined) {\n      return prev;\n    }\n\n    if (prev === false || curr === false) {\n      return false;\n    } else if (prev === true) {\n      return curr;\n    } else if (curr === true) {\n      return prev;\n    } else if (Array.isArray(prev.allOf)) {\n      if (Array.isArray(curr.allOf)) {\n        return { ...prev,\n          allOf: [...prev.allOf, ...curr.allOf]\n        };\n      } else {\n        return { ...prev,\n          allOf: [...prev.allOf, curr]\n        };\n      }\n    } else if (Array.isArray(curr.allOf)) {\n      return { ...prev,\n        allOf: [prev, ...curr.allOf]\n      };\n    } else {\n      return { ...prev,\n        allOf: [prev, curr]\n      };\n    }\n  }, true);\n}\n\nexports.mergeSchemas = mergeSchemas;","map":null,"metadata":{},"sourceType":"script"}