{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNpmPackageJson = exports.fetchPackageManifest = exports.fetchPackageMetadata = void 0;\n\nconst lockfile = __importStar( /*#__PURE__*/require(\"@yarnpkg/lockfile\"));\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst ini = __importStar( /*#__PURE__*/require(\"ini\"));\n\nconst os_1 = /*#__PURE__*/require(\"os\");\n\nconst path = __importStar( /*#__PURE__*/require(\"path\"));\n\nlet npmrc;\nconst npmPackageJsonCache = /*#__PURE__*/new Map();\n\nfunction ensureNpmrc(logger, usingYarn, verbose) {\n  if (!npmrc) {\n    try {\n      npmrc = readOptions(logger, false, verbose);\n    } catch {}\n\n    if (usingYarn) {\n      try {\n        npmrc = { ...npmrc,\n          ...readOptions(logger, true, verbose)\n        };\n      } catch {}\n    }\n  }\n}\n\nfunction readOptions(logger, yarn = false, showPotentials = false) {\n  const cwd = process.cwd();\n  const baseFilename = yarn ? 'yarnrc' : 'npmrc';\n  const dotFilename = '.' + baseFilename;\n  let globalPrefix;\n\n  if (process.env.PREFIX) {\n    globalPrefix = process.env.PREFIX;\n  } else {\n    globalPrefix = path.dirname(process.execPath);\n\n    if (process.platform !== 'win32') {\n      globalPrefix = path.dirname(globalPrefix);\n    }\n  }\n\n  const defaultConfigLocations = [!yarn && process.env.NPM_CONFIG_GLOBALCONFIG || path.join(globalPrefix, 'etc', baseFilename), !yarn && process.env.NPM_CONFIG_USERCONFIG || path.join((0, os_1.homedir)(), dotFilename)];\n  const projectConfigLocations = [path.join(cwd, dotFilename)];\n\n  if (yarn) {\n    const root = path.parse(cwd).root;\n\n    for (let curDir = path.dirname(cwd); curDir && curDir !== root; curDir = path.dirname(curDir)) {\n      projectConfigLocations.unshift(path.join(curDir, dotFilename));\n    }\n  }\n\n  if (showPotentials) {\n    logger.info(`Locating potential ${baseFilename} files:`);\n  }\n\n  let rcOptions = {};\n\n  for (const location of [...defaultConfigLocations, ...projectConfigLocations]) {\n    if ((0, fs_1.existsSync)(location)) {\n      if (showPotentials) {\n        logger.info(`Trying '${location}'...found.`);\n      }\n\n      const data = (0, fs_1.readFileSync)(location, 'utf8'); // Normalize RC options that are needed by 'npm-registry-fetch'.\n      // See: https://github.com/npm/npm-registry-fetch/blob/ebddbe78a5f67118c1f7af2e02c8a22bcaf9e850/index.js#L99-L126\n\n      const rcConfig = yarn ? lockfile.parse(data) : ini.parse(data);\n      rcOptions = normalizeOptions(rcConfig, location, rcOptions);\n    }\n  }\n\n  const envVariablesOptions = {};\n\n  for (const [key, value] of Object.entries(process.env)) {\n    if (!value) {\n      continue;\n    }\n\n    let normalizedName = key.toLowerCase();\n\n    if (normalizedName.startsWith('npm_config_')) {\n      normalizedName = normalizedName.substring(11);\n    } else if (yarn && normalizedName.startsWith('yarn_')) {\n      normalizedName = normalizedName.substring(5);\n    } else {\n      continue;\n    }\n\n    normalizedName = normalizedName.replace(/(?!^)_/g, '-'); // don't replace _ at the start of the key.s\n\n    envVariablesOptions[normalizedName] = value;\n  }\n\n  return normalizeOptions(envVariablesOptions, undefined, rcOptions);\n}\n\nfunction normalizeOptions(rawOptions, location = process.cwd(), existingNormalizedOptions = {}) {\n  var _a;\n\n  const options = { ...existingNormalizedOptions\n  };\n\n  for (const [key, value] of Object.entries(rawOptions)) {\n    let substitutedValue = value; // Substitute any environment variable references.\n\n    if (typeof value === 'string') {\n      substitutedValue = value.replace(/\\$\\{([^}]+)\\}/, (_, name) => process.env[name] || '');\n    }\n\n    switch (key) {\n      // Unless auth options are scope with the registry url it appears that npm-registry-fetch ignores them,\n      // even though they are documented.\n      // https://github.com/npm/npm-registry-fetch/blob/8954f61d8d703e5eb7f3d93c9b40488f8b1b62ac/README.md\n      // https://github.com/npm/npm-registry-fetch/blob/8954f61d8d703e5eb7f3d93c9b40488f8b1b62ac/auth.js#L45-L91\n      case '_authToken':\n      case 'token':\n      case 'username':\n      case 'password':\n      case '_auth':\n      case 'auth':\n        (_a = options['forceAuth']) !== null && _a !== void 0 ? _a : options['forceAuth'] = {};\n        options['forceAuth'][key] = substitutedValue;\n        break;\n\n      case 'noproxy':\n      case 'no-proxy':\n        options['noProxy'] = substitutedValue;\n        break;\n\n      case 'maxsockets':\n        options['maxSockets'] = substitutedValue;\n        break;\n\n      case 'https-proxy':\n      case 'proxy':\n        options['proxy'] = substitutedValue;\n        break;\n\n      case 'strict-ssl':\n        options['strictSSL'] = substitutedValue;\n        break;\n\n      case 'local-address':\n        options['localAddress'] = substitutedValue;\n        break;\n\n      case 'cafile':\n        if (typeof substitutedValue === 'string') {\n          const cafile = path.resolve(path.dirname(location), substitutedValue);\n\n          try {\n            options['ca'] = (0, fs_1.readFileSync)(cafile, 'utf8').replace(/\\r?\\n/g, '\\n');\n          } catch {}\n        }\n\n        break;\n\n      default:\n        options[key] = substitutedValue;\n        break;\n    }\n  }\n\n  return options;\n}\n\nfunction fetchPackageMetadata(_x, _x2, _x3) {\n  return _fetchPackageMetadata.apply(this, arguments);\n}\n\nfunction _fetchPackageMetadata() {\n  _fetchPackageMetadata = _asyncToGenerator(function* (name, logger, options) {\n    const {\n      usingYarn,\n      verbose,\n      registry\n    } = {\n      registry: undefined,\n      usingYarn: false,\n      verbose: false,\n      ...options\n    };\n    ensureNpmrc(logger, usingYarn, verbose);\n    const {\n      packument\n    } = yield Promise.resolve().then(() => __importStar(require('pacote')));\n    const response = yield packument(name, {\n      fullMetadata: true,\n      ...npmrc,\n      ...(registry ? {\n        registry\n      } : {})\n    }); // Normalize the response\n\n    const metadata = { ...response,\n      tags: {}\n    };\n\n    if (response['dist-tags']) {\n      for (const [tag, version] of Object.entries(response['dist-tags'])) {\n        const manifest = metadata.versions[version];\n\n        if (manifest) {\n          metadata.tags[tag] = manifest;\n        } else if (verbose) {\n          logger.warn(`Package ${metadata.name} has invalid version metadata for '${tag}'.`);\n        }\n      }\n    }\n\n    return metadata;\n  });\n  return _fetchPackageMetadata.apply(this, arguments);\n}\n\nexports.fetchPackageMetadata = fetchPackageMetadata;\n\nfunction fetchPackageManifest(_x4, _x5) {\n  return _fetchPackageManifest.apply(this, arguments);\n}\n\nfunction _fetchPackageManifest() {\n  _fetchPackageManifest = _asyncToGenerator(function* (name, logger, options = {}) {\n    const {\n      usingYarn = false,\n      verbose = false,\n      registry\n    } = options;\n    ensureNpmrc(logger, usingYarn, verbose);\n    const {\n      manifest\n    } = yield Promise.resolve().then(() => __importStar(require('pacote')));\n    const response = yield manifest(name, {\n      fullMetadata: true,\n      ...npmrc,\n      ...(registry ? {\n        registry\n      } : {})\n    });\n    return response;\n  });\n  return _fetchPackageManifest.apply(this, arguments);\n}\n\nexports.fetchPackageManifest = fetchPackageManifest;\n\nfunction getNpmPackageJson(_x6, _x7) {\n  return _getNpmPackageJson.apply(this, arguments);\n}\n\nfunction _getNpmPackageJson() {\n  _getNpmPackageJson = _asyncToGenerator(function* (packageName, logger, options = {}) {\n    const cachedResponse = npmPackageJsonCache.get(packageName);\n\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    const {\n      usingYarn = false,\n      verbose = false,\n      registry\n    } = options;\n    ensureNpmrc(logger, usingYarn, verbose);\n    const {\n      packument\n    } = yield Promise.resolve().then(() => __importStar(require('pacote')));\n    const resultPromise = packument(packageName, {\n      fullMetadata: true,\n      ...npmrc,\n      ...(registry ? {\n        registry\n      } : {})\n    }); // TODO: find some way to test this\n\n    const response = resultPromise.catch(err => {\n      logger.warn(err.message || err);\n      return {\n        requestedName: packageName\n      };\n    });\n    npmPackageJsonCache.set(packageName, response);\n    return response;\n  });\n  return _getNpmPackageJson.apply(this, arguments);\n}\n\nexports.getNpmPackageJson = getNpmPackageJson;","map":null,"metadata":{},"sourceType":"script"}