{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst Minipass = require('minipass');\n\nconst tarCreateOptions = require('./util/tar-create-options.js');\n\nconst packlist = require('npm-packlist');\n\nconst tar = require('tar');\n\nconst _prepareDir = Symbol('_prepareDir');\n\nconst {\n  resolve\n} = require('path');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\n\nconst runScript = require('@npmcli/run-script');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nclass DirFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // just the fully resolved filename\n\n    this.resolved = this.spec.fetchSpec;\n  } // exposes tarCreateOptions as public API\n\n\n  static tarCreateOptions(manifest) {\n    return tarCreateOptions(manifest);\n  }\n\n  get types() {\n    return ['directory'];\n  }\n\n  [_prepareDir]() {\n    return this.manifest().then(mani => {\n      if (!mani.scripts || !mani.scripts.prepare) {\n        return;\n      } // we *only* run prepare.\n      // pre/post-pack is run by the npm CLI for publish and pack,\n      // but this function is *also* run when installing git deps\n\n\n      const stdio = this.opts.foregroundScripts ? 'inherit' : 'pipe'; // hide the banner if silent opt is passed in, or if prepare running\n      // in the background.\n\n      const banner = this.opts.silent ? false : stdio === 'inherit';\n      return runScript({\n        pkg: mani,\n        event: 'prepare',\n        path: this.resolved,\n        stdioString: true,\n        stdio,\n        banner,\n        env: {\n          npm_package_resolved: this.resolved,\n          npm_package_integrity: this.integrity,\n          npm_package_json: resolve(this.resolved, 'package.json')\n        }\n      });\n    });\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.integrity = this.integrity;\n    const {\n      prefix,\n      workspaces\n    } = this.opts; // run the prepare script, get the list of files, and tar it up\n    // pipe to the stream, and proxy errors the chain.\n\n    this[_prepareDir]().then(() => packlist({\n      path: this.resolved,\n      prefix,\n      workspaces\n    })).then(files => tar.c(tarCreateOptions(this.package), files).on('error', er => stream.emit('error', er)).pipe(stream)).catch(er => stream.emit('error', er));\n\n    return stream;\n  }\n\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    }\n\n    return this[_readPackageJson](this.resolved + '/package.json').then(mani => this.package = { ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    });\n  }\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n}\n\nmodule.exports = DirFetcher;","map":null,"metadata":{},"sourceType":"script"}