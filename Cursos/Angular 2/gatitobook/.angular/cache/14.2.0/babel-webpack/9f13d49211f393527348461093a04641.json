{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _asyncIterator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n\nvar _awaitAsyncGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\n\nvar _wrapAsyncGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenerateCommandModule = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst command_module_1 = /*#__PURE__*/require(\"../../command-builder/command-module\");\n\nconst schematics_command_module_1 = /*#__PURE__*/require(\"../../command-builder/schematics-command-module\");\n\nconst command_1 = /*#__PURE__*/require(\"../../command-builder/utilities/command\");\n\nclass GenerateCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'generate';\n    this.aliases = 'g';\n    this.describe = 'Generates and/or modifies files based on a schematic.';\n  }\n\n  builder(argv) {\n    var _superprop_getBuilder = () => super.builder,\n        _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let localYargs = (yield _superprop_getBuilder().call(_this2, argv)).command({\n        command: '$0 <schematic>',\n        describe: 'Run the provided schematic.',\n        builder: localYargs => localYargs.positional('schematic', {\n          describe: 'The [collection:schematic] to run.',\n          type: 'string',\n          demandOption: true\n        }).strict(),\n        handler: options => _this2.handler(options)\n      });\n\n      for (const [schematicName, collectionName] of yield _this2.getSchematicsToRegister()) {\n        const workflow = _this2.getOrCreateWorkflowForBuilder(collectionName);\n\n        const collection = workflow.engine.createCollection(collectionName);\n        const {\n          description: {\n            schemaJson,\n            aliases: schematicAliases,\n            hidden: schematicHidden,\n            description: schematicDescription\n          }\n        } = collection.createSchematic(schematicName, true);\n\n        if (!schemaJson) {\n          continue;\n        }\n\n        const {\n          'x-deprecated': xDeprecated,\n          description = schematicDescription,\n          aliases = schematicAliases,\n          hidden = schematicHidden\n        } = schemaJson;\n        const options = yield _this2.getSchematicOptions(collection, schematicName, workflow);\n        localYargs = localYargs.command({\n          command: yield _this2.generateCommandString(collectionName, schematicName, options),\n          // When 'describe' is set to false, it results in a hidden command.\n          describe: hidden === true ? false : typeof description === 'string' ? description : '',\n          deprecated: xDeprecated === true || typeof xDeprecated === 'string' ? xDeprecated : false,\n          aliases: Array.isArray(aliases) ? aliases : undefined,\n          builder: localYargs => _this2.addSchemaOptionsToCommand(localYargs, options).strict(),\n          handler: options => _this2.handler({ ...options,\n            schematic: `${collectionName}:${schematicName}`\n          })\n        });\n      }\n\n      return localYargs.demandCommand(1, command_1.demandCommandFailureMessage);\n    })();\n  }\n\n  run(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        dryRun,\n        schematic,\n        defaults,\n        force,\n        interactive,\n        ...schematicOptions\n      } = options;\n\n      const [collectionName, schematicName] = _this3.parseSchematicInfo(schematic);\n\n      if (!collectionName || !schematicName) {\n        throw new command_module_1.CommandModuleError('A collection and schematic is required during execution.');\n      }\n\n      return _this3.runSchematic({\n        collectionName,\n        schematicName,\n        schematicOptions,\n        executionOptions: {\n          dryRun,\n          defaults,\n          force,\n          interactive\n        }\n      });\n    })();\n  }\n\n  getCollectionNames() {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const [collectionName] = _this4.parseSchematicInfo( // positional = [generate, component] or [generate]\n      _this4.context.args.positional[1]);\n\n      return collectionName ? [collectionName] : [...(yield _this4.getSchematicCollections())];\n    })();\n  }\n  /**\n   * Generate a command string to be passed to the command builder.\n   *\n   * @example `component [name]` or `@schematics/angular:component [name]`.\n   */\n\n\n  generateCommandString(collectionName, schematicName, options) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const [collectionNameFromArgs] = _this5.parseSchematicInfo( // positional = [generate, component] or [generate]\n      _this5.context.args.positional[1]);\n\n      const dasherizedSchematicName = core_1.strings.dasherize(schematicName);\n      const schematicCollectionsFromConfig = yield _this5.getSchematicCollections();\n      const collectionNames = yield _this5.getCollectionNames(); // Only add the collection name as part of the command when it's not a known\n      // schematics collection or when it has been provided via the CLI.\n      // Ex:`ng generate @schematics/angular:component`\n\n      const commandName = !!collectionNameFromArgs || !collectionNames.some(c => schematicCollectionsFromConfig.has(c)) ? collectionName + ':' + dasherizedSchematicName : dasherizedSchematicName;\n      const positionalArgs = options.filter(o => o.positional !== undefined).map(o => {\n        const label = `${core_1.strings.dasherize(o.name)}${o.type === 'array' ? ' ..' : ''}`;\n        return o.required ? `<${label}>` : `[${label}]`;\n      }).join(' ');\n      return `${commandName}${positionalArgs ? ' ' + positionalArgs : ''}`;\n    })();\n  }\n  /**\n   * Get schematics that can to be registered as subcommands.\n   */\n\n\n  getSchematics() {\n    var _this = this;\n\n    return _wrapAsyncGenerator(function* () {\n      const seenNames = new Set();\n\n      for (const collectionName of yield _awaitAsyncGenerator(_this.getCollectionNames())) {\n        const workflow = _this.getOrCreateWorkflowForBuilder(collectionName);\n\n        const collection = workflow.engine.createCollection(collectionName);\n\n        for (const schematicName of collection.listSchematicNames(true\n        /** includeHidden */\n        )) {\n          // If a schematic with this same name is already registered skip.\n          if (!seenNames.has(schematicName)) {\n            seenNames.add(schematicName);\n            yield {\n              schematicName,\n              collectionName\n            };\n          }\n        }\n      }\n    })();\n  }\n  /**\n   * Get schematics that should to be registered as subcommands.\n   *\n   * @returns a sorted list of schematic that needs to be registered as subcommands.\n   */\n\n\n  getSchematicsToRegister() {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const schematicsToRegister = [];\n\n      const [, schematicNameFromArgs] = _this6.parseSchematicInfo( // positional = [generate, component] or [generate]\n      _this6.context.args.positional[1]);\n\n      var _iteratorAbruptCompletion = false;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(_this6.getSchematics()), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n          const {\n            schematicName,\n            collectionName\n          } = _step.value;\n\n          if (schematicName === schematicNameFromArgs) {\n            return [[schematicName, collectionName]];\n          }\n\n          schematicsToRegister.push([schematicName, collectionName]);\n        } // Didn't find the schematic or no schematic name was provided Ex: `ng generate --help`.\n\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (_iteratorAbruptCompletion && _iterator.return != null) {\n            yield _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return schematicsToRegister.sort(([nameA], [nameB]) => nameA.localeCompare(nameB, undefined, {\n        sensitivity: 'accent'\n      }));\n    })();\n  }\n\n}\n\nexports.GenerateCommandModule = GenerateCommandModule;","map":null,"metadata":{},"sourceType":"script"}