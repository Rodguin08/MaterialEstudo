{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.template = exports.templateParser = void 0;\n\nconst source_map_1 = require(\"source-map\"); // Matches <%= expr %>. This does not support structural JavaScript (for/if/...).\n\n\nconst kInterpolateRe = /<%=([\\s\\S]+?)%>/g; // Matches <%# text %>. It's a comment and will be entirely ignored.\n\nconst kCommentRe = /<%#([\\s\\S]+?)%>/g; // Used to match template delimiters.\n// <%- expr %>: HTML escape the value.\n// <% ... %>: Structural template code.\n\nconst kEscapeRe = /<%-([\\s\\S]+?)%>/g;\nconst kEvaluateRe = /<%([\\s\\S]+?)%>/g;\n/** Used to map characters to HTML entities. */\n\nconst kHtmlEscapes = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '`': '&#96;'\n}; // Used to match HTML entities and HTML characters.\n\nconst reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');\n\nfunction _positionFor(content, offset) {\n  let line = 1;\n  let column = 0;\n\n  for (let i = 0; i < offset - 1; i++) {\n    if (content[i] == '\\n') {\n      line++;\n      column = 0;\n    } else {\n      column++;\n    }\n  }\n\n  return {\n    line,\n    column\n  };\n}\n/**\n * Given a source text (and a fileName), returns a TemplateAst.\n */\n\n\nfunction templateParser(sourceText, fileName) {\n  const children = []; // Compile the regexp to match each delimiter.\n\n  const reExpressions = [kEscapeRe, kCommentRe, kInterpolateRe, kEvaluateRe];\n  const reDelimiters = RegExp(reExpressions.map(x => x.source).join('|') + '|$', 'g');\n  const parsed = sourceText.split(reDelimiters);\n  let offset = 0; // Optimization that uses the fact that the end of a node is always the beginning of the next\n  // node, so we keep the positioning of the nodes in memory.\n\n  let start = _positionFor(sourceText, offset);\n\n  let end;\n  const increment = reExpressions.length + 1;\n\n  for (let i = 0; i < parsed.length; i += increment) {\n    const [content, escape, comment, interpolate, evaluate] = parsed.slice(i, i + increment);\n\n    if (content) {\n      end = _positionFor(sourceText, offset + content.length);\n      offset += content.length;\n      children.push({\n        kind: 'content',\n        content,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (escape) {\n      end = _positionFor(sourceText, offset + escape.length + 5);\n      offset += escape.length + 5;\n      children.push({\n        kind: 'escape',\n        expression: escape,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (comment) {\n      end = _positionFor(sourceText, offset + comment.length + 5);\n      offset += comment.length + 5;\n      children.push({\n        kind: 'comment',\n        text: comment,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (interpolate) {\n      end = _positionFor(sourceText, offset + interpolate.length + 5);\n      offset += interpolate.length + 5;\n      children.push({\n        kind: 'interpolate',\n        expression: interpolate,\n        start,\n        end\n      });\n      start = end;\n    }\n\n    if (evaluate) {\n      end = _positionFor(sourceText, offset + evaluate.length + 5);\n      offset += evaluate.length + 5;\n      children.push({\n        kind: 'evaluate',\n        expression: evaluate,\n        start,\n        end\n      });\n      start = end;\n    }\n  }\n\n  return {\n    fileName,\n    content: sourceText,\n    children\n  };\n}\n\nexports.templateParser = templateParser;\n/**\n * Fastest implementation of the templating algorithm. It only add strings and does not bother\n * with source maps.\n */\n\nfunction templateFast(ast, options) {\n  const module = options && options.module ? 'module.exports.default =' : '';\n  const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n  return `\n    return ${module} function(obj) {\n      obj || (obj = {});\n      let __t;\n      let __p = '';\n      const __escapes = ${JSON.stringify(kHtmlEscapes)};\n      const __escapesre = new RegExp('${reHtmlEscape}', 'g');\n\n      const __e = function(s) {\n        return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';\n      };\n      with (obj) {\n        ${ast.children.map(node => {\n    switch (node.kind) {\n      case 'content':\n        return `__p += ${JSON.stringify(node.content)};`;\n\n      case 'interpolate':\n        return `__p += ((__t = (${node.expression})) == null) ? '' : __t;`;\n\n      case 'escape':\n        return `__p += __e(${node.expression});`;\n\n      case 'evaluate':\n        return node.expression;\n    }\n  }).join('\\n')}\n      }\n\n      return __p;\n    };\n  `;\n}\n/**\n * Templating algorithm with source map support. The map is outputted as //# sourceMapUrl=...\n */\n\n\nfunction templateWithSourceMap(ast, options) {\n  const sourceUrl = ast.fileName;\n  const module = options && options.module ? 'module.exports.default =' : '';\n  const reHtmlEscape = reUnescapedHtml.source.replace(/[']/g, \"\\\\\\\\\\\\'\");\n  const preamble = new source_map_1.SourceNode(1, 0, sourceUrl, '').add(new source_map_1.SourceNode(1, 0, sourceUrl, [`return ${module} function(obj) {\\n`, '  obj || (obj = {});\\n', '  let __t;\\n', '  let __p = \"\";\\n', `  const __escapes = ${JSON.stringify(kHtmlEscapes)};\\n`, `  const __escapesre = new RegExp('${reHtmlEscape}', 'g');\\n`, `\\n`, `  const __e = function(s) { `, `    return s ? s.replace(__escapesre, function(key) { return __escapes[key]; }) : '';`, `  };\\n`, `  with (obj) {\\n`]));\n  const end = ast.children.length ? ast.children[ast.children.length - 1].end : {\n    line: 0,\n    column: 0\n  };\n  const nodes = ast.children.reduce((chunk, node) => {\n    let code = '';\n\n    switch (node.kind) {\n      case 'content':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p = __p'), ...node.content.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, '\\n    + ' + JSON.stringify(line + (i == arr.length - 1 ? '' : '\\n')));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ';\\n')];\n        break;\n\n      case 'interpolate':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += ((__t = '), ...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ') == null ? \"\" : __t);\\n')];\n        break;\n\n      case 'escape':\n        code = [new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, '__p += __e('), ...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, ');\\n')];\n        break;\n\n      case 'evaluate':\n        code = [...node.expression.split('\\n').map((line, i, arr) => {\n          return new source_map_1.SourceNode(node.start.line + i, i == 0 ? node.start.column : 0, sourceUrl, line + (i == arr.length - 1 ? '' : '\\n'));\n        }), new source_map_1.SourceNode(node.end.line, node.end.column, sourceUrl, '\\n')];\n        break;\n    }\n\n    return chunk.add(new source_map_1.SourceNode(node.start.line, node.start.column, sourceUrl, code));\n  }, preamble).add(new source_map_1.SourceNode(end.line, end.column, sourceUrl, ['  };\\n', '\\n', '  return __p;\\n', '}\\n']));\n  const code = nodes.toStringWithSourceMap({\n    file: sourceUrl,\n    sourceRoot: options && options.sourceRoot || '.'\n  }); // Set the source content in the source map, otherwise the sourceUrl is not enough\n  // to find the content.\n\n  code.map.setSourceContent(sourceUrl, ast.content);\n  return code.code + '\\n//# sourceMappingURL=data:application/json;base64,' + Buffer.from(code.map.toString()).toString('base64');\n}\n/**\n * An equivalent of EJS templates, which is based on John Resig's `tmpl` implementation\n * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js\n * (https://github.com/olado/doT).\n *\n * This version differs from lodash by removing support from ES6 quasi-literals, and making the\n * code slightly simpler to follow. It also does not depend on any third party, which is nice.\n *\n * Finally, it supports SourceMap, if you ever need to debug, which is super nice.\n *\n * @param content The template content.\n * @param options Optional Options. See TemplateOptions for more description.\n * @return {(input: T) => string} A function that accept an input object and returns the content\n *         of the template with the input applied.\n */\n\n\nfunction template(content, options) {\n  const sourceUrl = options && options.sourceURL || 'ejs';\n  const ast = templateParser(content, sourceUrl);\n  let source; // If there's no need for source map support, we revert back to the fast implementation.\n\n  if (options && options.sourceMap) {\n    source = templateWithSourceMap(ast, options);\n  } else {\n    source = templateFast(ast, options);\n  } // We pass a dummy module in case the module option is passed. If `module: true` is passed, we\n  // need to only use the source, not the function itself. Otherwise expect a module object to be\n  // passed, and we use that one.\n\n\n  const fn = Function('module', source);\n  const module = options && options.module ? options.module === true ? {\n    exports: {}\n  } : options.module : null;\n  const result = fn(module); // Provide the compiled function's source by its `toString` method or\n  // the `source` property as a convenience for inlining compiled templates.\n\n  result.source = source;\n  return result;\n}\n\nexports.template = template;","map":null,"metadata":{},"sourceType":"script"}