{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasGlobalCliInstall = exports.initializeAutocomplete = exports.considerSettingUpAutocompletion = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst child_process_1 = /*#__PURE__*/require(\"child_process\");\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst path = __importStar( /*#__PURE__*/require(\"path\"));\n\nconst process_1 = /*#__PURE__*/require(\"process\");\n\nconst color_1 = /*#__PURE__*/require(\"../utilities/color\");\n\nconst config_1 = /*#__PURE__*/require(\"../utilities/config\");\n\nconst environment_options_1 = /*#__PURE__*/require(\"../utilities/environment-options\");\n\nconst tty_1 = /*#__PURE__*/require(\"../utilities/tty\");\n\nconst error_1 = /*#__PURE__*/require(\"./error\");\n/**\n * Checks if it is appropriate to prompt the user to setup autocompletion. If not, does nothing. If\n * so prompts and sets up autocompletion for the user. Returns an exit code if the program should\n * terminate, otherwise returns `undefined`.\n * @returns an exit code if the program should terminate, undefined otherwise.\n */\n\n\nfunction considerSettingUpAutocompletion(_x, _x2) {\n  return _considerSettingUpAutocompletion.apply(this, arguments);\n}\n\nfunction _considerSettingUpAutocompletion() {\n  _considerSettingUpAutocompletion = _asyncToGenerator(function* (command, logger) {\n    // Check if we should prompt the user to setup autocompletion.\n    const completionConfig = yield getCompletionConfig();\n\n    if (!(yield shouldPromptForAutocompletionSetup(command, completionConfig))) {\n      return undefined; // Already set up or prompted previously, nothing to do.\n    } // Prompt the user and record their response.\n\n\n    const shouldSetupAutocompletion = yield promptForAutocompletion();\n\n    if (!shouldSetupAutocompletion) {\n      // User rejected the prompt and doesn't want autocompletion.\n      logger.info(`\nOk, you won't be prompted again. Should you change your mind, the following command will set up autocompletion for you:\n\n    ${color_1.colors.yellow(`ng completion`)}\n    `.trim()); // Save configuration to remember that the user was prompted and avoid prompting again.\n\n      yield setCompletionConfig({ ...completionConfig,\n        prompted: true\n      });\n      return undefined;\n    } // User accepted the prompt, set up autocompletion.\n\n\n    let rcFile;\n\n    try {\n      rcFile = yield initializeAutocomplete();\n    } catch (err) {\n      (0, error_1.assertIsError)(err); // Failed to set up autocompeletion, log the error and abort.\n\n      logger.error(err.message);\n      return 1;\n    } // Notify the user autocompletion was set up successfully.\n\n\n    logger.info(`\nAppended \\`source <(ng completion script)\\` to \\`${rcFile}\\`. Restart your terminal or run the following to autocomplete \\`ng\\` commands:\n\n    ${color_1.colors.yellow(`source <(ng completion script)`)}\n    `.trim());\n\n    if ((yield hasGlobalCliInstall()) === false) {\n      logger.warn('Setup completed successfully, but there does not seem to be a global install of the' + ' Angular CLI. For autocompletion to work, the CLI will need to be on your `$PATH`, which' + ' is typically done with the `-g` flag in `npm install -g @angular/cli`.' + '\\n\\n' + 'For more information, see https://angular.io/cli/completion#global-install');\n    } // Save configuration to remember that the user was prompted.\n\n\n    yield setCompletionConfig({ ...completionConfig,\n      prompted: true\n    });\n    return undefined;\n  });\n  return _considerSettingUpAutocompletion.apply(this, arguments);\n}\n\nexports.considerSettingUpAutocompletion = considerSettingUpAutocompletion;\n\nfunction getCompletionConfig() {\n  return _getCompletionConfig.apply(this, arguments);\n}\n\nfunction _getCompletionConfig() {\n  _getCompletionConfig = _asyncToGenerator(function* () {\n    var _a;\n\n    const wksp = yield (0, config_1.getWorkspace)('global');\n    return (_a = wksp === null || wksp === void 0 ? void 0 : wksp.getCli()) === null || _a === void 0 ? void 0 : _a['completion'];\n  });\n  return _getCompletionConfig.apply(this, arguments);\n}\n\nfunction setCompletionConfig(_x3) {\n  return _setCompletionConfig.apply(this, arguments);\n}\n\nfunction _setCompletionConfig() {\n  _setCompletionConfig = _asyncToGenerator(function* (config) {\n    var _a;\n\n    var _b;\n\n    const wksp = yield (0, config_1.getWorkspace)('global');\n\n    if (!wksp) {\n      throw new Error(`Could not find global workspace`);\n    }\n\n    (_a = (_b = wksp.extensions)['cli']) !== null && _a !== void 0 ? _a : _b['cli'] = {};\n    const cli = wksp.extensions['cli'];\n\n    if (!core_1.json.isJsonObject(cli)) {\n      throw new Error(`Invalid config found at ${wksp.filePath}. \\`extensions.cli\\` should be an object.`);\n    }\n\n    cli.completion = config;\n    yield wksp.save();\n  });\n  return _setCompletionConfig.apply(this, arguments);\n}\n\nfunction shouldPromptForAutocompletionSetup(_x4, _x5) {\n  return _shouldPromptForAutocompletionSetup.apply(this, arguments);\n}\n\nfunction _shouldPromptForAutocompletionSetup() {\n  _shouldPromptForAutocompletionSetup = _asyncToGenerator(function* (command, config) {\n    // Force whether or not to prompt for autocomplete to give an easy path for e2e testing to skip.\n    if (environment_options_1.forceAutocomplete !== undefined) {\n      return environment_options_1.forceAutocomplete;\n    } // Don't prompt on `ng update` or `ng completion`.\n\n\n    if (command === 'update' || command === 'completion') {\n      return false;\n    } // Non-interactive and continuous integration systems don't care about autocompletion.\n\n\n    if (!(0, tty_1.isTTY)()) {\n      return false;\n    } // Skip prompt if the user has already been prompted.\n\n\n    if (config === null || config === void 0 ? void 0 : config.prompted) {\n      return false;\n    } // `$HOME` variable is necessary to find RC files to modify.\n\n\n    const home = process_1.env['HOME'];\n\n    if (!home) {\n      return false;\n    } // Get possible RC files for the current shell.\n\n\n    const shell = process_1.env['SHELL'];\n\n    if (!shell) {\n      return false;\n    }\n\n    const rcFiles = getShellRunCommandCandidates(shell, home);\n\n    if (!rcFiles) {\n      return false; // Unknown shell.\n    } // Don't prompt if the user is missing a global CLI install. Autocompletion won't work after setup\n    // anyway and could be annoying for users running one-off commands via `npx` or using `npm start`.\n\n\n    if ((yield hasGlobalCliInstall()) === false) {\n      return false;\n    } // Check each RC file if they already use `ng completion script` in any capacity and don't prompt.\n\n\n    for (const rcFile of rcFiles) {\n      const contents = yield fs_1.promises.readFile(rcFile, 'utf-8').catch(() => undefined);\n\n      if (contents === null || contents === void 0 ? void 0 : contents.includes('ng completion script')) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n  return _shouldPromptForAutocompletionSetup.apply(this, arguments);\n}\n\nfunction promptForAutocompletion() {\n  return _promptForAutocompletion.apply(this, arguments);\n}\n/**\n * Sets up autocompletion for the user's terminal. This attempts to find the configuration file for\n * the current shell (`.bashrc`, `.zshrc`, etc.) and append a command which enables autocompletion\n * for the Angular CLI. Supports only Bash and Zsh. Returns whether or not it was successful.\n * @return The full path of the configuration file modified.\n */\n\n\nfunction _promptForAutocompletion() {\n  _promptForAutocompletion = _asyncToGenerator(function* () {\n    // Dynamically load `inquirer` so users don't have to pay the cost of parsing and executing it for\n    // the 99% of builds that *don't* prompt for autocompletion.\n    const {\n      prompt\n    } = yield Promise.resolve().then(() => __importStar(require('inquirer')));\n    const {\n      autocomplete\n    } = yield prompt([{\n      name: 'autocomplete',\n      type: 'confirm',\n      message: `\nWould you like to enable autocompletion? This will set up your terminal so pressing TAB while typing\nAngular CLI commands will show possible options and autocomplete arguments. (Enabling autocompletion\nwill modify configuration files in your home directory.)\n      `.split('\\n').join(' ').trim(),\n      default: true\n    }]);\n    return autocomplete;\n  });\n  return _promptForAutocompletion.apply(this, arguments);\n}\n\nfunction initializeAutocomplete() {\n  return _initializeAutocomplete.apply(this, arguments);\n}\n\nfunction _initializeAutocomplete() {\n  _initializeAutocomplete = _asyncToGenerator(function* () {\n    var _a, _b; // Get the currently active `$SHELL` and `$HOME` environment variables.\n\n\n    const shell = process_1.env['SHELL'];\n\n    if (!shell) {\n      throw new Error('`$SHELL` environment variable not set. Angular CLI autocompletion only supports Bash or' + \" Zsh. If you're on Windows, Cmd and Powershell don't support command autocompletion,\" + ' but Git Bash or Windows Subsystem for Linux should work, so please try again in one of' + ' those environments.');\n    }\n\n    const home = process_1.env['HOME'];\n\n    if (!home) {\n      throw new Error('`$HOME` environment variable not set. Setting up autocompletion modifies configuration files' + ' in the home directory and must be set.');\n    } // Get all the files we can add `ng completion` to which apply to the user's `$SHELL`.\n\n\n    const runCommandCandidates = getShellRunCommandCandidates(shell, home);\n\n    if (!runCommandCandidates) {\n      throw new Error(`Unknown \\`$SHELL\\` environment variable value (${shell}). Angular CLI autocompletion only supports Bash or Zsh.`);\n    } // Get the first file that already exists or fallback to a new file of the first candidate.\n\n\n    const candidates = yield Promise.allSettled(runCommandCandidates.map(rcFile => fs_1.promises.access(rcFile).then(() => rcFile)));\n    const rcFile = (_b = (_a = candidates.find(result => result.status === 'fulfilled')) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : runCommandCandidates[0]; // Append Angular autocompletion setup to RC file.\n\n    try {\n      yield fs_1.promises.appendFile(rcFile, '\\n\\n# Load Angular CLI autocompletion.\\nsource <(ng completion script)\\n');\n    } catch (err) {\n      (0, error_1.assertIsError)(err);\n      throw new Error(`Failed to append autocompletion setup to \\`${rcFile}\\`:\\n${err.message}`);\n    }\n\n    return rcFile;\n  });\n  return _initializeAutocomplete.apply(this, arguments);\n}\n\nexports.initializeAutocomplete = initializeAutocomplete;\n/** Returns an ordered list of possible candidates of RC files used by the given shell. */\n\nfunction getShellRunCommandCandidates(shell, home) {\n  if (shell.toLowerCase().includes('bash')) {\n    return ['.bashrc', '.bash_profile', '.profile'].map(file => path.join(home, file));\n  } else if (shell.toLowerCase().includes('zsh')) {\n    return ['.zshrc', '.zsh_profile', '.profile'].map(file => path.join(home, file));\n  } else {\n    return undefined;\n  }\n}\n/**\n * Returns whether the user has a global CLI install or `undefined` if this can't be determined.\n * Execution from `npx` is *not* considered a global CLI install.\n *\n * This does *not* mean the current execution is from a global CLI install, only that a global\n * install exists on the system.\n */\n\n\nfunction hasGlobalCliInstall() {\n  return _hasGlobalCliInstall.apply(this, arguments);\n}\n\nfunction _hasGlobalCliInstall() {\n  _hasGlobalCliInstall = _asyncToGenerator(function* () {\n    var _a; // List all binaries with the `ng` name on the user's `$PATH`.\n\n\n    const proc = (0, child_process_1.execFile)('which', ['-a', 'ng']);\n    let stdout = '';\n    (_a = proc.stdout) === null || _a === void 0 ? void 0 : _a.addListener('data', content => {\n      stdout += content;\n    });\n    const exitCode = yield new Promise(resolve => {\n      proc.addListener('exit', exitCode => {\n        resolve(exitCode);\n      });\n    });\n\n    switch (exitCode) {\n      case 0:\n        // Successfully listed all `ng` binaries on the `$PATH`. Look for at least one line which is a\n        // global install. We can't easily identify global installs, but local installs are typically\n        // placed in `node_modules/.bin` by NPM / Yarn. `npx` also currently caches files at\n        // `~/.npm/_npx/*/node_modules/.bin/`, so the same logic applies.\n        const lines = stdout.split('\\n').filter(line => line !== '');\n        const hasGlobalInstall = lines.some(line => {\n          // A binary is a local install if it is a direct child of a `node_modules/.bin/` directory.\n          const parent = path.parse(path.parse(line).dir);\n          const grandparent = path.parse(parent.dir);\n          const localInstall = grandparent.base === 'node_modules' && parent.base === '.bin';\n          return !localInstall;\n        });\n        return hasGlobalInstall;\n\n      case 1:\n        // No instances of `ng` on the user's `$PATH`.\n        return false;\n\n      case null:\n        // `which` was killed by a signal and did not exit gracefully. Maybe it hung or something else\n        // went very wrong, so treat this as inconclusive.\n        return undefined;\n\n      default:\n        // `which` returns exit code 2 if an invalid option is specified and `-a` doesn't appear to be\n        // supported on all systems. Other exit codes mean unknown errors occurred. Can't tell whether\n        // CLI is globally installed, so treat this as inconclusive.\n        return undefined;\n    }\n  });\n  return _hasGlobalCliInstall.apply(this, arguments);\n}\n\nexports.hasGlobalCliInstall = hasGlobalCliInstall;","map":null,"metadata":{},"sourceType":"script"}