{"ast":null,"code":"const isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';\n\nconst path = require('path');\n\nconst COLON = isWindows ? ';' : ':';\n\nconst isexe = require('isexe');\n\nconst getNotFoundError = cmd => Object.assign(new Error(`not found: ${cmd}`), {\n  code: 'ENOENT'\n});\n\nconst getPathInfo = (cmd, opt) => {\n  const colon = opt.colon || COLON; // If it has a slash, then we don't bother searching the pathenv.\n  // just check the file itself, and that's it.\n\n  const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [''] : [// windows always checks the cwd first\n  ...(isWindows ? [process.cwd()] : []), ...(opt.path || process.env.PATH ||\n  /* istanbul ignore next: very unusual */\n  '').split(colon)];\n  const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';\n  const pathExt = isWindows ? pathExtExe.split(colon) : [''];\n\n  if (isWindows) {\n    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');\n  }\n\n  return {\n    pathEnv,\n    pathExt,\n    pathExtExe\n  };\n};\n\nconst which = (cmd, opt, cb) => {\n  if (typeof opt === 'function') {\n    cb = opt;\n    opt = {};\n  }\n\n  if (!opt) opt = {};\n  const {\n    pathEnv,\n    pathExt,\n    pathExtExe\n  } = getPathInfo(cmd, opt);\n  const found = [];\n\n  const step = i => new Promise((resolve, reject) => {\n    if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));\n    const ppRaw = pathEnv[i];\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n    const pCmd = path.join(pathPart, cmd);\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n    resolve(subStep(p, i, 0));\n  });\n\n  const subStep = (p, i, ii) => new Promise((resolve, reject) => {\n    if (ii === pathExt.length) return resolve(step(i + 1));\n    const ext = pathExt[ii];\n    isexe(p + ext, {\n      pathExt: pathExtExe\n    }, (er, is) => {\n      if (!er && is) {\n        if (opt.all) found.push(p + ext);else return resolve(p + ext);\n      }\n\n      return resolve(subStep(p, i, ii + 1));\n    });\n  });\n\n  return cb ? step(0).then(res => cb(null, res), cb) : step(0);\n};\n\nconst whichSync = (cmd, opt) => {\n  opt = opt || {};\n  const {\n    pathEnv,\n    pathExt,\n    pathExtExe\n  } = getPathInfo(cmd, opt);\n  const found = [];\n\n  for (let i = 0; i < pathEnv.length; i++) {\n    const ppRaw = pathEnv[i];\n    const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;\n    const pCmd = path.join(pathPart, cmd);\n    const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;\n\n    for (let j = 0; j < pathExt.length; j++) {\n      const cur = p + pathExt[j];\n\n      try {\n        const is = isexe.sync(cur, {\n          pathExt: pathExtExe\n        });\n\n        if (is) {\n          if (opt.all) found.push(cur);else return cur;\n        }\n      } catch (ex) {}\n    }\n  }\n\n  if (opt.all && found.length) return found;\n  if (opt.nothrow) return null;\n  throw getNotFoundError(cmd);\n};\n\nmodule.exports = which;\nwhich.sync = whichSync;","map":null,"metadata":{},"sourceType":"script"}