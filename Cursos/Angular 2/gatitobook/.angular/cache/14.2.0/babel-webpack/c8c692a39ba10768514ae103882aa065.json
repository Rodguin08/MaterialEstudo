{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleTargetAndForget = exports.targetFromTargetString = exports.targetStringFromTarget = exports.fromAsyncIterable = exports.isBuilderOutput = exports.BuilderProgressState = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst progress_schema_1 = require(\"./progress-schema\");\n\nObject.defineProperty(exports, \"BuilderProgressState\", {\n  enumerable: true,\n  get: function () {\n    return progress_schema_1.State;\n  }\n}); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction isBuilderOutput(obj) {\n  if (!obj || typeof obj.then === 'function' || typeof obj.subscribe === 'function') {\n    return false;\n  }\n\n  if (typeof obj[Symbol.asyncIterator] === 'function') {\n    return false;\n  }\n\n  return typeof obj.success === 'boolean';\n}\n\nexports.isBuilderOutput = isBuilderOutput;\n\nfunction fromAsyncIterable(iterable) {\n  return new rxjs_1.Observable(subscriber => {\n    handleAsyncIterator(subscriber, iterable[Symbol.asyncIterator]()).then(() => subscriber.complete(), error => subscriber.error(error));\n  });\n}\n\nexports.fromAsyncIterable = fromAsyncIterable;\n\nfunction handleAsyncIterator(_x, _x2) {\n  return _handleAsyncIterator.apply(this, arguments);\n}\n/**\n * Returns a string of \"project:target[:configuration]\" for the target object.\n */\n\n\nfunction _handleAsyncIterator() {\n  _handleAsyncIterator = _asyncToGenerator(function* (subscriber, iterator) {\n    var _a;\n\n    const teardown = new Promise(resolve => subscriber.add(() => resolve()));\n\n    try {\n      while (!subscriber.closed) {\n        const result = yield Promise.race([teardown, iterator.next()]);\n\n        if (!result || result.done) {\n          break;\n        }\n\n        subscriber.next(result.value);\n      }\n    } finally {\n      yield (_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator);\n    }\n  });\n  return _handleAsyncIterator.apply(this, arguments);\n}\n\nfunction targetStringFromTarget({\n  project,\n  target,\n  configuration\n}) {\n  return `${project}:${target}${configuration !== undefined ? ':' + configuration : ''}`;\n}\n\nexports.targetStringFromTarget = targetStringFromTarget;\n/**\n * Return a Target tuple from a string.\n */\n\nfunction targetFromTargetString(str) {\n  const tuple = str.split(/:/, 3);\n\n  if (tuple.length < 2) {\n    throw new Error('Invalid target string: ' + JSON.stringify(str));\n  }\n\n  return {\n    project: tuple[0],\n    target: tuple[1],\n    ...(tuple[2] !== undefined && {\n      configuration: tuple[2]\n    })\n  };\n}\n\nexports.targetFromTargetString = targetFromTargetString;\n/**\n * Schedule a target, and forget about its run. This will return an observable of outputs, that\n * as a a teardown will stop the target from running. This means that the Run object this returns\n * should not be shared.\n *\n * The reason this is not part of the Context interface is to keep the Context as normal form as\n * possible. This is really an utility that people would implement in their project.\n *\n * @param context The context of your current execution.\n * @param target The target to schedule.\n * @param overrides Overrides that are used in the target.\n * @param scheduleOptions Additional scheduling options.\n */\n\nfunction scheduleTargetAndForget(context, target, overrides, scheduleOptions) {\n  let resolve = null;\n  const promise = new Promise(r => resolve = r);\n  context.addTeardown(() => promise);\n  return (0, rxjs_1.from)(context.scheduleTarget(target, overrides, scheduleOptions)).pipe((0, operators_1.switchMap)(run => new rxjs_1.Observable(observer => {\n    const subscription = run.output.subscribe(observer);\n    return () => {\n      subscription.unsubscribe(); // We can properly ignore the floating promise as it's a \"reverse\" promise; the teardown\n      // is waiting for the resolve.\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n      run.stop().then(resolve);\n    };\n  })));\n}\n\nexports.scheduleTargetAndForget = scheduleTargetAndForget;","map":null,"metadata":{},"sourceType":"script"}