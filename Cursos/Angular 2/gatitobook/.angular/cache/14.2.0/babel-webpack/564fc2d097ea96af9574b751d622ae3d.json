{"ast":null,"code":"'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert');\n\nconst Parser = require('./parse.js');\n\nconst fs = require('fs');\n\nconst fsm = require('fs-minipass');\n\nconst path = require('path');\n\nconst mkdir = require('./mkdir.js');\n\nconst wc = require('./winchars.js');\n\nconst pathReservations = require('./path-reservations.js');\n\nconst stripAbsolutePath = require('./strip-absolute-path.js');\n\nconst normPath = require('./normalize-windows-path.js');\n\nconst stripSlash = require('./strip-trailing-slashes.js');\n\nconst normalize = require('./normalize-unicode.js');\n\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\n\nconst crypto = require('crypto');\n\nconst getFlag = require('./get-write-flag.js');\n\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32'; // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) return fs.unlink(path, cb);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, er => {\n    if (er) return cb(er);\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nconst unlinkFileSync = path => {\n  if (!isWindows) return fs.unlinkSync(path);\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nconst uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c; // clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\n\n\nconst cacheKeyNormalize = path => normalize(stripSlash(normPath(path))).toLowerCase();\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs);\n\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path);\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) cache.delete(path);\n  }\n};\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) cache.delete(key);\n};\n\nclass Unpack extends Parser {\n  constructor(opt) {\n    if (!opt) opt = {};\n\n    opt.ondone = _ => {\n      this[ENDED] = true;\n      this[MAYBECLOSE]();\n    };\n\n    super(opt);\n    this[CHECKED_CWD] = false;\n    this.reservations = pathReservations();\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    this.writable = true;\n    this.readable = false;\n    this[PENDING] = 0;\n    this[ENDED] = false;\n    this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');\n\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n\n      this.uid = opt.uid;\n      this.gid = opt.gid;\n      this.setOwner = true;\n    } else {\n      this.uid = null;\n      this.gid = null;\n      this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') this.preserveOwner = process.getuid && process.getuid() === 0;else this.preserveOwner = !!opt.preserveOwner;\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    this.win32 = !!opt.win32 || isWindows; // do not unpack over files that are newer than what's in the archive\n\n    this.newer = !!opt.newer; // do not unpack over ANY files\n\n    this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    this.unlink = !!opt.unlink;\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()));\n    this.strip = +opt.strip || 0; // if we're not chmodding, then we don't need the process umask\n\n    this.processUmask = opt.noChmod ? 0 : process.umask();\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask; // default mode for dirs created as parents\n\n    this.dmode = opt.dmode || 0o0777 & ~this.umask;\n    this.fmode = opt.fmode || 0o0666 & ~this.umask;\n    this.on('entry', entry => this[ONENTRY](entry));\n  } // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n\n\n  warn(code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') data.recoverable = false;\n    return super.warn(code, msg, data);\n  }\n\n  [MAYBECLOSE]() {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish');\n      this.emit('finish');\n      this.emit('end');\n      this.emit('close');\n    }\n  }\n\n  [CHECKPATH](entry) {\n    if (this.strip) {\n      const parts = normPath(entry.path).split('/');\n      if (parts.length < this.strip) return false;\n      entry.path = parts.slice(this.strip).join('/');\n\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/');\n        if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');else return false;\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = normPath(entry.path);\n      const parts = p.split('/');\n\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p\n        });\n        return false;\n      } // strip off the root\n\n\n      const [root, stripped] = stripAbsolutePath(p);\n\n      if (root) {\n        entry.path = stripped;\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p\n        });\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) entry.absolute = normPath(path.resolve(entry.path));else entry.absolute = normPath(path.resolve(this.cwd, entry.path)); // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n\n    /* istanbul ignore if - defense in depth */\n\n    if (!this.preservePaths && entry.absolute.indexOf(this.cwd + '/') !== 0 && entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd\n      });\n      return false;\n    } // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n\n\n    if (entry.absolute === this.cwd && entry.type !== 'Directory' && entry.type !== 'GNUDumpDir') return false; // only encode : chars that aren't drive letter indicators\n\n    if (this.win32) {\n      const {\n        root: aRoot\n      } = path.win32.parse(entry.absolute);\n      entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));\n      const {\n        root: pRoot\n      } = path.win32.parse(entry.path);\n      entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));\n    }\n\n    return true;\n  }\n\n  [ONENTRY](entry) {\n    if (!this[CHECKPATH](entry)) return entry.resume();\n    assert.equal(typeof entry.absolute, 'string');\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) entry.mode = entry.mode | 0o700;\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry);\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry);\n    }\n  }\n\n  [ONERROR](er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') this.emit('error', er);else {\n      this.warn('TAR_ENTRY_ERROR', er, {\n        entry\n      });\n      this[UNPEND]();\n      entry.resume();\n    }\n  }\n\n  [MKDIR](dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod\n    }, cb);\n  }\n\n  [DOCHOWN](entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n  }\n\n  [UID](entry) {\n    return uint32(this.uid, entry.uid, this.processUid);\n  }\n\n  [GID](entry) {\n    return uint32(this.gid, entry.gid, this.processGid);\n  }\n\n  [FILE](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false\n    });\n    stream.on('error', er => {\n      if (stream.fd) fs.close(stream.fd, () => {}); // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n\n      stream.write = () => true;\n\n      this[ONERROR](er, entry);\n      fullyDone();\n    });\n    let actions = 1;\n\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) fs.close(stream.fd, () => {});\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) this[ONERROR](er, entry);else this[UNPEND]();\n          fullyDone();\n        });\n      }\n    };\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute;\n      const fd = stream.fd;\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n        fs.futimes(fd, atime, mtime, er => er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er)) : done());\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n        fs.fchown(fd, uid, gid, er => er ? fs.chown(abs, uid, gid, er2 => done(er2 && er)) : done());\n      }\n\n      done();\n    });\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry);\n        fullyDone();\n      });\n      entry.pipe(tx);\n    }\n\n    tx.pipe(stream);\n  }\n\n  [DIRECTORY](entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry);\n        fullyDone();\n        return;\n      }\n\n      let actions = 1;\n\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone();\n          this[UNPEND]();\n          entry.resume();\n        }\n      };\n\n      if (entry.mtime && !this.noMtime) {\n        actions++;\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++;\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done);\n      }\n\n      done();\n    });\n  }\n\n  [UNSUPPORTED](entry) {\n    entry.unsupported = true;\n    this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, {\n      entry\n    });\n    entry.resume();\n  }\n\n  [SYMLINK](entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done);\n  }\n\n  [HARDLINK](entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath));\n    this[LINK](entry, linkpath, 'link', done);\n  }\n\n  [PEND]() {\n    this[PENDING]++;\n  }\n\n  [UNPEND]() {\n    this[PENDING]--;\n    this[MAYBECLOSE]();\n  }\n\n  [SKIP](entry) {\n    this[UNPEND]();\n    entry.resume();\n  } // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n\n\n  [ISREUSABLE](entry, st) {\n    return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows;\n  } // check if a thing is there, and if so, try to clobber it\n\n\n  [CHECKFS](entry) {\n    this[PEND]();\n    const paths = [entry.path];\n    if (entry.linkpath) paths.push(entry.linkpath);\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n  }\n\n  [PRUNECACHE](entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') dropCache(this.dirCache);else if (entry.type !== 'Directory') pruneCache(this.dirCache, entry.absolute);\n  }\n\n  [CHECKFS2](entry, fullyDone) {\n    this[PRUNECACHE](entry);\n\n    const done = er => {\n      this[PRUNECACHE](entry);\n      fullyDone(er);\n    };\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry);\n          done();\n          return;\n        }\n\n        this[CHECKED_CWD] = true;\n        start();\n      });\n    };\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute));\n\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry);\n              done();\n              return;\n            }\n\n            afterMakeParent();\n          });\n        }\n      }\n\n      afterMakeParent();\n    };\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry);\n          done();\n          return;\n        }\n\n        if (lstatEr || this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry, done);\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n\n            const afterChmod = er => this[MAKEFS](er, entry, done);\n\n            if (!needChmod) return afterChmod();\n            return fs.chmod(entry.absolute, entry.mode, afterChmod);\n          } // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n\n\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done));\n          }\n        } // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n\n\n        if (entry.absolute === this.cwd) return this[MAKEFS](null, entry, done);\n        unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done));\n      });\n    };\n\n    if (this[CHECKED_CWD]) start();else checkCwd();\n  }\n\n  [MAKEFS](er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done);\n\n      case 'Link':\n        return this[HARDLINK](entry, done);\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done);\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done);\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) this[ONERROR](er, entry);else {\n        this[UNPEND]();\n        entry.resume();\n      }\n      done();\n    });\n  }\n\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()];\n  } catch (er) {\n    return [er, null];\n  }\n};\n\nclass UnpackSync extends Unpack {\n  [MAKEFS](er, entry) {\n    return super[MAKEFS](er, entry, () => {});\n  }\n\n  [CHECKFS](entry) {\n    this[PRUNECACHE](entry);\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode);\n      if (er) return this[ONERROR](er, entry);\n      this[CHECKED_CWD] = true;\n    } // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n\n\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute));\n\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode);\n        if (mkParent) return this[ONERROR](mkParent, entry);\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute));\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) return this[SKIP](entry);\n    if (lstatEr || this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry);\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode;\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode);\n        }) : [];\n        return this[MAKEFS](er, entry);\n      } // not a dir entry, have to remove it\n\n\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute));\n      this[MAKEFS](er, entry);\n    } // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n\n\n    const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));\n    this[MAKEFS](er, entry);\n  }\n\n  [FILE](entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode;\n\n    const oner = er => {\n      let closeError;\n\n      try {\n        fs.closeSync(fd);\n      } catch (e) {\n        closeError = e;\n      }\n\n      if (er || closeError) this[ONERROR](er || closeError, entry);\n      done();\n    };\n\n    let fd;\n\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n    } catch (er) {\n      return oner(er);\n    }\n\n    const tx = this.transform ? this.transform(entry) || entry : entry;\n\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry));\n      entry.pipe(tx);\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length);\n      } catch (er) {\n        oner(er);\n      }\n    });\n    tx.on('end', _ => {\n      let er = null; // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date();\n        const mtime = entry.mtime;\n\n        try {\n          fs.futimesSync(fd, atime, mtime);\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime);\n          } catch (utimeser) {\n            er = futimeser;\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry);\n        const gid = this[GID](entry);\n\n        try {\n          fs.fchownSync(fd, uid, gid);\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid);\n          } catch (chowner) {\n            er = er || fchowner;\n          }\n        }\n      }\n\n      oner(er);\n    });\n  }\n\n  [DIRECTORY](entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode;\n    const er = this[MKDIR](entry.absolute, mode);\n\n    if (er) {\n      this[ONERROR](er, entry);\n      done();\n      return;\n    }\n\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n      } catch (er) {}\n    }\n\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n      } catch (er) {}\n    }\n\n    done();\n    entry.resume();\n  }\n\n  [MKDIR](dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode\n      });\n    } catch (er) {\n      return er;\n    }\n  }\n\n  [LINK](entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute);\n      done();\n      entry.resume();\n    } catch (er) {\n      return this[ONERROR](er, entry);\n    }\n  }\n\n}\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":null,"metadata":{},"sourceType":"script"}