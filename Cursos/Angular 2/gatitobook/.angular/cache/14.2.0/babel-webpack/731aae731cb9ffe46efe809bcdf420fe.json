{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.schematic = exports.externalSchematic = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nconst static_1 = require(\"../tree/static\");\n/**\n * Run a schematic from a separate collection.\n *\n * @param collectionName The name of the collection that contains the schematic to run.\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\n\n\nfunction externalSchematic(collectionName, schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.engine.createCollection(collectionName, context.schematic.collection);\n    const schematic = collection.createSchematic(schematicName);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\n\nexports.externalSchematic = externalSchematic;\n/**\n * Run a schematic from the same collection.\n *\n * @param schematicName The name of the schematic to run.\n * @param options The options to pass as input to the RuleFactory.\n */\n\nfunction schematic(schematicName, options, executionOptions) {\n  return (input, context) => {\n    const collection = context.schematic.collection;\n    const schematic = collection.createSchematic(schematicName, true);\n    return schematic.call(options, (0, rxjs_1.of)((0, static_1.branch)(input)), context, executionOptions).pipe((0, operators_1.last)(), (0, operators_1.map)(x => {\n      // We allow overwrite conflict here because they're the only merge conflict we particularly\n      // don't want to deal with; the input tree might have an OVERWRITE which the sub\n      input.merge(x, interface_1.MergeStrategy.AllowOverwriteConflict);\n      return input;\n    }));\n  };\n}\n\nexports.schematic = schematic;","map":null,"metadata":{},"sourceType":"script"}