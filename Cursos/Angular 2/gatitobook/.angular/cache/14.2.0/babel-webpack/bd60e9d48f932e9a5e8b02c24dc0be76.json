{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FileSystemEngineHostBase = exports.SchematicNameCollisionException = exports.SchematicMissingDescriptionException = exports.SchematicMissingFieldsException = exports.CollectionMissingFieldsException = exports.CollectionMissingSchematicsMapException = exports.FactoryCannotBeResolvedException = exports.SchematicMissingFactoryException = exports.InvalidCollectionJsonException = exports.CollectionCannotBeResolvedException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst node_1 = require(\"@angular-devkit/core/node\");\n\nconst fs_1 = require(\"fs\");\n\nconst path_1 = require(\"path\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst src_1 = require(\"../src\");\n\nconst file_system_utility_1 = require(\"./file-system-utility\");\n\nclass CollectionCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection ${JSON.stringify(name)} cannot be resolved.`);\n  }\n\n}\n\nexports.CollectionCannotBeResolvedException = CollectionCannotBeResolvedException;\n\nclass InvalidCollectionJsonException extends core_1.BaseException {\n  constructor(_name, path, jsonException) {\n    let msg = `Collection JSON at path ${JSON.stringify(path)} is invalid.`;\n\n    if (jsonException) {\n      msg = `${msg} ${jsonException.message}`;\n    }\n\n    super(msg);\n  }\n\n}\n\nexports.InvalidCollectionJsonException = InvalidCollectionJsonException;\n\nclass SchematicMissingFactoryException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} is missing a factory.`);\n  }\n\n}\n\nexports.SchematicMissingFactoryException = SchematicMissingFactoryException;\n\nclass FactoryCannotBeResolvedException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic ${JSON.stringify(name)} cannot resolve the factory.`);\n  }\n\n}\n\nexports.FactoryCannotBeResolvedException = FactoryCannotBeResolvedException;\n\nclass CollectionMissingSchematicsMapException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" does not have a schematics map.`);\n  }\n\n}\n\nexports.CollectionMissingSchematicsMapException = CollectionMissingSchematicsMapException;\n\nclass CollectionMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Collection \"${name}\" is missing fields.`);\n  }\n\n}\n\nexports.CollectionMissingFieldsException = CollectionMissingFieldsException;\n\nclass SchematicMissingFieldsException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematic \"${name}\" is missing fields.`);\n  }\n\n}\n\nexports.SchematicMissingFieldsException = SchematicMissingFieldsException;\n\nclass SchematicMissingDescriptionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics \"${name}\" does not have a description.`);\n  }\n\n}\n\nexports.SchematicMissingDescriptionException = SchematicMissingDescriptionException;\n\nclass SchematicNameCollisionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Schematics/alias ${JSON.stringify(name)} collides with another alias or schematic` + ' name.');\n  }\n\n}\n\nexports.SchematicNameCollisionException = SchematicNameCollisionException;\n/**\n * A EngineHost base class that uses the file system to resolve collections. This is the base of\n * all other EngineHost provided by the tooling part of the Schematics library.\n */\n\nclass FileSystemEngineHostBase {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this._transforms = [];\n    this._contextTransforms = [];\n    this._taskFactories = new Map();\n  }\n\n  listSchematicNames(collection, includeHidden) {\n    const schematics = [];\n\n    for (const key of Object.keys(collection.schematics)) {\n      const schematic = collection.schematics[key];\n\n      if (schematic.hidden && !includeHidden || schematic.private) {\n        continue;\n      } // If extends is present without a factory it is an alias, do not return it\n      //   unless it is from another collection.\n\n\n      if (!schematic.extends || schematic.factory) {\n        schematics.push(key);\n      } else if (schematic.extends && schematic.extends.indexOf(':') !== -1) {\n        schematics.push(key);\n      }\n    }\n\n    return schematics;\n  }\n\n  registerOptionsTransform(t) {\n    this._transforms.push(t);\n  }\n\n  registerContextTransform(t) {\n    this._contextTransforms.push(t);\n  }\n  /**\n   *\n   * @param name\n   * @return {{path: string}}\n   */\n\n\n  createCollectionDescription(name, requester) {\n    const path = this._resolveCollectionPath(name, requester === null || requester === void 0 ? void 0 : requester.path);\n\n    const jsonValue = (0, file_system_utility_1.readJsonFile)(path);\n\n    if (!jsonValue || typeof jsonValue != 'object' || Array.isArray(jsonValue)) {\n      throw new InvalidCollectionJsonException(name, path);\n    } // normalize extends property to an array\n\n\n    if (typeof jsonValue['extends'] === 'string') {\n      jsonValue['extends'] = [jsonValue['extends']];\n    }\n\n    const description = this._transformCollectionDescription(name, { ...jsonValue,\n      path\n    });\n\n    if (!description || !description.name) {\n      throw new InvalidCollectionJsonException(name, path);\n    } // Validate aliases.\n\n\n    const allNames = Object.keys(description.schematics);\n\n    for (const schematicName of Object.keys(description.schematics)) {\n      const aliases = description.schematics[schematicName].aliases || [];\n\n      for (const alias of aliases) {\n        if (allNames.indexOf(alias) != -1) {\n          throw new SchematicNameCollisionException(alias);\n        }\n      }\n\n      allNames.push(...aliases);\n    }\n\n    return description;\n  }\n\n  createSchematicDescription(name, collection) {\n    // Resolve aliases first.\n    for (const schematicName of Object.keys(collection.schematics)) {\n      const schematicDescription = collection.schematics[schematicName];\n\n      if (schematicDescription.aliases && schematicDescription.aliases.indexOf(name) != -1) {\n        name = schematicName;\n        break;\n      }\n    }\n\n    if (!(name in collection.schematics)) {\n      return null;\n    }\n\n    const collectionPath = (0, path_1.dirname)(collection.path);\n    const partialDesc = collection.schematics[name];\n\n    if (!partialDesc) {\n      return null;\n    }\n\n    if (partialDesc.extends) {\n      const index = partialDesc.extends.indexOf(':');\n      const collectionName = index !== -1 ? partialDesc.extends.slice(0, index) : null;\n      const schematicName = index === -1 ? partialDesc.extends : partialDesc.extends.slice(index + 1);\n\n      if (collectionName !== null) {\n        const extendCollection = this.createCollectionDescription(collectionName);\n        return this.createSchematicDescription(schematicName, extendCollection);\n      } else {\n        return this.createSchematicDescription(schematicName, collection);\n      }\n    } // Use any on this ref as we don't have the OptionT here, but we don't need it (we only need\n    // the path).\n\n\n    if (!partialDesc.factory) {\n      throw new SchematicMissingFactoryException(name);\n    }\n\n    const resolvedRef = this._resolveReferenceString(partialDesc.factory, collectionPath, collection);\n\n    if (!resolvedRef) {\n      throw new FactoryCannotBeResolvedException(name);\n    }\n\n    let schema = partialDesc.schema;\n    let schemaJson = undefined;\n\n    if (schema) {\n      if (!(0, path_1.isAbsolute)(schema)) {\n        schema = (0, path_1.join)(collectionPath, schema);\n      }\n\n      schemaJson = (0, file_system_utility_1.readJsonFile)(schema);\n    } // The schematic path is used to resolve URLs.\n    // We should be able to just do `dirname(resolvedRef.path)` but for compatibility with\n    // Bazel under Windows this directory needs to be resolved from the collection instead.\n    // This is needed because on Bazel under Windows the data files (such as the collection or\n    // url files) are not in the same place as the compiled JS.\n\n\n    const maybePath = (0, path_1.join)(collectionPath, partialDesc.factory);\n    const path = (0, fs_1.existsSync)(maybePath) && (0, fs_1.statSync)(maybePath).isDirectory() ? maybePath : (0, path_1.dirname)(maybePath);\n    return this._transformSchematicDescription(name, collection, { ...partialDesc,\n      schema,\n      schemaJson,\n      name,\n      path,\n      factoryFn: resolvedRef.ref,\n      collection\n    });\n  }\n\n  createSourceFromUrl(url) {\n    switch (url.protocol) {\n      case null:\n      case 'file:':\n        return context => {\n          // Check if context has necessary FileSystemSchematicContext path property\n          const fileDescription = context.schematic.description;\n\n          if (fileDescription.path === undefined) {\n            throw new Error('Unsupported schematic context. Expected a FileSystemSchematicContext.');\n          } // Resolve all file:///a/b/c/d from the schematic's own path, and not the current\n          // path.\n\n\n          const root = (0, core_1.normalize)((0, path_1.resolve)(fileDescription.path, url.path || ''));\n          return new src_1.HostCreateTree(new core_1.virtualFs.ScopedHost(new node_1.NodeJsSyncHost(), root));\n        };\n    }\n\n    return null;\n  }\n\n  transformOptions(schematic, options, context) {\n    var _this = this;\n\n    const transform = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* () {\n        let transformedOptions = options;\n\n        for (const transformer of _this._transforms) {\n          const transformerResult = transformer(schematic, transformedOptions, context);\n          transformedOptions = yield (0, rxjs_1.isObservable)(transformerResult) ? transformerResult.toPromise() : transformerResult;\n        }\n\n        return transformedOptions;\n      });\n\n      return function transform() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    return (0, rxjs_1.from)(transform());\n  }\n\n  transformContext(context) {\n    return this._contextTransforms.reduce((acc, curr) => curr(acc), context);\n  }\n\n  getSchematicRuleFactory(schematic, _collection) {\n    return schematic.factoryFn;\n  }\n\n  registerTaskExecutor(factory, options) {\n    this._taskFactories.set(factory.name, () => (0, rxjs_1.from)(factory.create(options)));\n  }\n\n  createTaskExecutor(name) {\n    const factory = this._taskFactories.get(name);\n\n    if (factory) {\n      return factory();\n    }\n\n    return (0, rxjs_1.throwError)(new src_1.UnregisteredTaskException(name));\n  }\n\n  hasTaskExecutor(name) {\n    return this._taskFactories.has(name);\n  }\n\n}\n\nexports.FileSystemEngineHostBase = FileSystemEngineHostBase;","map":null,"metadata":{},"sourceType":"script"}