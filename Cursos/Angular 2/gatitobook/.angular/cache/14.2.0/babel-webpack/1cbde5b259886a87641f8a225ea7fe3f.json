{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SyncDelegateHost = exports.SynchronousDelegateExpectedException = void 0;\n\nconst exception_1 = require(\"../../exception\");\n\nclass SynchronousDelegateExpectedException extends exception_1.BaseException {\n  constructor() {\n    super(`Expected a synchronous delegate but got an asynchronous one.`);\n  }\n\n}\n\nexports.SynchronousDelegateExpectedException = SynchronousDelegateExpectedException;\n/**\n * Implement a synchronous-only host interface (remove the Observable parts).\n */\n\nclass SyncDelegateHost {\n  constructor(_delegate) {\n    this._delegate = _delegate;\n\n    if (!_delegate.capabilities.synchronous) {\n      throw new SynchronousDelegateExpectedException();\n    }\n  }\n\n  _doSyncCall(observable) {\n    let completed = false;\n    let result = undefined;\n    let errorResult = undefined; // Perf note: this is not using an observer object to avoid a performance penalty in RxJS.\n    // See https://github.com/ReactiveX/rxjs/pull/5646 for details.\n\n    observable.subscribe(x => result = x, err => errorResult = err, () => completed = true);\n\n    if (errorResult !== undefined) {\n      throw errorResult;\n    }\n\n    if (!completed) {\n      throw new SynchronousDelegateExpectedException();\n    } // The non-null operation is to work around `void` type. We don't allow to return undefined\n    // but ResultT could be void, which is undefined in JavaScript, so this doesn't change the\n    // behaviour.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return result;\n  }\n\n  get capabilities() {\n    return this._delegate.capabilities;\n  }\n\n  get delegate() {\n    return this._delegate;\n  }\n\n  write(path, content) {\n    return this._doSyncCall(this._delegate.write(path, content));\n  }\n\n  read(path) {\n    return this._doSyncCall(this._delegate.read(path));\n  }\n\n  delete(path) {\n    return this._doSyncCall(this._delegate.delete(path));\n  }\n\n  rename(from, to) {\n    return this._doSyncCall(this._delegate.rename(from, to));\n  }\n\n  list(path) {\n    return this._doSyncCall(this._delegate.list(path));\n  }\n\n  exists(path) {\n    return this._doSyncCall(this._delegate.exists(path));\n  }\n\n  isDirectory(path) {\n    return this._doSyncCall(this._delegate.isDirectory(path));\n  }\n\n  isFile(path) {\n    return this._doSyncCall(this._delegate.isFile(path));\n  } // Some hosts may not support stat.\n\n\n  stat(path) {\n    const result = this._delegate.stat(path);\n\n    if (result) {\n      return this._doSyncCall(result);\n    } else {\n      return null;\n    }\n  }\n\n  watch(path, options) {\n    return this._delegate.watch(path, options);\n  }\n\n}\n\nexports.SyncDelegateHost = SyncDelegateHost;","map":null,"metadata":{},"sourceType":"script"}