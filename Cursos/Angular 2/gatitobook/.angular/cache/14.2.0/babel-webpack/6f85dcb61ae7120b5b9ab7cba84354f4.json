{"ast":null,"code":"'use strict';\n\nconst npa = /*#__PURE__*/require('npm-package-arg');\n\nconst semver = /*#__PURE__*/require('semver');\n\nconst {\n  checkEngine\n} = /*#__PURE__*/require('npm-install-checks');\n\nconst normalizeBin = /*#__PURE__*/require('npm-normalize-package-bin');\n\nconst engineOk = (manifest, npmVersion, nodeVersion) => {\n  try {\n    checkEngine(manifest, npmVersion, nodeVersion);\n    return true;\n  } catch (_) {\n    return false;\n  }\n};\n\nconst isBefore = (verTimes, ver, time) => !verTimes || !verTimes[ver] || Date.parse(verTimes[ver]) <= time;\n\nconst avoidSemverOpt = {\n  includePrerelease: true,\n  loose: true\n};\n\nconst shouldAvoid = (ver, avoid) => avoid && semver.satisfies(ver, avoid, avoidSemverOpt);\n\nconst decorateAvoid = (result, avoid) => result && shouldAvoid(result.version, avoid) ? { ...result,\n  _shouldAvoid: true\n} : result;\n\nconst pickManifest = (packument, wanted, opts) => {\n  const {\n    defaultTag = 'latest',\n    before = null,\n    nodeVersion = process.version,\n    npmVersion = null,\n    includeStaged = false,\n    avoid = null,\n    avoidStrict = false\n  } = opts;\n  const {\n    name,\n    time: verTimes\n  } = packument;\n  const versions = packument.versions || {};\n\n  if (avoidStrict) {\n    const looseOpts = { ...opts,\n      avoidStrict: false\n    };\n    const result = pickManifest(packument, wanted, looseOpts);\n\n    if (!result || !result._shouldAvoid) {\n      return result;\n    }\n\n    const caret = pickManifest(packument, `^${result.version}`, looseOpts);\n\n    if (!caret || !caret._shouldAvoid) {\n      return { ...caret,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: false\n      };\n    }\n\n    const star = pickManifest(packument, '*', looseOpts);\n\n    if (!star || !star._shouldAvoid) {\n      return { ...star,\n        _outsideDependencyRange: true,\n        _isSemVerMajor: true\n      };\n    }\n\n    throw Object.assign(new Error(`No avoidable versions for ${name}`), {\n      code: 'ETARGET',\n      name,\n      wanted,\n      avoid,\n      before,\n      versions: Object.keys(versions)\n    });\n  }\n\n  const staged = includeStaged && packument.stagedVersions && packument.stagedVersions.versions || {};\n  const restricted = packument.policyRestrictions && packument.policyRestrictions.versions || {};\n  const time = before && verTimes ? +new Date(before) : Infinity;\n  const spec = npa.resolve(name, wanted || defaultTag);\n  const type = spec.type;\n  const distTags = packument['dist-tags'] || {};\n\n  if (type !== 'tag' && type !== 'version' && type !== 'range') {\n    throw new Error('Only tag, version, and range are supported');\n  } // if the type is 'tag', and not just the implicit default, then it must\n  // be that exactly, or nothing else will do.\n\n\n  if (wanted && type === 'tag') {\n    const ver = distTags[wanted]; // if the version in the dist-tags is before the before date, then\n    // we use that.  Otherwise, we get the highest precedence version\n    // prior to the dist-tag.\n\n    if (isBefore(verTimes, ver, time)) {\n      return decorateAvoid(versions[ver] || staged[ver] || restricted[ver], avoid);\n    } else {\n      return pickManifest(packument, `<=${ver}`, opts);\n    }\n  } // similarly, if a specific version, then only that version will do\n\n\n  if (wanted && type === 'version') {\n    const ver = semver.clean(wanted, {\n      loose: true\n    });\n    const mani = versions[ver] || staged[ver] || restricted[ver];\n    return isBefore(verTimes, ver, time) ? decorateAvoid(mani, avoid) : null;\n  } // ok, sort based on our heuristics, and pick the best fit\n\n\n  const range = type === 'range' ? wanted : '*'; // if the range is *, then we prefer the 'latest' if available\n  // but skip this if it should be avoided, in that case we have\n  // to try a little harder.\n\n  const defaultVer = distTags[defaultTag];\n\n  if (defaultVer && (range === '*' || semver.satisfies(defaultVer, range, {\n    loose: true\n  })) && !shouldAvoid(defaultVer, avoid)) {\n    const mani = versions[defaultVer];\n\n    if (mani && isBefore(verTimes, defaultVer, time)) {\n      return mani;\n    }\n  } // ok, actually have to sort the list and take the winner\n\n\n  const allEntries = Object.entries(versions).concat(Object.entries(staged)).concat(Object.entries(restricted)).filter(([ver, mani]) => isBefore(verTimes, ver, time));\n\n  if (!allEntries.length) {\n    throw Object.assign(new Error(`No versions available for ${name}`), {\n      code: 'ENOVERSIONS',\n      name,\n      type,\n      wanted,\n      before,\n      versions: Object.keys(versions)\n    });\n  }\n\n  const sortSemverOpt = {\n    loose: true\n  };\n  const entries = allEntries.filter(([ver, mani]) => semver.satisfies(ver, range, {\n    loose: true\n  })).sort((a, b) => {\n    const [vera, mania] = a;\n    const [verb, manib] = b;\n    const notavoida = !shouldAvoid(vera, avoid);\n    const notavoidb = !shouldAvoid(verb, avoid);\n    const notrestra = !restricted[a];\n    const notrestrb = !restricted[b];\n    const notstagea = !staged[a];\n    const notstageb = !staged[b];\n    const notdepra = !mania.deprecated;\n    const notdeprb = !manib.deprecated;\n    const enginea = engineOk(mania, npmVersion, nodeVersion);\n    const engineb = engineOk(manib, npmVersion, nodeVersion); // sort by:\n    // - not an avoided version\n    // - not restricted\n    // - not staged\n    // - not deprecated and engine ok\n    // - engine ok\n    // - not deprecated\n    // - semver\n\n    return notavoidb - notavoida || notrestrb - notrestra || notstageb - notstagea || (notdeprb && engineb) - (notdepra && enginea) || engineb - enginea || notdeprb - notdepra || semver.rcompare(vera, verb, sortSemverOpt);\n  });\n  return decorateAvoid(entries[0] && entries[0][1], avoid);\n};\n\nmodule.exports = (packument, wanted, opts = {}) => {\n  const mani = pickManifest(packument, wanted, opts);\n  const picked = mani && normalizeBin(mani);\n  const policyRestrictions = packument.policyRestrictions;\n  const restricted = policyRestrictions && policyRestrictions.versions || {};\n\n  if (picked && !restricted[picked.version]) {\n    return picked;\n  }\n\n  const {\n    before = null,\n    defaultTag = 'latest'\n  } = opts;\n  const bstr = before ? new Date(before).toLocaleString() : '';\n  const {\n    name\n  } = packument;\n  const pckg = `${name}@${wanted}` + (before ? ` with a date before ${bstr}` : '');\n  const isForbidden = picked && !!restricted[picked.version];\n  const polMsg = isForbidden ? policyRestrictions.message : '';\n  const msg = !isForbidden ? `No matching version found for ${pckg}.` : `Could not download ${pckg} due to policy violations:\\n${polMsg}`;\n  const code = isForbidden ? 'E403' : 'ETARGET';\n  throw Object.assign(new Error(msg), {\n    code,\n    type: npa.resolve(packument.name, wanted).type,\n    wanted,\n    versions: Object.keys(packument.versions),\n    name,\n    distTags: packument['dist-tags'],\n    defaultTag\n  });\n};","map":null,"metadata":{},"sourceType":"script"}