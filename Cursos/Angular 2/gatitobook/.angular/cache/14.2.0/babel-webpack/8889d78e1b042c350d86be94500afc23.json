{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.visitJsonSchema = exports.visitJson = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst pointer_1 = require(\"./pointer\");\n\nfunction _getObjectSubSchema(schema, key) {\n  if (typeof schema !== 'object' || schema === null) {\n    return undefined;\n  } // Is it an object schema?\n\n\n  if (typeof schema.properties == 'object' || schema.type == 'object') {\n    if (typeof schema.properties == 'object' && typeof schema.properties[key] == 'object') {\n      return schema.properties[key];\n    }\n\n    if (typeof schema.additionalProperties == 'object') {\n      return schema.additionalProperties;\n    }\n\n    return undefined;\n  } // Is it an array schema?\n\n\n  if (typeof schema.items == 'object' || schema.type == 'array') {\n    return typeof schema.items == 'object' ? schema.items : undefined;\n  }\n\n  return undefined;\n}\n\nfunction _visitJsonRecursive(json, visitor, ptr, schema, refResolver, context, root) {\n  if (schema === true || schema === false) {\n    // There's no schema definition, so just visit the JSON recursively.\n    schema = undefined;\n  } // eslint-disable-next-line no-prototype-builtins\n\n\n  if (schema && schema.hasOwnProperty('$ref') && typeof schema['$ref'] == 'string') {\n    if (refResolver) {\n      const resolved = refResolver(schema['$ref'], context);\n      schema = resolved.schema;\n      context = resolved.context;\n    }\n  }\n\n  const value = visitor(json, ptr, schema, root);\n  return ((0, rxjs_1.isObservable)(value) ? value : (0, rxjs_1.of)(value)).pipe((0, operators_1.concatMap)(value => {\n    if (Array.isArray(value)) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(value).pipe((0, operators_1.mergeMap)((item, i) => {\n        return _visitJsonRecursive(item, visitor, (0, pointer_1.joinJsonPointer)(ptr, '' + i), _getObjectSubSchema(schema, '' + i), refResolver, context, root || value).pipe((0, operators_1.tap)(x => value[i] = x));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else if (typeof value == 'object' && value !== null) {\n      return (0, rxjs_1.concat)((0, rxjs_1.from)(Object.getOwnPropertyNames(value)).pipe((0, operators_1.mergeMap)(key => {\n        return _visitJsonRecursive(value[key], visitor, (0, pointer_1.joinJsonPointer)(ptr, key), _getObjectSubSchema(schema, key), refResolver, context, root || value).pipe((0, operators_1.tap)(x => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, key);\n\n          if (descriptor && descriptor.writable && value[key] !== x) {\n            value[key] = x;\n          }\n        }));\n      }), (0, operators_1.ignoreElements)()), (0, rxjs_1.of)(value));\n    } else {\n      return (0, rxjs_1.of)(value);\n    }\n  }));\n}\n/**\n * Visit all the properties in a JSON object, allowing to transform them. It supports calling\n * properties synchronously or asynchronously (through Observables).\n * The original object can be mutated or replaced entirely. In case where it's replaced, the new\n * value is returned. When it's mutated though the original object will be changed.\n *\n * Please note it is possible to have an infinite loop here (which will result in a stack overflow)\n * if you return 2 objects that references each others (or the same object all the time).\n *\n * @param {JsonValue} json The Json value to visit.\n * @param {JsonVisitor} visitor A function that will be called on every items.\n * @param {JsonObject} schema A JSON schema to pass through to the visitor (where possible).\n * @param refResolver a function to resolve references in the schema.\n * @returns {Observable< | undefined>} The observable of the new root, if the root changed.\n */\n\n\nfunction visitJson(json, visitor, schema, refResolver, context) {\n  return _visitJsonRecursive(json, visitor, (0, pointer_1.buildJsonPointer)([]), schema, refResolver, context);\n}\n\nexports.visitJson = visitJson;\n\nfunction visitJsonSchema(schema, visitor) {\n  if (schema === false || schema === true) {\n    // Nothing to visit.\n    return;\n  }\n\n  const keywords = {\n    additionalItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    propertyNames: true,\n    not: true\n  };\n  const arrayKeywords = {\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n  };\n  const propsKeywords = {\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    additionalProperties: true,\n    dependencies: true,\n    items: true\n  };\n\n  function _traverse(schema, jsonPtr, rootSchema, parentSchema, keyIndex) {\n    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n      visitor(schema, jsonPtr, parentSchema, keyIndex);\n\n      for (const key of Object.keys(schema)) {\n        const sch = schema[key];\n\n        if (key in propsKeywords) {\n          if (sch && typeof sch == 'object') {\n            for (const prop of Object.keys(sch)) {\n              _traverse(sch[prop], (0, pointer_1.joinJsonPointer)(jsonPtr, key, prop), rootSchema, schema, prop);\n            }\n          }\n        } else if (key in keywords) {\n          _traverse(sch, (0, pointer_1.joinJsonPointer)(jsonPtr, key), rootSchema, schema, key);\n        } else if (key in arrayKeywords) {\n          if (Array.isArray(sch)) {\n            for (let i = 0; i < sch.length; i++) {\n              _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n            }\n          }\n        } else if (Array.isArray(sch)) {\n          for (let i = 0; i < sch.length; i++) {\n            _traverse(sch[i], (0, pointer_1.joinJsonPointer)(jsonPtr, key, '' + i), rootSchema, sch, '' + i);\n          }\n        }\n      }\n    }\n  }\n\n  _traverse(schema, (0, pointer_1.buildJsonPointer)([]), schema);\n}\n\nexports.visitJsonSchema = visitJsonSchema;","map":null,"metadata":{},"sourceType":"script"}