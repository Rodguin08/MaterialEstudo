{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst util = require('util');\n\nconst chownr = util.promisify(require('chownr'));\n\nconst mkdirp = require('mkdirp');\n\nconst inflight = require('promise-inflight');\n\nconst inferOwner = require('infer-owner'); // Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\n\n\nconst self = {\n  uid: null,\n  gid: null\n};\n\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid();\n    const setuid = process.setuid;\n\n    process.setuid = uid => {\n      self.uid = null;\n      process.setuid = setuid;\n      return process.setuid(uid);\n    };\n  }\n\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid();\n    const setgid = process.setgid;\n\n    process.setgid = gid => {\n      self.gid = null;\n      process.setgid = setgid;\n      return process.setgid(gid);\n    };\n  }\n};\n\nmodule.exports.chownr = fixOwner;\n\nfunction fixOwner(_x, _x2) {\n  return _fixOwner.apply(this, arguments);\n}\n\nfunction _fixOwner() {\n  _fixOwner = _asyncToGenerator(function* (cache, filepath) {\n    if (!process.getuid) {\n      // This platform doesn't need ownership fixing\n      return;\n    }\n\n    getSelf();\n\n    if (self.uid !== 0) {\n      // almost certainly can't chown anyway\n      return;\n    }\n\n    const {\n      uid,\n      gid\n    } = yield inferOwner(cache); // No need to override if it's already what we used.\n\n    if (self.uid === uid && self.gid === gid) {\n      return;\n    }\n\n    return inflight('fixOwner: fixing ownership on ' + filepath, () => chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid).catch(err => {\n      if (err.code === 'ENOENT') {\n        return null;\n      }\n\n      throw err;\n    }));\n  });\n  return _fixOwner.apply(this, arguments);\n}\n\nmodule.exports.chownr.sync = fixOwnerSync;\n\nfunction fixOwnerSync(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return;\n  }\n\n  const {\n    uid,\n    gid\n  } = inferOwner.sync(cache);\n  getSelf();\n\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return;\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return;\n  }\n\n  try {\n    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n\n    throw err;\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix;\n\nfunction mkdirfix(_x3, _x4, _x5) {\n  return _mkdirfix.apply(this, arguments);\n}\n\nfunction _mkdirfix() {\n  _mkdirfix = _asyncToGenerator(function* (cache, p, cb) {\n    // we have to infer the owner _before_ making the directory, even though\n    // we aren't going to use the results, since the cache itself might not\n    // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n    // to be correct if it creates the cache folder in the process.\n    yield inferOwner(cache);\n\n    try {\n      const made = yield mkdirp(p);\n\n      if (made) {\n        yield fixOwner(cache, made);\n        return made;\n      }\n    } catch (err) {\n      if (err.code === 'EEXIST') {\n        yield fixOwner(cache, p);\n        return null;\n      }\n\n      throw err;\n    }\n  });\n  return _mkdirfix.apply(this, arguments);\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync;\n\nfunction mkdirfixSync(cache, p) {\n  try {\n    inferOwner.sync(cache);\n    const made = mkdirp.sync(p);\n\n    if (made) {\n      fixOwnerSync(cache, made);\n      return made;\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p);\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}