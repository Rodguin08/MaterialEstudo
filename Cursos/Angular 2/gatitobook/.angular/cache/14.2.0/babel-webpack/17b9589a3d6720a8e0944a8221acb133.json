{"ast":null,"code":"const {\n  dirname\n} = require('path');\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false;\n  const parent = dirname(path);\n\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;\n    });\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT') return mkdirpManual(parent, opts).then(made => mkdirpManual(path, opts, made));\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory()) return made;else throw er;\n    }, () => {\n      throw er;\n    });\n  });\n};\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path);\n  opts.recursive = false;\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts);\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;else return;\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts);\n    return made || path;\n  } catch (er) {\n    if (er.code === 'ENOENT') return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n\n    try {\n      if (!opts.statSync(path).isDirectory()) throw er;\n    } catch (_) {\n      throw er;\n    }\n  }\n};\n\nmodule.exports = {\n  mkdirpManual,\n  mkdirpManualSync\n};","map":null,"metadata":{},"sourceType":"script"}