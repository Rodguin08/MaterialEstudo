{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLoggerJob = exports.createJobFactory = exports.createJobHandler = exports.ChannelAlreadyExistException = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst index_1 = require(\"../../utils/index\");\n\nconst api_1 = require(\"./api\");\n\nclass ChannelAlreadyExistException extends exception_1.BaseException {\n  constructor(name) {\n    super(`Channel ${JSON.stringify(name)} already exist.`);\n  }\n\n}\n\nexports.ChannelAlreadyExistException = ChannelAlreadyExistException;\n/**\n * Make a simple job handler that sets start and end from a function that's synchronous.\n *\n * @param fn The function to create a handler for.\n * @param options An optional set of properties to set on the handler. Some fields might be\n *   required by registry or schedulers.\n */\n\nfunction createJobHandler(fn, options = {}) {\n  const handler = (argument, context) => {\n    const description = context.description;\n    const inboundBus = context.inboundBus;\n    const inputChannel = new rxjs_1.Subject();\n    let subscription;\n    return new rxjs_1.Observable(subject => {\n      function complete() {\n        if (subscription) {\n          subscription.unsubscribe();\n        }\n\n        subject.next({\n          kind: api_1.JobOutboundMessageKind.End,\n          description\n        });\n        subject.complete();\n        inputChannel.complete();\n      } // Handle input.\n\n\n      const inboundSub = inboundBus.subscribe(message => {\n        switch (message.kind) {\n          case api_1.JobInboundMessageKind.Ping:\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.Pong,\n              description,\n              id: message.id\n            });\n            break;\n\n          case api_1.JobInboundMessageKind.Stop:\n            // There's no way to cancel a promise or a synchronous function, but we do cancel\n            // observables where possible.\n            complete();\n            break;\n\n          case api_1.JobInboundMessageKind.Input:\n            inputChannel.next(message.value);\n            break;\n        }\n      }); // Execute the function with the additional context.\n\n      const channels = new Map();\n      const newContext = { ...context,\n        input: inputChannel.asObservable(),\n\n        createChannel(name) {\n          if (channels.has(name)) {\n            throw new ChannelAlreadyExistException(name);\n          }\n\n          const channelSubject = new rxjs_1.Subject();\n          const channelSub = channelSubject.subscribe(message => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelMessage,\n              description,\n              name,\n              message\n            });\n          }, error => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelError,\n              description,\n              name,\n              error\n            }); // This can be reopened.\n\n            channels.delete(name);\n          }, () => {\n            subject.next({\n              kind: api_1.JobOutboundMessageKind.ChannelComplete,\n              description,\n              name\n            }); // This can be reopened.\n\n            channels.delete(name);\n          });\n          channels.set(name, channelSubject);\n\n          if (subscription) {\n            subscription.add(channelSub);\n          }\n\n          return channelSubject;\n        }\n\n      };\n      subject.next({\n        kind: api_1.JobOutboundMessageKind.Start,\n        description\n      });\n      let result = fn(argument, newContext); // If the result is a promise, simply wait for it to complete before reporting the result.\n\n      if ((0, index_1.isPromise)(result)) {\n        result = (0, rxjs_1.from)(result);\n      } else if (!(0, rxjs_1.isObservable)(result)) {\n        result = (0, rxjs_1.of)(result);\n      }\n\n      subscription = result.subscribe(value => subject.next({\n        kind: api_1.JobOutboundMessageKind.Output,\n        description,\n        value\n      }), error => subject.error(error), () => complete());\n      subscription.add(inboundSub);\n      return subscription;\n    });\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobHandler = createJobHandler;\n/**\n * Lazily create a job using a function.\n * @param loader A factory function that returns a promise/observable of a JobHandler.\n * @param options Same options as createJob.\n */\n\nfunction createJobFactory(loader, options = {}) {\n  const handler = (argument, context) => {\n    return (0, rxjs_1.from)(loader()).pipe((0, operators_1.switchMap)(fn => fn(argument, context)));\n  };\n\n  return Object.assign(handler, {\n    jobDescription: options\n  });\n}\n\nexports.createJobFactory = createJobFactory;\n/**\n * Creates a job that logs out input/output messages of another Job. The messages are still\n * propagated to the other job.\n */\n\nfunction createLoggerJob(job, logger) {\n  const handler = (argument, context) => {\n    context.inboundBus.pipe((0, operators_1.tap)(message => logger.info(`Input: ${JSON.stringify(message)}`))).subscribe();\n    return job(argument, context).pipe((0, operators_1.tap)(message => logger.info(`Message: ${JSON.stringify(message)}`), error => logger.warn(`Error: ${JSON.stringify(error)}`), () => logger.info(`Completed`)));\n  };\n\n  return Object.assign(handler, job);\n}\n\nexports.createLoggerJob = createLoggerJob;","map":null,"metadata":{},"sourceType":"script"}