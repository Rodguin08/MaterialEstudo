{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  URL\n} = require('url');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst Body = require('./body.js');\n\nconst {\n  writeToStream,\n  getTotalBytes\n} = Body;\n\nconst Response = require('./response.js');\n\nconst Headers = require('./headers.js');\n\nconst {\n  createHeadersLenient\n} = Headers;\n\nconst Request = require('./request.js');\n\nconst {\n  getNodeRequestOptions\n} = Request;\n\nconst FetchError = require('./fetch-error.js');\n\nconst AbortError = require('./abort-error.js'); // XXX this should really be split up and unit-ized for easier testing\n// and better DRY implementation of data/http request aborting\n\n\nconst fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (url, opts) {\n    if (/^data:/.test(url)) {\n      const request = new Request(url, opts); // delay 1 promise tick so that the consumer can abort right away\n\n      return Promise.resolve().then(() => new Promise((resolve, reject) => {\n        let type, data;\n\n        try {\n          const {\n            pathname,\n            search\n          } = new URL(url);\n          const split = pathname.split(',');\n\n          if (split.length < 2) {\n            throw new Error('invalid data: URI');\n          }\n\n          const mime = split.shift();\n          const base64 = /;base64$/.test(mime);\n          type = base64 ? mime.slice(0, -1 * ';base64'.length) : mime;\n          const rawData = decodeURIComponent(split.join(',') + search);\n          data = base64 ? Buffer.from(rawData, 'base64') : Buffer.from(rawData);\n        } catch (er) {\n          return reject(new FetchError(`[${request.method}] ${request.url} invalid URL, ${er.message}`, 'system', er));\n        }\n\n        const {\n          signal\n        } = request;\n\n        if (signal && signal.aborted) {\n          return reject(new AbortError('The user aborted a request.'));\n        }\n\n        const headers = {\n          'Content-Length': data.length\n        };\n\n        if (type) {\n          headers['Content-Type'] = type;\n        }\n\n        return resolve(new Response(data, {\n          headers\n        }));\n      }));\n    }\n\n    return new Promise((resolve, reject) => {\n      // build request object\n      const request = new Request(url, opts);\n      let options;\n\n      try {\n        options = getNodeRequestOptions(request);\n      } catch (er) {\n        return reject(er);\n      }\n\n      const send = (options.protocol === 'https:' ? https : http).request;\n      const {\n        signal\n      } = request;\n      let response = null;\n\n      const abort = () => {\n        const error = new AbortError('The user aborted a request.');\n        reject(error);\n\n        if (Minipass.isStream(request.body) && typeof request.body.destroy === 'function') {\n          request.body.destroy(error);\n        }\n\n        if (response && response.body) {\n          response.body.emit('error', error);\n        }\n      };\n\n      if (signal && signal.aborted) {\n        return abort();\n      }\n\n      const abortAndFinalize = () => {\n        abort();\n        finalize();\n      };\n\n      const finalize = () => {\n        req.abort();\n\n        if (signal) {\n          signal.removeEventListener('abort', abortAndFinalize);\n        }\n\n        clearTimeout(reqTimeout);\n      }; // send request\n\n\n      const req = send(options);\n\n      if (signal) {\n        signal.addEventListener('abort', abortAndFinalize);\n      }\n\n      let reqTimeout = null;\n\n      if (request.timeout) {\n        req.once('socket', socket => {\n          reqTimeout = setTimeout(() => {\n            reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n            finalize();\n          }, request.timeout);\n        });\n      }\n\n      req.on('error', er => {\n        // if a 'response' event is emitted before the 'error' event, then by the\n        // time this handler is run it's too late to reject the Promise for the\n        // response. instead, we forward the error event to the response stream\n        // so that the error will surface to the user when they try to consume\n        // the body. this is done as a side effect of aborting the request except\n        // for in windows, where we must forward the event manually, otherwise\n        // there is no longer a ref'd socket attached to the request and the\n        // stream never ends so the event loop runs out of work and the process\n        // exits without warning.\n        // coverage skipped here due to the difficulty in testing\n        // istanbul ignore next\n        if (req.res) {\n          req.res.emit('error', er);\n        }\n\n        reject(new FetchError(`request to ${request.url} failed, reason: ${er.message}`, 'system', er));\n        finalize();\n      });\n      req.on('response', res => {\n        clearTimeout(reqTimeout);\n        const headers = createHeadersLenient(res.headers); // HTTP fetch step 5\n\n        if (fetch.isRedirect(res.statusCode)) {\n          // HTTP fetch step 5.2\n          const location = headers.get('Location'); // HTTP fetch step 5.3\n\n          const locationURL = location === null ? null : new URL(location, request.url).toString(); // HTTP fetch step 5.5\n\n          if (request.redirect === 'error') {\n            reject(new FetchError('uri requested responds with a redirect, ' + `redirect mode is set to error: ${request.url}`, 'no-redirect'));\n            finalize();\n            return;\n          } else if (request.redirect === 'manual') {\n            // node-fetch-specific step: make manual redirect a bit easier to\n            // use by setting the Location header value to the resolved URL.\n            if (locationURL !== null) {\n              // handle corrupted header\n              try {\n                headers.set('Location', locationURL);\n              } catch (err) {\n                /* istanbul ignore next: nodejs server prevent invalid\n                   response headers, we can't test this through normal\n                   request */\n                reject(err);\n              }\n            }\n          } else if (request.redirect === 'follow' && locationURL !== null) {\n            // HTTP-redirect fetch step 5\n            if (request.counter >= request.follow) {\n              reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n              finalize();\n              return;\n            } // HTTP-redirect fetch step 9\n\n\n            if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n              reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n              finalize();\n              return;\n            } // Update host due to redirection\n\n\n            request.headers.set('host', new URL(locationURL).host); // HTTP-redirect fetch step 6 (counter increment)\n            // Create a new Request object.\n\n            const requestOpts = {\n              headers: new Headers(request.headers),\n              follow: request.follow,\n              counter: request.counter + 1,\n              agent: request.agent,\n              compress: request.compress,\n              method: request.method,\n              body: request.body,\n              signal: request.signal,\n              timeout: request.timeout\n            }; // if the redirect is to a new hostname, strip the authorization and cookie headers\n\n            const parsedOriginal = new URL(request.url);\n            const parsedRedirect = new URL(locationURL);\n\n            if (parsedOriginal.hostname !== parsedRedirect.hostname) {\n              requestOpts.headers.delete('authorization');\n              requestOpts.headers.delete('cookie');\n            } // HTTP-redirect fetch step 11\n\n\n            if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n              requestOpts.method = 'GET';\n              requestOpts.body = undefined;\n              requestOpts.headers.delete('content-length');\n            } // HTTP-redirect fetch step 15\n\n\n            resolve(fetch(new Request(locationURL, requestOpts)));\n            finalize();\n            return;\n          }\n        } // end if(isRedirect)\n        // prepare response\n\n\n        res.once('end', () => signal && signal.removeEventListener('abort', abortAndFinalize));\n        const body = new Minipass(); // if an error occurs, either on the response stream itself, on one of the\n        // decoder streams, or a response length timeout from the Body class, we\n        // forward the error through to our internal body stream. If we see an\n        // error event on that, we call finalize to abort the request and ensure\n        // we don't leave a socket believing a request is in flight.\n        // this is difficult to test, so lacks specific coverage.\n\n        body.on('error', finalize); // exceedingly rare that the stream would have an error,\n        // but just in case we proxy it to the stream in use.\n\n        res.on('error',\n        /* istanbul ignore next */\n        er => body.emit('error', er));\n        res.on('data', chunk => body.write(chunk));\n        res.on('end', () => body.end());\n        const responseOptions = {\n          url: request.url,\n          status: res.statusCode,\n          statusText: res.statusMessage,\n          headers: headers,\n          size: request.size,\n          timeout: request.timeout,\n          counter: request.counter,\n          trailer: new Promise(resolveTrailer => res.on('end', () => resolveTrailer(createHeadersLenient(res.trailers))))\n        }; // HTTP-network fetch step 12.1.1.3\n\n        const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 12.1.1.4: handle content codings\n        // in following scenarios we ignore compression support\n        // 1. compression support is disabled\n        // 2. HEAD request\n        // 3. no Content-Encoding header\n        // 4. no content response (204)\n        // 5. content not modified response (304)\n\n        if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n          response = new Response(body, responseOptions);\n          resolve(response);\n          return;\n        } // Be less strict when decoding compressed responses, since sometimes\n        // servers send slightly invalid responses that are still accepted\n        // by common browsers.\n        // Always using Z_SYNC_FLUSH is what cURL does.\n\n\n        const zlibOptions = {\n          flush: zlib.constants.Z_SYNC_FLUSH,\n          finishFlush: zlib.constants.Z_SYNC_FLUSH\n        }; // for gzip\n\n        if (codings === 'gzip' || codings === 'x-gzip') {\n          const unzip = new zlib.Gunzip(zlibOptions);\n          response = new Response( // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n          body.on('error',\n          /* istanbul ignore next */\n          er => unzip.emit('error', er)).pipe(unzip), responseOptions);\n          resolve(response);\n          return;\n        } // for deflate\n\n\n        if (codings === 'deflate' || codings === 'x-deflate') {\n          // handle the infamous raw deflate response from old servers\n          // a hack for old IIS and Apache servers\n          const raw = res.pipe(new Minipass());\n          raw.once('data', chunk => {\n            // see http://stackoverflow.com/questions/37519828\n            const decoder = (chunk[0] & 0x0F) === 0x08 ? new zlib.Inflate() : new zlib.InflateRaw(); // exceedingly rare that the stream would have an error,\n            // but just in case we proxy it to the stream in use.\n\n            body.on('error',\n            /* istanbul ignore next */\n            er => decoder.emit('error', er)).pipe(decoder);\n            response = new Response(decoder, responseOptions);\n            resolve(response);\n          });\n          return;\n        } // for br\n\n\n        if (codings === 'br') {\n          // ignoring coverage so tests don't have to fake support (or lack of) for brotli\n          // istanbul ignore next\n          try {\n            var decoder = new zlib.BrotliDecompress();\n          } catch (err) {\n            reject(err);\n            finalize();\n            return;\n          } // exceedingly rare that the stream would have an error,\n          // but just in case we proxy it to the stream in use.\n\n\n          body.on('error',\n          /* istanbul ignore next */\n          er => decoder.emit('error', er)).pipe(decoder);\n          response = new Response(decoder, responseOptions);\n          resolve(response);\n          return;\n        } // otherwise, use response as-is\n\n\n        response = new Response(body, responseOptions);\n        resolve(response);\n      });\n      writeToStream(req, request);\n    });\n  });\n\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = fetch;\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n\nfetch.Headers = Headers;\nfetch.Request = Request;\nfetch.Response = Response;\nfetch.FetchError = FetchError;\nfetch.AbortError = AbortError;","map":null,"metadata":{},"sourceType":"script"}