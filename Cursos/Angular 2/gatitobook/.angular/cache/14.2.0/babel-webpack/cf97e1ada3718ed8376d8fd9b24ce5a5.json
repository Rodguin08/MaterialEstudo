{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScopedTree = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst delegate_1 = require(\"./delegate\");\n\nconst interface_1 = require(\"./interface\");\n\nclass ScopedFileEntry {\n  constructor(_base, scope) {\n    this._base = _base;\n    this.scope = scope;\n  }\n\n  get path() {\n    return (0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this.scope, this._base.path));\n  }\n\n  get content() {\n    return this._base.content;\n  }\n\n}\n\nclass ScopedDirEntry {\n  constructor(_base, scope) {\n    this._base = _base;\n    this.scope = scope;\n  }\n\n  get parent() {\n    if (!this._base.parent || this._base.path == this.scope) {\n      return null;\n    }\n\n    return new ScopedDirEntry(this._base.parent, this.scope);\n  }\n\n  get path() {\n    return (0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this.scope, this._base.path));\n  }\n\n  get subdirs() {\n    return this._base.subdirs;\n  }\n\n  get subfiles() {\n    return this._base.subfiles;\n  }\n\n  dir(name) {\n    const entry = this._base.dir(name);\n\n    return entry && new ScopedDirEntry(entry, this.scope);\n  }\n\n  file(name) {\n    const entry = this._base.file(name);\n\n    return entry && new ScopedFileEntry(entry, this.scope);\n  }\n\n  visit(visitor) {\n    return this._base.visit((path, entry) => {\n      visitor((0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this.scope, path)), entry && new ScopedFileEntry(entry, this.scope));\n    });\n  }\n\n}\n\nclass ScopedTree {\n  constructor(_base, scope) {\n    this._base = _base;\n    const normalizedScope = (0, core_1.normalize)('/' + scope);\n    this._root = new ScopedDirEntry(this._base.getDir(normalizedScope), normalizedScope);\n  }\n\n  get root() {\n    return this._root;\n  }\n\n  branch() {\n    return new ScopedTree(this._base.branch(), this._root.scope);\n  }\n\n  merge(other, strategy) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n    const delegate = new class extends delegate_1.DelegateTree {\n      get actions() {\n        return other.actions.map(action => self._fullPathAction(action));\n      }\n\n    }(other);\n\n    this._base.merge(delegate, strategy);\n  } // Readonly.\n\n\n  read(path) {\n    return this._base.read(this._fullPath(path));\n  }\n\n  readText(path) {\n    return this._base.readText(this._fullPath(path));\n  }\n\n  readJson(path) {\n    return this._base.readJson(this._fullPath(path));\n  }\n\n  exists(path) {\n    return this._base.exists(this._fullPath(path));\n  }\n\n  get(path) {\n    const entry = this._base.get(this._fullPath(path));\n\n    return entry && new ScopedFileEntry(entry, this._root.scope);\n  }\n\n  getDir(path) {\n    const entry = this._base.getDir(this._fullPath(path));\n\n    return entry && new ScopedDirEntry(entry, this._root.scope);\n  }\n\n  visit(visitor) {\n    return this._root.visit(visitor);\n  } // Change content of host files.\n\n\n  overwrite(path, content) {\n    return this._base.overwrite(this._fullPath(path), content);\n  }\n\n  beginUpdate(path) {\n    return this._base.beginUpdate(this._fullPath(path));\n  }\n\n  commitUpdate(record) {\n    return this._base.commitUpdate(record);\n  } // Structural methods.\n\n\n  create(path, content) {\n    return this._base.create(this._fullPath(path), content);\n  }\n\n  delete(path) {\n    return this._base.delete(this._fullPath(path));\n  }\n\n  rename(from, to) {\n    return this._base.rename(this._fullPath(from), this._fullPath(to));\n  }\n\n  apply(action, strategy) {\n    return this._base.apply(this._fullPathAction(action), strategy);\n  }\n\n  get actions() {\n    const scopedActions = [];\n\n    for (const action of this._base.actions) {\n      if (!action.path.startsWith(this._root.scope + '/')) {\n        continue;\n      }\n\n      if (action.kind !== 'r') {\n        scopedActions.push({ ...action,\n          path: (0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this._root.scope, action.path))\n        });\n      } else if (action.to.startsWith(this._root.scope + '/')) {\n        scopedActions.push({ ...action,\n          path: (0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this._root.scope, action.path)),\n          to: (0, core_1.join)(core_1.NormalizedRoot, (0, core_1.relative)(this._root.scope, action.to))\n        });\n      }\n    }\n\n    return scopedActions;\n  }\n\n  [interface_1.TreeSymbol]() {\n    return this;\n  }\n\n  _fullPath(path) {\n    return (0, core_1.join)(this._root.scope, (0, core_1.normalize)('/' + path));\n  }\n\n  _fullPathAction(action) {\n    let fullPathAction;\n\n    if (action.kind === 'r') {\n      fullPathAction = { ...action,\n        path: this._fullPath(action.path),\n        to: this._fullPath(action.to)\n      };\n    } else {\n      fullPathAction = { ...action,\n        path: this._fullPath(action.path)\n      };\n    }\n\n    return fullPathAction;\n  }\n\n}\n\nexports.ScopedTree = ScopedTree;","map":null,"metadata":{},"sourceType":"script"}