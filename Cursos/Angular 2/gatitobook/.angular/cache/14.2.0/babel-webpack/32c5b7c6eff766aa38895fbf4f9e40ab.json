{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst readFile = promisify(fs.readFile);\nconst lstat = promisify(fs.lstat);\nconst readdir = promisify(fs.readdir);\n\nconst parse = require('json-parse-even-better-errors');\n\nconst {\n  resolve,\n  dirname,\n  join,\n  relative\n} = require('path');\n\nconst rpj = path => readFile(path, 'utf8').then(data => readBinDir(path, normalize(stripUnderscores(parse(data))))).catch(er => {\n  er.path = path;\n  throw er;\n});\n\nconst normalizePackageBin = require('npm-normalize-package-bin'); // load the directories.bin folder as a 'bin' object\n\n\nconst readBinDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (path, data) {\n    if (data.bin) return data;\n    const m = data.directories && data.directories.bin;\n    if (!m || typeof m !== 'string') return data; // cut off any monkey business, like setting directories.bin\n    // to ../../../etc/passwd or /etc/passwd or something like that.\n\n    const root = dirname(path);\n    const dir = join('.', join('/', m));\n    data.bin = yield walkBinDir(root, dir, {});\n    return data;\n  });\n\n  return function readBinDir(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nconst walkBinDir = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator(function* (root, dir, obj) {\n    const entries = yield readdir(resolve(root, dir)).catch(() => []);\n\n    for (const entry of entries) {\n      if (entry.charAt(0) === '.') continue;\n      const f = resolve(root, dir, entry); // ignore stat errors, weird file types, symlinks, etc.\n\n      const st = yield lstat(f).catch(() => null);\n      if (!st) continue;else if (st.isFile()) obj[entry] = relative(root, f);else if (st.isDirectory()) yield walkBinDir(root, join(dir, entry), obj);\n    }\n\n    return obj;\n  });\n\n  return function walkBinDir(_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // do not preserve _fields set in files, they are sus\n\n\nconst stripUnderscores = data => {\n  for (const key of Object.keys(data).filter(k => /^_/.test(k))) delete data[key];\n\n  return data;\n};\n\nconst normalize = data => {\n  add_id(data);\n  fixBundled(data);\n  pruneRepeatedOptionals(data);\n  fixScripts(data);\n  fixFunding(data);\n  normalizePackageBin(data);\n  return data;\n};\n\nrpj.normalize = normalize;\n\nconst add_id = data => {\n  if (data.name && data.version) data._id = `${data.name}@${data.version}`;\n  return data;\n}; // it was once common practice to list deps both in optionalDependencies\n// and in dependencies, to support npm versions that did not know abbout\n// optionalDependencies.  This is no longer a relevant need, so duplicating\n// the deps in two places is unnecessary and excessive.\n\n\nconst pruneRepeatedOptionals = data => {\n  const od = data.optionalDependencies;\n  const dd = data.dependencies || {};\n\n  if (od && typeof od === 'object') {\n    for (const name of Object.keys(od)) {\n      delete dd[name];\n    }\n  }\n\n  if (Object.keys(dd).length === 0) delete data.dependencies;\n  return data;\n};\n\nconst fixBundled = data => {\n  const bdd = data.bundledDependencies;\n  const bd = data.bundleDependencies === undefined ? bdd : data.bundleDependencies;\n  if (bd === false) data.bundleDependencies = [];else if (bd === true) data.bundleDependencies = Object.keys(data.dependencies || {});else if (bd && typeof bd === 'object') {\n    if (!Array.isArray(bd)) data.bundleDependencies = Object.keys(bd);else data.bundleDependencies = bd;\n  } else delete data.bundleDependencies;\n  delete data.bundledDependencies;\n  return data;\n};\n\nconst fixScripts = data => {\n  if (!data.scripts || typeof data.scripts !== 'object') {\n    delete data.scripts;\n    return data;\n  }\n\n  for (const [name, script] of Object.entries(data.scripts)) {\n    if (typeof script !== 'string') delete data.scripts[name];\n  }\n\n  return data;\n};\n\nconst fixFunding = data => {\n  if (data.funding && typeof data.funding === 'string') data.funding = {\n    url: data.funding\n  };\n  return data;\n};\n\nmodule.exports = rpj;","map":null,"metadata":{},"sourceType":"script"}