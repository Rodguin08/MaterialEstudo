{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\n\nconst path = require('path');\n\nconst glob = require('glob');\n\nconst log = require('npmlog');\n\nconst which = require('which');\n\nconst win = process.platform === 'win32';\n\nfunction build(gyp, argv, callback) {\n  var platformMake = 'make';\n\n  if (process.platform === 'aix') {\n    platformMake = 'gmake';\n  } else if (process.platform.indexOf('bsd') !== -1) {\n    platformMake = 'gmake';\n  } else if (win && argv.length > 0) {\n    argv = argv.map(function (target) {\n      return '/t:' + target;\n    });\n  }\n\n  var makeCommand = gyp.opts.make || process.env.MAKE || platformMake;\n  var command = win ? 'msbuild' : makeCommand;\n  var jobs = gyp.opts.jobs || process.env.JOBS;\n  var buildType;\n  var config;\n  var arch;\n  var nodeDir;\n  var guessedSolution;\n  loadConfigGypi();\n  /**\n   * Load the \"config.gypi\" file that was generated during \"configure\".\n   */\n\n  function loadConfigGypi() {\n    var configPath = path.resolve('build', 'config.gypi');\n    fs.readFile(configPath, 'utf8', function (err, data) {\n      if (err) {\n        if (err.code === 'ENOENT') {\n          callback(new Error('You must run `node-gyp configure` first!'));\n        } else {\n          callback(err);\n        }\n\n        return;\n      }\n\n      config = JSON.parse(data.replace(/#.+\\n/, '')); // get the 'arch', 'buildType', and 'nodeDir' vars from the config\n\n      buildType = config.target_defaults.default_configuration;\n      arch = config.variables.target_arch;\n      nodeDir = config.variables.nodedir;\n\n      if ('debug' in gyp.opts) {\n        buildType = gyp.opts.debug ? 'Debug' : 'Release';\n      }\n\n      if (!buildType) {\n        buildType = 'Release';\n      }\n\n      log.verbose('build type', buildType);\n      log.verbose('architecture', arch);\n      log.verbose('node dev dir', nodeDir);\n\n      if (win) {\n        findSolutionFile();\n      } else {\n        doWhich();\n      }\n    });\n  }\n  /**\n   * On Windows, find the first build/*.sln file.\n   */\n\n\n  function findSolutionFile() {\n    glob('build/*.sln', function (err, files) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (files.length === 0) {\n        return callback(new Error('Could not find *.sln file. Did you run \"configure\"?'));\n      }\n\n      guessedSolution = files[0];\n      log.verbose('found first Solution file', guessedSolution);\n      doWhich();\n    });\n  }\n  /**\n   * Uses node-which to locate the msbuild / make executable.\n   */\n\n\n  function doWhich() {\n    // On Windows use msbuild provided by node-gyp configure\n    if (win) {\n      if (!config.variables.msbuild_path) {\n        return callback(new Error('MSBuild is not set, please run `node-gyp configure`.'));\n      }\n\n      command = config.variables.msbuild_path;\n      log.verbose('using MSBuild:', command);\n      doBuild();\n      return;\n    } // First make sure we have the build command in the PATH\n\n\n    which(command, function (err, execPath) {\n      if (err) {\n        // Some other error or 'make' not found on Unix, report that to the user\n        callback(err);\n        return;\n      }\n\n      log.verbose('`which` succeeded for `' + command + '`', execPath);\n      doBuild();\n    });\n  }\n  /**\n   * Actually spawn the process and compile the module.\n   */\n\n\n  function doBuild() {\n    // Enable Verbose build\n    var verbose = log.levels[log.level] <= log.levels.verbose;\n    var j;\n\n    if (!win && verbose) {\n      argv.push('V=1');\n    }\n\n    if (win && !verbose) {\n      argv.push('/clp:Verbosity=minimal');\n    }\n\n    if (win) {\n      // Turn off the Microsoft logo on Windows\n      argv.push('/nologo');\n    } // Specify the build type, Release by default\n\n\n    if (win) {\n      // Convert .gypi config target_arch to MSBuild /Platform\n      // Since there are many ways to state '32-bit Intel', default to it.\n      // N.B. msbuild's Condition string equality tests are case-insensitive.\n      var archLower = arch.toLowerCase();\n      var p = archLower === 'x64' ? 'x64' : archLower === 'arm' ? 'ARM' : archLower === 'arm64' ? 'ARM64' : 'Win32';\n      argv.push('/p:Configuration=' + buildType + ';Platform=' + p);\n\n      if (jobs) {\n        j = parseInt(jobs, 10);\n\n        if (!isNaN(j) && j > 0) {\n          argv.push('/m:' + j);\n        } else if (jobs.toUpperCase() === 'MAX') {\n          argv.push('/m:' + require('os').cpus().length);\n        }\n      }\n    } else {\n      argv.push('BUILDTYPE=' + buildType); // Invoke the Makefile in the 'build' dir.\n\n      argv.push('-C');\n      argv.push('build');\n\n      if (jobs) {\n        j = parseInt(jobs, 10);\n\n        if (!isNaN(j) && j > 0) {\n          argv.push('--jobs');\n          argv.push(j);\n        } else if (jobs.toUpperCase() === 'MAX') {\n          argv.push('--jobs');\n          argv.push(require('os').cpus().length);\n        }\n      }\n    }\n\n    if (win) {\n      // did the user specify their own .sln file?\n      var hasSln = argv.some(function (arg) {\n        return path.extname(arg) === '.sln';\n      });\n\n      if (!hasSln) {\n        argv.unshift(gyp.opts.solution || guessedSolution);\n      }\n    }\n\n    if (!win) {\n      // Add build-time dependency symlinks (such as Python) to PATH\n      const buildBinsDir = path.resolve('build', 'node_gyp_bins');\n      process.env.PATH = `${buildBinsDir}:${process.env.PATH}`;\n      log.verbose('bin symlinks', `adding symlinks (such as Python), at \"${buildBinsDir}\", to PATH`);\n    }\n\n    var proc = gyp.spawn(command, argv);\n    proc.on('exit', onExit);\n  }\n\n  function onExit(code, signal) {\n    if (code !== 0) {\n      return callback(new Error('`' + command + '` failed with exit code: ' + code));\n    }\n\n    if (signal) {\n      return callback(new Error('`' + command + '` got signal: ' + signal));\n    }\n\n    callback();\n  }\n}\n\nmodule.exports = build;\nmodule.exports.usage = 'Invokes `' + (win ? 'msbuild' : 'make') + '` and builds the module';","map":null,"metadata":{},"sourceType":"script"}