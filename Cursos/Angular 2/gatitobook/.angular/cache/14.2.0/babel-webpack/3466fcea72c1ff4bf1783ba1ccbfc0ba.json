{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TargetDefinitionCollection = exports.ProjectDefinitionCollection = void 0;\n\nclass DefinitionCollection {\n  constructor(initial, _listener) {\n    this._listener = _listener;\n    this._map = new Map(initial && Object.entries(initial));\n  }\n\n  delete(key) {\n    var _a;\n\n    const result = this._map.delete(key);\n\n    if (result) {\n      (_a = this._listener) === null || _a === void 0 ? void 0 : _a.call(this, key, undefined, this);\n    }\n\n    return result;\n  }\n\n  set(key, value) {\n    var _a;\n\n    const updatedValue = value !== this.get(key);\n\n    if (updatedValue) {\n      this._map.set(key, value);\n\n      (_a = this._listener) === null || _a === void 0 ? void 0 : _a.call(this, key, value, this);\n    }\n\n    return this;\n  }\n\n  forEach(callbackfn, thisArg) {\n    this._map.forEach((value, key) => callbackfn(value, key, this), thisArg);\n  }\n\n  get(key) {\n    return this._map.get(key);\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get size() {\n    return this._map.size;\n  }\n\n  [Symbol.iterator]() {\n    return this._map[Symbol.iterator]();\n  }\n\n  entries() {\n    return this._map.entries();\n  }\n\n  keys() {\n    return this._map.keys();\n  }\n\n  values() {\n    return this._map.values();\n  }\n\n}\n\nfunction isJsonValue(value) {\n  const visited = new Set();\n\n  switch (typeof value) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      return true;\n\n    case 'object':\n      if (value === null) {\n        return true;\n      }\n\n      visited.add(value);\n\n      for (const property of Object.values(value)) {\n        if (typeof value === 'object' && visited.has(property)) {\n          continue;\n        }\n\n        if (!isJsonValue(property)) {\n          return false;\n        }\n      }\n\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass ProjectDefinitionCollection extends DefinitionCollection {\n  constructor(initial, listener) {\n    super(initial, listener);\n  }\n\n  add(definition) {\n    if (this.has(definition.name)) {\n      throw new Error('Project name already exists.');\n    }\n\n    this._validateName(definition.name);\n\n    const project = {\n      root: definition.root,\n      prefix: definition.prefix,\n      sourceRoot: definition.sourceRoot,\n      targets: new TargetDefinitionCollection(),\n      extensions: {}\n    };\n\n    if (definition.targets) {\n      for (const [name, target] of Object.entries(definition.targets)) {\n        if (target) {\n          project.targets.set(name, target);\n        }\n      }\n    }\n\n    for (const [name, value] of Object.entries(definition)) {\n      switch (name) {\n        case 'name':\n        case 'root':\n        case 'sourceRoot':\n        case 'prefix':\n        case 'targets':\n          break;\n\n        default:\n          if (isJsonValue(value)) {\n            project.extensions[name] = value;\n          } else {\n            throw new TypeError(`\"${name}\" must be a JSON value.`);\n          }\n\n          break;\n      }\n    }\n\n    super.set(definition.name, project);\n    return project;\n  }\n\n  set(name, value) {\n    this._validateName(name);\n\n    super.set(name, value);\n    return this;\n  }\n\n  _validateName(name) {\n    if (typeof name !== 'string' || !/^(?:@\\w[\\w.-]*\\/)?\\w[\\w.-]*$/.test(name)) {\n      throw new Error('Project name must be a valid npm package name.');\n    }\n  }\n\n}\n\nexports.ProjectDefinitionCollection = ProjectDefinitionCollection;\n\nclass TargetDefinitionCollection extends DefinitionCollection {\n  constructor(initial, listener) {\n    super(initial, listener);\n  }\n\n  add(definition) {\n    if (this.has(definition.name)) {\n      throw new Error('Target name already exists.');\n    }\n\n    this._validateName(definition.name);\n\n    const target = {\n      builder: definition.builder,\n      options: definition.options,\n      configurations: definition.configurations,\n      defaultConfiguration: definition.defaultConfiguration\n    };\n    super.set(definition.name, target);\n    return target;\n  }\n\n  set(name, value) {\n    this._validateName(name);\n\n    super.set(name, value);\n    return this;\n  }\n\n  _validateName(name) {\n    if (typeof name !== 'string') {\n      throw new TypeError('Target name must be a string.');\n    }\n  }\n\n}\n\nexports.TargetDefinitionCollection = TargetDefinitionCollection;","map":null,"metadata":{},"sourceType":"script"}