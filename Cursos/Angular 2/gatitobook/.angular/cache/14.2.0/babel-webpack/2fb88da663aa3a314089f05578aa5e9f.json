{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateBuffer2 = exports.UpdateBuffer = exports.UpdateBufferBase = exports.Chunk = exports.ContentCannotBeRemovedException = exports.IndexOutOfBoundException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst magic_string_1 = __importDefault(require(\"magic-string\"));\n\nconst environment_options_1 = require(\"./environment-options\");\n\nconst linked_list_1 = require(\"./linked-list\");\n\nclass IndexOutOfBoundException extends core_1.BaseException {\n  constructor(index, min, max = Infinity) {\n    super(`Index ${index} outside of range [${min}, ${max}].`);\n  }\n\n}\n\nexports.IndexOutOfBoundException = IndexOutOfBoundException;\n/** @deprecated Since v13.0 */\n\nclass ContentCannotBeRemovedException extends core_1.BaseException {\n  constructor() {\n    super(`User tried to remove content that was marked essential.`);\n  }\n\n}\n\nexports.ContentCannotBeRemovedException = ContentCannotBeRemovedException;\n/**\n * A Chunk description, including left/right content that has been inserted.\n * If _left/_right is null, this means that content was deleted. If the _content is null,\n * it means the content itself was deleted.\n *\n * @see UpdateBuffer\n * @deprecated Since v13.0\n */\n\nclass Chunk {\n  constructor(start, end, originalContent) {\n    this.start = start;\n    this.end = end;\n    this.originalContent = originalContent;\n    this._left = Buffer.alloc(0);\n    this._right = Buffer.alloc(0);\n    this._assertLeft = false;\n    this._assertRight = false;\n    this.next = null;\n    this._content = originalContent.slice(start, end);\n  }\n\n  get length() {\n    return (this._left ? this._left.length : 0) + (this._content ? this._content.length : 0) + (this._right ? this._right.length : 0);\n  }\n\n  toString(encoding = 'utf-8') {\n    return (this._left ? this._left.toString(encoding) : '') + (this._content ? this._content.toString(encoding) : '') + (this._right ? this._right.toString(encoding) : '');\n  }\n\n  slice(start) {\n    if (start < this.start || start > this.end) {\n      throw new IndexOutOfBoundException(start, this.start, this.end);\n    } // Update _content to the new indices.\n\n\n    const newChunk = new Chunk(start, this.end, this.originalContent); // If this chunk has _content, reslice the original _content. We move the _right so we are not\n    // losing any data here. If this chunk has been deleted, the next chunk should also be deleted.\n\n    if (this._content) {\n      this._content = this.originalContent.slice(this.start, start);\n    } else {\n      newChunk._content = this._content;\n\n      if (this._right === null) {\n        newChunk._left = null;\n      }\n    }\n\n    this.end = start; // Move _right to the new chunk.\n\n    newChunk._right = this._right;\n    this._right = this._right && Buffer.alloc(0); // Update essentials.\n\n    if (this._assertRight) {\n      newChunk._assertRight = true;\n      this._assertRight = false;\n    } // Update the linked list.\n\n\n    newChunk.next = this.next;\n    this.next = newChunk;\n    return newChunk;\n  }\n\n  append(buffer, essential) {\n    if (!this._right) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      return;\n    }\n\n    const outro = this._right;\n    this._right = Buffer.alloc(outro.length + buffer.length);\n    outro.copy(this._right, 0);\n    buffer.copy(this._right, outro.length);\n\n    if (essential) {\n      this._assertRight = true;\n    }\n  }\n\n  prepend(buffer, essential) {\n    if (!this._left) {\n      if (essential) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      return;\n    }\n\n    const intro = this._left;\n    this._left = Buffer.alloc(intro.length + buffer.length);\n    intro.copy(this._left, 0);\n    buffer.copy(this._left, intro.length);\n\n    if (essential) {\n      this._assertLeft = true;\n    }\n  }\n\n  assert(left, _content, right) {\n    if (left && this._assertLeft) {\n      throw new ContentCannotBeRemovedException();\n    }\n\n    if (right && this._assertRight) {\n      throw new ContentCannotBeRemovedException();\n    }\n  }\n\n  remove(left, content, right) {\n    if (left) {\n      if (this._assertLeft) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      this._left = null;\n    }\n\n    if (content) {\n      this._content = null;\n    }\n\n    if (right) {\n      if (this._assertRight) {\n        throw new ContentCannotBeRemovedException();\n      }\n\n      this._right = null;\n    }\n  }\n\n  copy(target, start) {\n    if (this._left) {\n      this._left.copy(target, start);\n\n      start += this._left.length;\n    }\n\n    if (this._content) {\n      this._content.copy(target, start);\n\n      start += this._content.length;\n    }\n\n    if (this._right) {\n      this._right.copy(target, start);\n\n      start += this._right.length;\n    }\n\n    return start;\n  }\n\n}\n\nexports.Chunk = Chunk;\n/**\n * Base class for an update buffer implementation that allows buffers to be inserted to the _right\n * or _left, or deleted, while keeping indices to the original buffer.\n */\n\nclass UpdateBufferBase {\n  constructor(_originalContent) {\n    this._originalContent = _originalContent;\n  }\n  /**\n   * Creates an UpdateBufferBase instance. Depending on the NG_UPDATE_BUFFER_V2\n   * environment variable, will either create an UpdateBuffer or an UpdateBuffer2\n   * instance.\n   *\n   * See: https://github.com/angular/angular-cli/issues/21110\n   *\n   * @param originalContent The original content of the update buffer instance.\n   * @returns An UpdateBufferBase instance.\n   */\n\n\n  static create(originalContent) {\n    return environment_options_1.updateBufferV2Enabled ? new UpdateBuffer2(originalContent) : new UpdateBuffer(originalContent);\n  }\n\n}\n\nexports.UpdateBufferBase = UpdateBufferBase;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n *\n * The constructor takes an original buffer, and keeps it into a linked list of chunks, smaller\n * buffers that keep track of _content inserted to the _right or _left of it.\n *\n * Since the Node Buffer structure is non-destructive when slicing, we try to use slicing to create\n * new chunks, and always keep chunks pointing to the original content.\n *\n * @deprecated Since v13.0\n */\n\nclass UpdateBuffer extends UpdateBufferBase {\n  constructor(originalContent) {\n    super(originalContent);\n    this._linkedList = new linked_list_1.LinkedList(new Chunk(0, originalContent.length, originalContent));\n  }\n\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n\n  _slice(start) {\n    let index;\n\n    if (start >= this._originalContent.length) {\n      index = start;\n    } else if (start < 0) {\n      index = this._originalContent.length + start;\n    } else {\n      index = this._getTextPosition(start);\n    }\n\n    this._assertIndex(index); // Find the chunk by going through the list.\n\n\n    const h = this._linkedList.find(chunk => index <= chunk.end);\n\n    if (!h) {\n      throw Error('Chunk cannot be found.');\n    }\n\n    if (index == h.end && h.next !== null) {\n      return [h, h.next];\n    }\n\n    return [h, h.slice(index)];\n  }\n  /**\n   * Gets the position in the content based on the position in the string.\n   * Some characters might be wider than one byte, thus we have to determine the position using\n   * string functions.\n   */\n\n\n  _getTextPosition(index) {\n    return Buffer.from(this._originalContent.toString().substring(0, index)).length;\n  }\n\n  get length() {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.length, 0);\n  }\n\n  get original() {\n    return this._originalContent;\n  }\n\n  toString(encoding = 'utf-8') {\n    return this._linkedList.reduce((acc, chunk) => acc + chunk.toString(encoding), '');\n  }\n\n  generate() {\n    const result = Buffer.allocUnsafe(this.length);\n    let i = 0;\n\n    this._linkedList.forEach(chunk => {\n      chunk.copy(result, i);\n      i += chunk.length;\n    });\n\n    return result;\n  }\n\n  insertLeft(index, content, assert = false) {\n    this._slice(index)[0].append(content, assert);\n  }\n\n  insertRight(index, content, assert = false) {\n    this._slice(index)[1].prepend(content, assert);\n  }\n\n  remove(index, length) {\n    if (length === 0) {\n      return;\n    }\n\n    const end = index + length;\n\n    const first = this._slice(index)[1];\n\n    const last = this._slice(end)[1];\n\n    let curr;\n\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.assert(curr !== first, curr !== last, curr === first);\n    }\n\n    for (curr = first; curr && curr !== last; curr = curr.next) {\n      curr.remove(curr !== first, curr !== last, curr === first);\n    }\n\n    if (curr) {\n      curr.remove(true, false, false);\n    }\n  }\n\n}\n\nexports.UpdateBuffer = UpdateBuffer;\n/**\n * An utility class that allows buffers to be inserted to the _right or _left, or deleted, while\n * keeping indices to the original buffer.\n */\n\nclass UpdateBuffer2 extends UpdateBufferBase {\n  constructor() {\n    super(...arguments);\n    this._mutatableContent = new magic_string_1.default(this._originalContent.toString());\n  }\n\n  _assertIndex(index) {\n    if (index < 0 || index > this._originalContent.length) {\n      throw new IndexOutOfBoundException(index, 0, this._originalContent.length);\n    }\n  }\n\n  get length() {\n    return this._mutatableContent.length();\n  }\n\n  get original() {\n    return this._originalContent;\n  }\n\n  toString() {\n    return this._mutatableContent.toString();\n  }\n\n  generate() {\n    return Buffer.from(this.toString());\n  }\n\n  insertLeft(index, content) {\n    this._assertIndex(index);\n\n    this._mutatableContent.appendLeft(index, content.toString());\n  }\n\n  insertRight(index, content) {\n    this._assertIndex(index);\n\n    this._mutatableContent.appendRight(index, content.toString());\n  }\n\n  remove(index, length) {\n    this._assertIndex(index);\n\n    this._mutatableContent.remove(index, index + length);\n  }\n\n}\n\nexports.UpdateBuffer2 = UpdateBuffer2;","map":null,"metadata":{},"sourceType":"script"}