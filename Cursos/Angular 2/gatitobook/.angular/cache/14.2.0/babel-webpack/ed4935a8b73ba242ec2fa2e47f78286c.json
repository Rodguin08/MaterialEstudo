{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchematicsCommandModule = exports.DEFAULT_SCHEMATICS_COLLECTION = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst schematics_1 = /*#__PURE__*/require(\"@angular-devkit/schematics\");\n\nconst tools_1 = /*#__PURE__*/require(\"@angular-devkit/schematics/tools\");\n\nconst path_1 = /*#__PURE__*/require(\"path\");\n\nconst config_1 = /*#__PURE__*/require(\"../utilities/config\");\n\nconst error_1 = /*#__PURE__*/require(\"../utilities/error\");\n\nconst memoize_1 = /*#__PURE__*/require(\"../utilities/memoize\");\n\nconst tty_1 = /*#__PURE__*/require(\"../utilities/tty\");\n\nconst command_module_1 = /*#__PURE__*/require(\"./command-module\");\n\nconst json_schema_1 = /*#__PURE__*/require(\"./utilities/json-schema\");\n\nconst schematic_engine_host_1 = /*#__PURE__*/require(\"./utilities/schematic-engine-host\");\n\nconst schematic_workflow_1 = /*#__PURE__*/require(\"./utilities/schematic-workflow\");\n\nexports.DEFAULT_SCHEMATICS_COLLECTION = '@schematics/angular';\n\nclass SchematicsCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.scope = command_module_1.CommandScope.In;\n    this.allowPrivateSchematics = false;\n    this.shouldReportAnalytics = false;\n    this.defaultProjectDeprecationWarningShown = false;\n  }\n\n  builder(argv) {\n    return _asyncToGenerator(function* () {\n      return argv.option('interactive', {\n        describe: 'Enable interactive input prompts.',\n        type: 'boolean',\n        default: true\n      }).option('dry-run', {\n        describe: 'Run through and reports activity without writing out results.',\n        type: 'boolean',\n        default: false\n      }).option('defaults', {\n        describe: 'Disable interactive input prompts for options with a default.',\n        type: 'boolean',\n        default: false\n      }).option('force', {\n        describe: 'Force overwriting of existing files.',\n        type: 'boolean',\n        default: false\n      }).strict();\n    })();\n  }\n  /** Get schematic schema options.*/\n\n\n  getSchematicOptions(collection, schematicName, workflow) {\n    return _asyncToGenerator(function* () {\n      const schematic = collection.createSchematic(schematicName, true);\n      const {\n        schemaJson\n      } = schematic.description;\n\n      if (!schemaJson) {\n        return [];\n      }\n\n      return (0, json_schema_1.parseJsonSchemaToOptions)(workflow.registry, schemaJson);\n    })();\n  }\n\n  getOrCreateWorkflowForBuilder(collectionName) {\n    return new tools_1.NodeWorkflow(this.context.root, {\n      resolvePaths: this.getResolvePaths(collectionName),\n      engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n    });\n  }\n\n  getOrCreateWorkflowForExecution(collectionName, options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger,\n        root,\n        packageManager\n      } = _this.context;\n      const {\n        force,\n        dryRun,\n        packageRegistry\n      } = options;\n      const workflow = new tools_1.NodeWorkflow(root, {\n        force,\n        dryRun,\n        packageManager: packageManager.name,\n        // A schema registry is required to allow customizing addUndefinedDefaults\n        registry: new core_1.schema.CoreSchemaRegistry(schematics_1.formats.standardFormats),\n        packageRegistry,\n        resolvePaths: _this.getResolvePaths(collectionName),\n        schemaValidation: true,\n        optionTransforms: [\n        /*#__PURE__*/\n        // Add configuration file defaults\n        function () {\n          var _ref = _asyncToGenerator(function* (schematic, current) {\n            const projectName = typeof (current === null || current === void 0 ? void 0 : current.project) === 'string' ? current.project : _this.getProjectName();\n            return { ...(yield (0, config_1.getSchematicDefaults)(schematic.collection.name, schematic.name, projectName)),\n              ...current\n            };\n          });\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }()],\n        engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n      });\n      workflow.registry.addPostTransform(core_1.schema.transforms.addUndefinedDefaults);\n      workflow.registry.useXDeprecatedProvider(msg => logger.warn(msg));\n      workflow.registry.addSmartDefaultProvider('projectName', () => _this.getProjectName());\n      const workingDir = (0, core_1.normalize)((0, path_1.relative)(_this.context.root, process.cwd()));\n      workflow.registry.addSmartDefaultProvider('workingDirectory', () => workingDir === '' ? undefined : workingDir);\n      let shouldReportAnalytics = true;\n      workflow.engineHost.registerOptionsTransform( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (schematic, options) {\n          var _a;\n\n          if (shouldReportAnalytics) {\n            shouldReportAnalytics = false; // ng generate lib -> ng generate\n\n            const commandName = (_a = _this.command) === null || _a === void 0 ? void 0 : _a.split(' ', 1)[0];\n            yield _this.reportAnalytics(options, [commandName, schematic.collection.name.replace(/\\//g, '_'), schematic.name.replace(/\\//g, '_')]);\n          } // TODO: The below should be removed in version 15 when we change 1P schematics to use the `workingDirectory smart default`.\n          // Handle `\"format\": \"path\"` options.\n\n\n          const schema = schematic === null || schematic === void 0 ? void 0 : schematic.schemaJson;\n\n          if (!options || !schema || !(0, core_1.isJsonObject)(schema)) {\n            return options;\n          }\n\n          if (!('path' in options && options['path'] === undefined)) {\n            return options;\n          }\n\n          const properties = schema === null || schema === void 0 ? void 0 : schema['properties'];\n\n          if (!properties || !(0, core_1.isJsonObject)(properties)) {\n            return options;\n          }\n\n          const property = properties['path'];\n\n          if (!property || !(0, core_1.isJsonObject)(property)) {\n            return options;\n          }\n\n          if (property['format'] === 'path' && !property['$default']) {\n            options['path'] = workingDir || undefined;\n\n            _this.context.logger.warn(`The 'path' option in '${schematic === null || schematic === void 0 ? void 0 : schematic.schema}' is using deprecated behaviour. ` + `'workingDirectory' smart default provider should be used instead.`);\n          }\n\n          return options;\n        });\n\n        return function (_x3, _x4) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n\n      if (options.interactive !== false && (0, tty_1.isTTY)()) {\n        workflow.registry.usePromptProvider( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (definitions) {\n            const questions = definitions.filter(definition => !options.defaults || definition.default === undefined).map(definition => {\n              var _a;\n\n              const question = {\n                name: definition.id,\n                message: definition.message,\n                default: definition.default\n              };\n              const validator = definition.validator;\n\n              if (validator) {\n                question.validate = input => validator(input); // Filter allows transformation of the value prior to validation\n\n\n                question.filter = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator(function* (input) {\n                    for (const type of definition.propertyTypes) {\n                      let value;\n\n                      switch (type) {\n                        case 'string':\n                          value = String(input);\n                          break;\n\n                        case 'integer':\n                        case 'number':\n                          value = Number(input);\n                          break;\n\n                        default:\n                          value = input;\n                          break;\n                      } // Can be a string if validation fails\n\n\n                      const isValid = (yield validator(value)) === true;\n\n                      if (isValid) {\n                        return value;\n                      }\n                    }\n\n                    return input;\n                  });\n\n                  return function (_x6) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n              }\n\n              switch (definition.type) {\n                case 'confirmation':\n                  question.type = 'confirm';\n                  break;\n\n                case 'list':\n                  question.type = definition.multiselect ? 'checkbox' : 'list';\n                  question.choices = (_a = definition.items) === null || _a === void 0 ? void 0 : _a.map(item => {\n                    return typeof item == 'string' ? item : {\n                      name: item.label,\n                      value: item.value\n                    };\n                  });\n                  break;\n\n                default:\n                  question.type = definition.type;\n                  break;\n              }\n\n              return question;\n            });\n\n            if (questions.length) {\n              const {\n                prompt\n              } = yield Promise.resolve().then(() => __importStar(require('inquirer')));\n              return prompt(questions);\n            } else {\n              return {};\n            }\n          });\n\n          return function (_x5) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      }\n\n      return workflow;\n    })();\n  }\n\n  getSchematicCollections() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a; // Resolve relative collections from the location of `angular.json`\n\n\n      const resolveRelativeCollection = collectionName => collectionName.charAt(0) === '.' ? (0, path_1.resolve)(_this2.context.root, collectionName) : collectionName;\n\n      const getSchematicCollections = configSection => {\n        if (!configSection) {\n          return undefined;\n        }\n\n        const {\n          schematicCollections,\n          defaultCollection\n        } = configSection;\n\n        if (Array.isArray(schematicCollections)) {\n          return new Set(schematicCollections.map(c => resolveRelativeCollection(c)));\n        } else if (typeof defaultCollection === 'string') {\n          return new Set([resolveRelativeCollection(defaultCollection)]);\n        }\n\n        return undefined;\n      };\n\n      const {\n        workspace,\n        globalConfiguration\n      } = _this2.context;\n\n      if (workspace) {\n        const project = (0, config_1.getProjectByCwd)(workspace);\n\n        if (project) {\n          const value = getSchematicCollections(workspace.getProjectCli(project));\n\n          if (value) {\n            return value;\n          }\n        }\n      }\n\n      const value = (_a = getSchematicCollections(workspace === null || workspace === void 0 ? void 0 : workspace.getCli())) !== null && _a !== void 0 ? _a : getSchematicCollections(globalConfiguration.getCli());\n\n      if (value) {\n        return value;\n      }\n\n      return new Set([exports.DEFAULT_SCHEMATICS_COLLECTION]);\n    })();\n  }\n\n  parseSchematicInfo(schematic) {\n    if (schematic === null || schematic === void 0 ? void 0 : schematic.includes(':')) {\n      const [collectionName, schematicName] = schematic.split(':', 2);\n      return [collectionName, schematicName];\n    }\n\n    return [undefined, schematic];\n  }\n\n  runSchematic(options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this3.context;\n      const {\n        schematicOptions,\n        executionOptions,\n        collectionName,\n        schematicName\n      } = options;\n      const workflow = yield _this3.getOrCreateWorkflowForExecution(collectionName, executionOptions);\n\n      if (!schematicName) {\n        throw new Error('schematicName cannot be undefined.');\n      }\n\n      const {\n        unsubscribe,\n        files\n      } = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger);\n\n      try {\n        yield workflow.execute({\n          collection: collectionName,\n          schematic: schematicName,\n          options: schematicOptions,\n          logger,\n          allowPrivate: _this3.allowPrivateSchematics\n        }).toPromise();\n\n        if (!files.size) {\n          logger.info('Nothing to be done.');\n        }\n\n        if (executionOptions.dryRun) {\n          logger.warn(`\\nNOTE: The \"--dry-run\" option means no changes were made.`);\n        }\n      } catch (err) {\n        // In case the workflow was not successful, show an appropriate error message.\n        if (err instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n          // \"See above\" because we already printed the error.\n          logger.fatal('The Schematic workflow failed. See above.');\n        } else {\n          (0, error_1.assertIsError)(err);\n          logger.fatal(err.message);\n        }\n\n        return 1;\n      } finally {\n        unsubscribe();\n      }\n\n      return 0;\n    })();\n  }\n\n  getProjectName() {\n    const {\n      workspace,\n      logger\n    } = this.context;\n\n    if (!workspace) {\n      return undefined;\n    }\n\n    const projectName = (0, config_1.getProjectByCwd)(workspace);\n\n    if (projectName) {\n      return projectName;\n    }\n\n    const defaultProjectName = workspace.extensions['defaultProject'];\n\n    if (typeof defaultProjectName === 'string' && defaultProjectName) {\n      if (!this.defaultProjectDeprecationWarningShown) {\n        logger.warn(core_1.tags.oneLine`\n             DEPRECATED: The 'defaultProject' workspace option has been deprecated.\n             The project to use will be determined from the current working directory.\n           `);\n        this.defaultProjectDeprecationWarningShown = true;\n      }\n\n      return defaultProjectName;\n    }\n\n    return undefined;\n  }\n\n  getResolvePaths(collectionName) {\n    const {\n      workspace,\n      root\n    } = this.context;\n    return workspace ? // Workspace\n    collectionName === exports.DEFAULT_SCHEMATICS_COLLECTION ? // Favor __dirname for @schematics/angular to use the build-in version\n    [__dirname, process.cwd(), root] : [process.cwd(), root, __dirname] : // Global\n    [__dirname, process.cwd()];\n  }\n\n}\n\n__decorate([memoize_1.memoize], SchematicsCommandModule.prototype, \"getOrCreateWorkflowForBuilder\", null);\n\n__decorate([memoize_1.memoize], SchematicsCommandModule.prototype, \"getOrCreateWorkflowForExecution\", null);\n\n__decorate([memoize_1.memoize], SchematicsCommandModule.prototype, \"getSchematicCollections\", null);\n\nexports.SchematicsCommandModule = SchematicsCommandModule;","map":null,"metadata":{},"sourceType":"script"}