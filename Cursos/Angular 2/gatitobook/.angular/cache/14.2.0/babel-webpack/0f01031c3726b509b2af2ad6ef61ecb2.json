{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // identity function for calling harmony imports with the correct context\n\n  /******/\n\n  __webpack_require__.i = function (value) {\n    return value;\n  };\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        /******/\n        configurable: false,\n\n        /******/\n        enumerable: true,\n\n        /******/\n        get: getter\n        /******/\n\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 14);\n  /******/\n}\n/************************************************************************/\n\n/******/\n([\n  /* 8 */\n\n  /* 10 */\n\n  /* 15 */\n\n  /* 16 */\n\n  /* 18 */\n\n  /* 19 */\n\n  /* 21 */\n\n  /* 24 */\n\n  /* 25 */\n\n  /* 26 */\n\n  /* 28 */\n\n  /* 30 */\n\n  /* 37 */\n\n  /* 38 */\n\n  /* 39 */\n\n  /* 43 */\n\n  /* 44 */\n\n  /* 51 */\n\n  /* 52 */\n\n  /* 53 */\n\n  /* 56 */\n\n  /* 57 */\n\n  /* 58 */\n\n  /* 59 */\n\n  /* 62 */\n\n  /* 64 */\n\n  /* 65 */\n\n  /* 66 */\n\n  /* 77 */\n\n  /* 78 */\n\n  /* 80 */\n\n  /* 82 */\n\n  /* 83 */\n\n  /* 86 */\n\n  /* 87 */\n\n  /* 88 */\n\n  /* 89 */\n\n  /* 90 */\n\n  /* 91 */\n\n  /* 92 */\n\n  /* 93 */\n\n  /* 94 */\n\n  /* 95 */\n\n  /* 96 */\n\n  /* 97 */\n\n  /* 98 */\n\n  /* 99 */\n\n  /* 113 */\n\n  /* 117 */\n\n  /* 118 */\n\n  /* 119 */\n\n  /* 120 */\n\n  /* 121 */\n\n  /* 124 */\n\n  /* 125 */\n\n  /* 126 */\n\n  /* 127 */\n\n  /* 128 */\n\n  /* 129 */\n\n  /* 130 */\n\n  /* 134 */\n\n  /* 135 */\n\n  /* 136 */\n\n  /* 137 */\n\n  /* 138 */\n\n  /* 139 */\n\n  /* 140 */\n\n  /* 141 */\n\n  /* 142 */\n\n  /* 143 */\n\n  /* 144 */\n\n  /* 146 */\n\n  /* 147 */\n\n  /* 148 */\n\n  /* 149 */\n\n  /* 151 */\n\n  /* 152 */\n\n  /* 153 */\n\n  /* 154 */\n\n  /* 155 */\n\n  /* 156 */\n\n  /* 157 */\n\n  /* 158 */\n\n  /* 159 */\n\n  /* 160 */\n\n  /* 161 */\n\n  /* 162 */\n\n  /* 163 */\n\n  /* 165 */\n\n  /* 166 */\n\n  /* 167 */\n\n  /* 168 */\n\n  /* 170 */\n\n  /* 172 */\n\n  /* 177 */\n\n  /* 214 */\n\n  /* 215 */\n\n  /* 216 */\n\n  /* 219 */\n\n  /* 220 */\n\n  /* 222 */\n\n  /* 225 */\n\n  /* 226 */\n\n  /* 228 */\n\n  /* 230 */\n\n  /* 231 */\n\n  /* 232 */\n\n  /* 234 */\n\n  /* 235 */\n\n  /* 236 */\n\n  /* 237 */\n\n  /* 238 */\n\n/* 0 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"path\");\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  exports.__esModule = true;\n\n  var _promise = __webpack_require__(173);\n\n  var _promise2 = _interopRequireDefault(_promise);\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  exports.default = function (fn) {\n    return function () {\n      var gen = fn.apply(this, arguments);\n      return new _promise2.default(function (resolve, reject) {\n        function step(key, arg) {\n          try {\n            var info = gen[key](arg);\n            var value = info.value;\n          } catch (error) {\n            reject(error);\n            return;\n          }\n\n          if (info.done) {\n            resolve(value);\n          } else {\n            return _promise2.default.resolve(value).then(function (value) {\n              step(\"next\", value);\n            }, function (err) {\n              step(\"throw\", err);\n            });\n          }\n        }\n\n        return step(\"next\");\n      });\n    };\n  };\n  /***/\n\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"util\");\n  /***/\n},\n/* 3 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"fs\");\n  /***/\n},\n/* 4 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  class MessageError extends Error {\n    constructor(msg, code) {\n      super(msg);\n      this.code = code;\n    }\n\n  }\n\n  exports.MessageError = MessageError;\n\n  class ProcessSpawnError extends MessageError {\n    constructor(msg, code, process) {\n      super(msg, code);\n      this.process = process;\n    }\n\n  }\n\n  exports.ProcessSpawnError = ProcessSpawnError;\n\n  class SecurityError extends MessageError {}\n\n  exports.SecurityError = SecurityError;\n\n  class ProcessTermError extends MessageError {}\n\n  exports.ProcessTermError = ProcessTermError;\n\n  class ResponseError extends Error {\n    constructor(msg, responseCode) {\n      super(msg);\n      this.responseCode = responseCode;\n    }\n\n  }\n\n  exports.ResponseError = ResponseError;\n  /***/\n},\n/* 5 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getFirstSuitableFolder = exports.readFirstAvailableStream = exports.makeTempDir = exports.hardlinksWork = exports.writeFilePreservingEol = exports.getFileSizeOnDisk = exports.walk = exports.symlink = exports.find = exports.readJsonAndFile = exports.readJson = exports.readFileAny = exports.hardlinkBulk = exports.copyBulk = exports.unlink = exports.glob = exports.link = exports.chmod = exports.lstat = exports.exists = exports.mkdirp = exports.stat = exports.access = exports.rename = exports.readdir = exports.realpath = exports.readlink = exports.writeFile = exports.open = exports.readFileBuffer = exports.lockQueue = exports.constants = undefined;\n\n  var _asyncToGenerator2;\n\n  function _load_asyncToGenerator() {\n    return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n  }\n\n  let buildActionsForCopy = (() => {\n    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n      //\n      let build = (() => {\n        var _ref5 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n          const src = data.src,\n                dest = data.dest,\n                type = data.type;\n          const onFresh = data.onFresh || noop;\n          const onDone = data.onDone || noop; // TODO https://github.com/yarnpkg/yarn/issues/3751\n          // related to bundled dependencies handling\n\n          if (files.has(dest.toLowerCase())) {\n            reporter.verbose(`The case-insensitive file ${dest} shouldn't be copied twice in one bulk copy`);\n          } else {\n            files.add(dest.toLowerCase());\n          }\n\n          if (type === 'symlink') {\n            yield mkdirp((_path || _load_path()).default.dirname(dest));\n            onFresh();\n            actions.symlink.push({\n              dest,\n              linkname: src\n            });\n            onDone();\n            return;\n          }\n\n          if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {\n            // ignored file\n            return;\n          }\n\n          const srcStat = yield lstat(src);\n          let srcFiles;\n\n          if (srcStat.isDirectory()) {\n            srcFiles = yield readdir(src);\n          }\n\n          let destStat;\n\n          try {\n            // try accessing the destination\n            destStat = yield lstat(dest);\n          } catch (e) {\n            // proceed if destination doesn't exist, otherwise error\n            if (e.code !== 'ENOENT') {\n              throw e;\n            }\n          } // if destination exists\n\n\n          if (destStat) {\n            const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n            const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n            const bothFiles = srcStat.isFile() && destStat.isFile(); // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n            // us modes that aren't valid. investigate this, it's generally safe to proceed.\n\n            /* if (srcStat.mode !== destStat.mode) {\n              try {\n                await access(dest, srcStat.mode);\n              } catch (err) {}\n            } */\n\n            if (bothFiles && artifactFiles.has(dest)) {\n              // this file gets changed during build, likely by a custom install script. Don't bother checking it.\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));\n              return;\n            }\n\n            if (bothFiles && srcStat.size === destStat.size && (0, (_fsNormalized || _load_fsNormalized()).fileDatesEqual)(srcStat.mtime, destStat.mtime)) {\n              // we can safely assume this is the same file\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.size, +srcStat.mtime));\n              return;\n            }\n\n            if (bothSymlinks) {\n              const srcReallink = yield readlink(src);\n\n              if (srcReallink === (yield readlink(dest))) {\n                // if both symlinks are the same then we can continue on\n                onDone();\n                reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n                return;\n              }\n            }\n\n            if (bothFolders) {\n              // mark files that aren't in this folder as possibly extraneous\n              const destFiles = yield readdir(dest);\n              invariant(srcFiles, 'src files not initialised');\n\n              for (var _iterator4 = destFiles, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {\n                var _ref6;\n\n                if (_isArray4) {\n                  if (_i4 >= _iterator4.length) break;\n                  _ref6 = _iterator4[_i4++];\n                } else {\n                  _i4 = _iterator4.next();\n                  if (_i4.done) break;\n                  _ref6 = _i4.value;\n                }\n\n                const file = _ref6;\n\n                if (srcFiles.indexOf(file) < 0) {\n                  const loc = (_path || _load_path()).default.join(dest, file);\n\n                  possibleExtraneous.add(loc);\n\n                  if ((yield lstat(loc)).isDirectory()) {\n                    for (var _iterator5 = yield readdir(loc), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {\n                      var _ref7;\n\n                      if (_isArray5) {\n                        if (_i5 >= _iterator5.length) break;\n                        _ref7 = _iterator5[_i5++];\n                      } else {\n                        _i5 = _iterator5.next();\n                        if (_i5.done) break;\n                        _ref7 = _i5.value;\n                      }\n\n                      const file = _ref7;\n                      possibleExtraneous.add((_path || _load_path()).default.join(loc, file));\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (destStat && destStat.isSymbolicLink()) {\n            yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);\n            destStat = null;\n          }\n\n          if (srcStat.isSymbolicLink()) {\n            onFresh();\n            const linkname = yield readlink(src);\n            actions.symlink.push({\n              dest,\n              linkname\n            });\n            onDone();\n          } else if (srcStat.isDirectory()) {\n            if (!destStat) {\n              reporter.verbose(reporter.lang('verboseFileFolder', dest));\n              yield mkdirp(dest);\n            }\n\n            const destParts = dest.split((_path || _load_path()).default.sep);\n\n            while (destParts.length) {\n              files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());\n              destParts.pop();\n            } // push all files to queue\n\n\n            invariant(srcFiles, 'src files not initialised');\n            let remaining = srcFiles.length;\n\n            if (!remaining) {\n              onDone();\n            }\n\n            for (var _iterator6 = srcFiles, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {\n              var _ref8;\n\n              if (_isArray6) {\n                if (_i6 >= _iterator6.length) break;\n                _ref8 = _iterator6[_i6++];\n              } else {\n                _i6 = _iterator6.next();\n                if (_i6.done) break;\n                _ref8 = _i6.value;\n              }\n\n              const file = _ref8;\n              queue.push({\n                dest: (_path || _load_path()).default.join(dest, file),\n                onFresh,\n                onDone: function (_onDone) {\n                  function onDone() {\n                    return _onDone.apply(this, arguments);\n                  }\n\n                  onDone.toString = function () {\n                    return _onDone.toString();\n                  };\n\n                  return onDone;\n                }(function () {\n                  if (--remaining === 0) {\n                    onDone();\n                  }\n                }),\n                src: (_path || _load_path()).default.join(src, file)\n              });\n            }\n          } else if (srcStat.isFile()) {\n            onFresh();\n            actions.file.push({\n              src,\n              dest,\n              atime: srcStat.atime,\n              mtime: srcStat.mtime,\n              mode: srcStat.mode\n            });\n            onDone();\n          } else {\n            throw new Error(`unsure how to copy this: ${src}`);\n          }\n        });\n\n        return function build(_x5) {\n          return _ref5.apply(this, arguments);\n        };\n      })();\n\n      const artifactFiles = new Set(events.artifactFiles || []);\n      const files = new Set(); // initialise events\n\n      for (var _iterator = queue, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref2 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref2 = _i.value;\n        }\n\n        const item = _ref2;\n        const onDone = item.onDone;\n\n        item.onDone = function () {\n          events.onProgress(item.dest);\n\n          if (onDone) {\n            onDone();\n          }\n        };\n      }\n\n      events.onStart(queue.length); // start building actions\n\n      const actions = {\n        file: [],\n        symlink: [],\n        link: []\n      }; // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n      // at a time due to the requirement to push items onto the queue\n\n      while (queue.length) {\n        const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n        yield Promise.all(items.map(build));\n      } // simulate the existence of some files to prevent considering them extraneous\n\n\n      for (var _iterator2 = artifactFiles, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref3 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref3 = _i2.value;\n        }\n\n        const file = _ref3;\n\n        if (possibleExtraneous.has(file)) {\n          reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n          possibleExtraneous.delete(file);\n        }\n      }\n\n      for (var _iterator3 = possibleExtraneous, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        const loc = _ref4;\n\n        if (files.has(loc.toLowerCase())) {\n          possibleExtraneous.delete(loc);\n        }\n      }\n\n      return actions;\n    });\n\n    return function buildActionsForCopy(_x, _x2, _x3, _x4) {\n      return _ref.apply(this, arguments);\n    };\n  })();\n\n  let buildActionsForHardlink = (() => {\n    var _ref9 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, events, possibleExtraneous, reporter) {\n      //\n      let build = (() => {\n        var _ref13 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n          const src = data.src,\n                dest = data.dest;\n          const onFresh = data.onFresh || noop;\n          const onDone = data.onDone || noop;\n\n          if (files.has(dest.toLowerCase())) {\n            // Fixes issue https://github.com/yarnpkg/yarn/issues/2734\n            // When bulk hardlinking we have A -> B structure that we want to hardlink to A1 -> B1,\n            // package-linker passes that modules A1 and B1 need to be hardlinked,\n            // the recursive linking algorithm of A1 ends up scheduling files in B1 to be linked twice which will case\n            // an exception.\n            onDone();\n            return;\n          }\n\n          files.add(dest.toLowerCase());\n\n          if (events.ignoreBasenames.indexOf((_path || _load_path()).default.basename(src)) >= 0) {\n            // ignored file\n            return;\n          }\n\n          const srcStat = yield lstat(src);\n          let srcFiles;\n\n          if (srcStat.isDirectory()) {\n            srcFiles = yield readdir(src);\n          }\n\n          const destExists = yield exists(dest);\n\n          if (destExists) {\n            const destStat = yield lstat(dest);\n            const bothSymlinks = srcStat.isSymbolicLink() && destStat.isSymbolicLink();\n            const bothFolders = srcStat.isDirectory() && destStat.isDirectory();\n            const bothFiles = srcStat.isFile() && destStat.isFile();\n\n            if (srcStat.mode !== destStat.mode) {\n              try {\n                yield access(dest, srcStat.mode);\n              } catch (err) {\n                // EINVAL access errors sometimes happen which shouldn't because node shouldn't be giving\n                // us modes that aren't valid. investigate this, it's generally safe to proceed.\n                reporter.verbose(err);\n              }\n            }\n\n            if (bothFiles && artifactFiles.has(dest)) {\n              // this file gets changed during build, likely by a custom install script. Don't bother checking it.\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkipArtifact', src));\n              return;\n            } // correct hardlink\n\n\n            if (bothFiles && srcStat.ino !== null && srcStat.ino === destStat.ino) {\n              onDone();\n              reporter.verbose(reporter.lang('verboseFileSkip', src, dest, srcStat.ino));\n              return;\n            }\n\n            if (bothSymlinks) {\n              const srcReallink = yield readlink(src);\n\n              if (srcReallink === (yield readlink(dest))) {\n                // if both symlinks are the same then we can continue on\n                onDone();\n                reporter.verbose(reporter.lang('verboseFileSkipSymlink', src, dest, srcReallink));\n                return;\n              }\n            }\n\n            if (bothFolders) {\n              // mark files that aren't in this folder as possibly extraneous\n              const destFiles = yield readdir(dest);\n              invariant(srcFiles, 'src files not initialised');\n\n              for (var _iterator10 = destFiles, _isArray10 = Array.isArray(_iterator10), _i10 = 0, _iterator10 = _isArray10 ? _iterator10 : _iterator10[Symbol.iterator]();;) {\n                var _ref14;\n\n                if (_isArray10) {\n                  if (_i10 >= _iterator10.length) break;\n                  _ref14 = _iterator10[_i10++];\n                } else {\n                  _i10 = _iterator10.next();\n                  if (_i10.done) break;\n                  _ref14 = _i10.value;\n                }\n\n                const file = _ref14;\n\n                if (srcFiles.indexOf(file) < 0) {\n                  const loc = (_path || _load_path()).default.join(dest, file);\n\n                  possibleExtraneous.add(loc);\n\n                  if ((yield lstat(loc)).isDirectory()) {\n                    for (var _iterator11 = yield readdir(loc), _isArray11 = Array.isArray(_iterator11), _i11 = 0, _iterator11 = _isArray11 ? _iterator11 : _iterator11[Symbol.iterator]();;) {\n                      var _ref15;\n\n                      if (_isArray11) {\n                        if (_i11 >= _iterator11.length) break;\n                        _ref15 = _iterator11[_i11++];\n                      } else {\n                        _i11 = _iterator11.next();\n                        if (_i11.done) break;\n                        _ref15 = _i11.value;\n                      }\n\n                      const file = _ref15;\n                      possibleExtraneous.add((_path || _load_path()).default.join(loc, file));\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          if (srcStat.isSymbolicLink()) {\n            onFresh();\n            const linkname = yield readlink(src);\n            actions.symlink.push({\n              dest,\n              linkname\n            });\n            onDone();\n          } else if (srcStat.isDirectory()) {\n            reporter.verbose(reporter.lang('verboseFileFolder', dest));\n            yield mkdirp(dest);\n            const destParts = dest.split((_path || _load_path()).default.sep);\n\n            while (destParts.length) {\n              files.add(destParts.join((_path || _load_path()).default.sep).toLowerCase());\n              destParts.pop();\n            } // push all files to queue\n\n\n            invariant(srcFiles, 'src files not initialised');\n            let remaining = srcFiles.length;\n\n            if (!remaining) {\n              onDone();\n            }\n\n            for (var _iterator12 = srcFiles, _isArray12 = Array.isArray(_iterator12), _i12 = 0, _iterator12 = _isArray12 ? _iterator12 : _iterator12[Symbol.iterator]();;) {\n              var _ref16;\n\n              if (_isArray12) {\n                if (_i12 >= _iterator12.length) break;\n                _ref16 = _iterator12[_i12++];\n              } else {\n                _i12 = _iterator12.next();\n                if (_i12.done) break;\n                _ref16 = _i12.value;\n              }\n\n              const file = _ref16;\n              queue.push({\n                onFresh,\n                src: (_path || _load_path()).default.join(src, file),\n                dest: (_path || _load_path()).default.join(dest, file),\n                onDone: function (_onDone2) {\n                  function onDone() {\n                    return _onDone2.apply(this, arguments);\n                  }\n\n                  onDone.toString = function () {\n                    return _onDone2.toString();\n                  };\n\n                  return onDone;\n                }(function () {\n                  if (--remaining === 0) {\n                    onDone();\n                  }\n                })\n              });\n            }\n          } else if (srcStat.isFile()) {\n            onFresh();\n            actions.link.push({\n              src,\n              dest,\n              removeDest: destExists\n            });\n            onDone();\n          } else {\n            throw new Error(`unsure how to copy this: ${src}`);\n          }\n        });\n\n        return function build(_x10) {\n          return _ref13.apply(this, arguments);\n        };\n      })();\n\n      const artifactFiles = new Set(events.artifactFiles || []);\n      const files = new Set(); // initialise events\n\n      for (var _iterator7 = queue, _isArray7 = Array.isArray(_iterator7), _i7 = 0, _iterator7 = _isArray7 ? _iterator7 : _iterator7[Symbol.iterator]();;) {\n        var _ref10;\n\n        if (_isArray7) {\n          if (_i7 >= _iterator7.length) break;\n          _ref10 = _iterator7[_i7++];\n        } else {\n          _i7 = _iterator7.next();\n          if (_i7.done) break;\n          _ref10 = _i7.value;\n        }\n\n        const item = _ref10;\n        const onDone = item.onDone || noop;\n\n        item.onDone = function () {\n          events.onProgress(item.dest);\n          onDone();\n        };\n      }\n\n      events.onStart(queue.length); // start building actions\n\n      const actions = {\n        file: [],\n        symlink: [],\n        link: []\n      }; // custom concurrency logic as we're always executing stacks of CONCURRENT_QUEUE_ITEMS queue items\n      // at a time due to the requirement to push items onto the queue\n\n      while (queue.length) {\n        const items = queue.splice(0, CONCURRENT_QUEUE_ITEMS);\n        yield Promise.all(items.map(build));\n      } // simulate the existence of some files to prevent considering them extraneous\n\n\n      for (var _iterator8 = artifactFiles, _isArray8 = Array.isArray(_iterator8), _i8 = 0, _iterator8 = _isArray8 ? _iterator8 : _iterator8[Symbol.iterator]();;) {\n        var _ref11;\n\n        if (_isArray8) {\n          if (_i8 >= _iterator8.length) break;\n          _ref11 = _iterator8[_i8++];\n        } else {\n          _i8 = _iterator8.next();\n          if (_i8.done) break;\n          _ref11 = _i8.value;\n        }\n\n        const file = _ref11;\n\n        if (possibleExtraneous.has(file)) {\n          reporter.verbose(reporter.lang('verboseFilePhantomExtraneous', file));\n          possibleExtraneous.delete(file);\n        }\n      }\n\n      for (var _iterator9 = possibleExtraneous, _isArray9 = Array.isArray(_iterator9), _i9 = 0, _iterator9 = _isArray9 ? _iterator9 : _iterator9[Symbol.iterator]();;) {\n        var _ref12;\n\n        if (_isArray9) {\n          if (_i9 >= _iterator9.length) break;\n          _ref12 = _iterator9[_i9++];\n        } else {\n          _i9 = _iterator9.next();\n          if (_i9.done) break;\n          _ref12 = _i9.value;\n        }\n\n        const loc = _ref12;\n\n        if (files.has(loc.toLowerCase())) {\n          possibleExtraneous.delete(loc);\n        }\n      }\n\n      return actions;\n    });\n\n    return function buildActionsForHardlink(_x6, _x7, _x8, _x9) {\n      return _ref9.apply(this, arguments);\n    };\n  })();\n\n  let copyBulk = exports.copyBulk = (() => {\n    var _ref17 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n      const events = {\n        onStart: _events && _events.onStart || noop,\n        onProgress: _events && _events.onProgress || noop,\n        possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n        ignoreBasenames: _events && _events.ignoreBasenames || [],\n        artifactFiles: _events && _events.artifactFiles || []\n      };\n      const actions = yield buildActionsForCopy(queue, events, events.possibleExtraneous, reporter);\n      events.onStart(actions.file.length + actions.symlink.length + actions.link.length);\n      const fileActions = actions.file;\n      const currentlyWriting = new Map();\n      yield (_promise || _load_promise()).queue(fileActions, (() => {\n        var _ref18 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n          let writePromise;\n\n          while (writePromise = currentlyWriting.get(data.dest)) {\n            yield writePromise;\n          }\n\n          reporter.verbose(reporter.lang('verboseFileCopy', data.src, data.dest));\n          const copier = (0, (_fsNormalized || _load_fsNormalized()).copyFile)(data, function () {\n            return currentlyWriting.delete(data.dest);\n          });\n          currentlyWriting.set(data.dest, copier);\n          events.onProgress(data.dest);\n          return copier;\n        });\n\n        return function (_x14) {\n          return _ref18.apply(this, arguments);\n        };\n      })(), CONCURRENT_QUEUE_ITEMS); // we need to copy symlinks last as they could reference files we were copying\n\n      const symlinkActions = actions.symlink;\n      yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n        const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);\n\n        reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n        return symlink(linkname, data.dest);\n      });\n    });\n\n    return function copyBulk(_x11, _x12, _x13) {\n      return _ref17.apply(this, arguments);\n    };\n  })();\n\n  let hardlinkBulk = exports.hardlinkBulk = (() => {\n    var _ref19 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (queue, reporter, _events) {\n      const events = {\n        onStart: _events && _events.onStart || noop,\n        onProgress: _events && _events.onProgress || noop,\n        possibleExtraneous: _events ? _events.possibleExtraneous : new Set(),\n        artifactFiles: _events && _events.artifactFiles || [],\n        ignoreBasenames: []\n      };\n      const actions = yield buildActionsForHardlink(queue, events, events.possibleExtraneous, reporter);\n      events.onStart(actions.file.length + actions.symlink.length + actions.link.length);\n      const fileActions = actions.link;\n      yield (_promise || _load_promise()).queue(fileActions, (() => {\n        var _ref20 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data) {\n          reporter.verbose(reporter.lang('verboseFileLink', data.src, data.dest));\n\n          if (data.removeDest) {\n            yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(data.dest);\n          }\n\n          yield link(data.src, data.dest);\n        });\n\n        return function (_x18) {\n          return _ref20.apply(this, arguments);\n        };\n      })(), CONCURRENT_QUEUE_ITEMS); // we need to copy symlinks last as they could reference files we were copying\n\n      const symlinkActions = actions.symlink;\n      yield (_promise || _load_promise()).queue(symlinkActions, function (data) {\n        const linkname = (_path || _load_path()).default.resolve((_path || _load_path()).default.dirname(data.dest), data.linkname);\n\n        reporter.verbose(reporter.lang('verboseFileSymlink', data.dest, linkname));\n        return symlink(linkname, data.dest);\n      });\n    });\n\n    return function hardlinkBulk(_x15, _x16, _x17) {\n      return _ref19.apply(this, arguments);\n    };\n  })();\n\n  let readFileAny = exports.readFileAny = (() => {\n    var _ref21 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (files) {\n      for (var _iterator13 = files, _isArray13 = Array.isArray(_iterator13), _i13 = 0, _iterator13 = _isArray13 ? _iterator13 : _iterator13[Symbol.iterator]();;) {\n        var _ref22;\n\n        if (_isArray13) {\n          if (_i13 >= _iterator13.length) break;\n          _ref22 = _iterator13[_i13++];\n        } else {\n          _i13 = _iterator13.next();\n          if (_i13.done) break;\n          _ref22 = _i13.value;\n        }\n\n        const file = _ref22;\n\n        if (yield exists(file)) {\n          return readFile(file);\n        }\n      }\n\n      return null;\n    });\n\n    return function readFileAny(_x19) {\n      return _ref21.apply(this, arguments);\n    };\n  })();\n\n  let readJson = exports.readJson = (() => {\n    var _ref23 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n      return (yield readJsonAndFile(loc)).object;\n    });\n\n    return function readJson(_x20) {\n      return _ref23.apply(this, arguments);\n    };\n  })();\n\n  let readJsonAndFile = exports.readJsonAndFile = (() => {\n    var _ref24 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n      const file = yield readFile(loc);\n\n      try {\n        return {\n          object: (0, (_map || _load_map()).default)(JSON.parse(stripBOM(file))),\n          content: file\n        };\n      } catch (err) {\n        err.message = `${loc}: ${err.message}`;\n        throw err;\n      }\n    });\n\n    return function readJsonAndFile(_x21) {\n      return _ref24.apply(this, arguments);\n    };\n  })();\n\n  let find = exports.find = (() => {\n    var _ref25 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (filename, dir) {\n      const parts = dir.split((_path || _load_path()).default.sep);\n\n      while (parts.length) {\n        const loc = parts.concat(filename).join((_path || _load_path()).default.sep);\n\n        if (yield exists(loc)) {\n          return loc;\n        } else {\n          parts.pop();\n        }\n      }\n\n      return false;\n    });\n\n    return function find(_x22, _x23) {\n      return _ref25.apply(this, arguments);\n    };\n  })();\n\n  let symlink = exports.symlink = (() => {\n    var _ref26 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest) {\n      try {\n        const stats = yield lstat(dest);\n\n        if (stats.isSymbolicLink()) {\n          const resolved = yield realpath(dest);\n\n          if (resolved === src) {\n            return;\n          }\n        }\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      } // We use rimraf for unlink which never throws an ENOENT on missing target\n\n\n      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dest);\n\n      if (process.platform === 'win32') {\n        // use directory junctions if possible on win32, this requires absolute paths\n        yield fsSymlink(src, dest, 'junction');\n      } else {\n        // use relative paths otherwise which will be retained if the directory is moved\n        let relative;\n\n        try {\n          relative = (_path || _load_path()).default.relative((_fs || _load_fs()).default.realpathSync((_path || _load_path()).default.dirname(dest)), (_fs || _load_fs()).default.realpathSync(src));\n        } catch (err) {\n          if (err.code !== 'ENOENT') {\n            throw err;\n          }\n\n          relative = (_path || _load_path()).default.relative((_path || _load_path()).default.dirname(dest), src);\n        } // When path.relative returns an empty string for the current directory, we should instead use\n        // '.', which is a valid fs.symlink target.\n\n\n        yield fsSymlink(relative || '.', dest);\n      }\n    });\n\n    return function symlink(_x24, _x25) {\n      return _ref26.apply(this, arguments);\n    };\n  })();\n\n  let walk = exports.walk = (() => {\n    var _ref27 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir, relativeDir, ignoreBasenames = new Set()) {\n      let files = [];\n      let filenames = yield readdir(dir);\n\n      if (ignoreBasenames.size) {\n        filenames = filenames.filter(function (name) {\n          return !ignoreBasenames.has(name);\n        });\n      }\n\n      for (var _iterator14 = filenames, _isArray14 = Array.isArray(_iterator14), _i14 = 0, _iterator14 = _isArray14 ? _iterator14 : _iterator14[Symbol.iterator]();;) {\n        var _ref28;\n\n        if (_isArray14) {\n          if (_i14 >= _iterator14.length) break;\n          _ref28 = _iterator14[_i14++];\n        } else {\n          _i14 = _iterator14.next();\n          if (_i14.done) break;\n          _ref28 = _i14.value;\n        }\n\n        const name = _ref28;\n        const relative = relativeDir ? (_path || _load_path()).default.join(relativeDir, name) : name;\n\n        const loc = (_path || _load_path()).default.join(dir, name);\n\n        const stat = yield lstat(loc);\n        files.push({\n          relative,\n          basename: name,\n          absolute: loc,\n          mtime: +stat.mtime\n        });\n\n        if (stat.isDirectory()) {\n          files = files.concat(yield walk(loc, relative, ignoreBasenames));\n        }\n      }\n\n      return files;\n    });\n\n    return function walk(_x26, _x27) {\n      return _ref27.apply(this, arguments);\n    };\n  })();\n\n  let getFileSizeOnDisk = exports.getFileSizeOnDisk = (() => {\n    var _ref29 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (loc) {\n      const stat = yield lstat(loc);\n      const size = stat.size,\n            blockSize = stat.blksize;\n      return Math.ceil(size / blockSize) * blockSize;\n    });\n\n    return function getFileSizeOnDisk(_x28) {\n      return _ref29.apply(this, arguments);\n    };\n  })();\n\n  let getEolFromFile = (() => {\n    var _ref30 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path) {\n      if (!(yield exists(path))) {\n        return undefined;\n      }\n\n      const buffer = yield readFileBuffer(path);\n\n      for (let i = 0; i < buffer.length; ++i) {\n        if (buffer[i] === cr) {\n          return '\\r\\n';\n        }\n\n        if (buffer[i] === lf) {\n          return '\\n';\n        }\n      }\n\n      return undefined;\n    });\n\n    return function getEolFromFile(_x29) {\n      return _ref30.apply(this, arguments);\n    };\n  })();\n\n  let writeFilePreservingEol = exports.writeFilePreservingEol = (() => {\n    var _ref31 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (path, data) {\n      const eol = (yield getEolFromFile(path)) || (_os || _load_os()).default.EOL;\n\n      if (eol !== '\\n') {\n        data = data.replace(/\\n/g, eol);\n      }\n\n      yield writeFile(path, data);\n    });\n\n    return function writeFilePreservingEol(_x30, _x31) {\n      return _ref31.apply(this, arguments);\n    };\n  })();\n\n  let hardlinksWork = exports.hardlinksWork = (() => {\n    var _ref32 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (dir) {\n      const filename = 'test-file' + Math.random();\n\n      const file = (_path || _load_path()).default.join(dir, filename);\n\n      const fileLink = (_path || _load_path()).default.join(dir, filename + '-link');\n\n      try {\n        yield writeFile(file, 'test');\n        yield link(file, fileLink);\n      } catch (err) {\n        return false;\n      } finally {\n        yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(file);\n        yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(fileLink);\n      }\n\n      return true;\n    });\n\n    return function hardlinksWork(_x32) {\n      return _ref32.apply(this, arguments);\n    };\n  })(); // not a strict polyfill for Node's fs.mkdtemp\n\n\n  let makeTempDir = exports.makeTempDir = (() => {\n    var _ref33 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (prefix) {\n      const dir = (_path || _load_path()).default.join((_os || _load_os()).default.tmpdir(), `yarn-${prefix || ''}-${Date.now()}-${Math.random()}`);\n\n      yield (0, (_fsNormalized || _load_fsNormalized()).unlink)(dir);\n      yield mkdirp(dir);\n      return dir;\n    });\n\n    return function makeTempDir(_x33) {\n      return _ref33.apply(this, arguments);\n    };\n  })();\n\n  let readFirstAvailableStream = exports.readFirstAvailableStream = (() => {\n    var _ref34 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths) {\n      for (var _iterator15 = paths, _isArray15 = Array.isArray(_iterator15), _i15 = 0, _iterator15 = _isArray15 ? _iterator15 : _iterator15[Symbol.iterator]();;) {\n        var _ref35;\n\n        if (_isArray15) {\n          if (_i15 >= _iterator15.length) break;\n          _ref35 = _iterator15[_i15++];\n        } else {\n          _i15 = _iterator15.next();\n          if (_i15.done) break;\n          _ref35 = _i15.value;\n        }\n\n        const path = _ref35;\n\n        try {\n          const fd = yield open(path, 'r');\n          return (_fs || _load_fs()).default.createReadStream(path, {\n            fd\n          });\n        } catch (err) {// Try the next one\n        }\n      }\n\n      return null;\n    });\n\n    return function readFirstAvailableStream(_x34) {\n      return _ref34.apply(this, arguments);\n    };\n  })();\n\n  let getFirstSuitableFolder = exports.getFirstSuitableFolder = (() => {\n    var _ref36 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (paths, mode = constants.W_OK | constants.X_OK) {\n      const result = {\n        skipped: [],\n        folder: null\n      };\n\n      for (var _iterator16 = paths, _isArray16 = Array.isArray(_iterator16), _i16 = 0, _iterator16 = _isArray16 ? _iterator16 : _iterator16[Symbol.iterator]();;) {\n        var _ref37;\n\n        if (_isArray16) {\n          if (_i16 >= _iterator16.length) break;\n          _ref37 = _iterator16[_i16++];\n        } else {\n          _i16 = _iterator16.next();\n          if (_i16.done) break;\n          _ref37 = _i16.value;\n        }\n\n        const folder = _ref37;\n\n        try {\n          yield mkdirp(folder);\n          yield access(folder, mode);\n          result.folder = folder;\n          return result;\n        } catch (error) {\n          result.skipped.push({\n            error,\n            folder\n          });\n        }\n      }\n\n      return result;\n    });\n\n    return function getFirstSuitableFolder(_x35) {\n      return _ref36.apply(this, arguments);\n    };\n  })();\n\n  exports.copy = copy;\n  exports.readFile = readFile;\n  exports.readFileRaw = readFileRaw;\n  exports.normalizeOS = normalizeOS;\n\n  var _fs;\n\n  function _load_fs() {\n    return _fs = _interopRequireDefault(__webpack_require__(3));\n  }\n\n  var _glob;\n\n  function _load_glob() {\n    return _glob = _interopRequireDefault(__webpack_require__(75));\n  }\n\n  var _os;\n\n  function _load_os() {\n    return _os = _interopRequireDefault(__webpack_require__(36));\n  }\n\n  var _path;\n\n  function _load_path() {\n    return _path = _interopRequireDefault(__webpack_require__(0));\n  }\n\n  var _blockingQueue;\n\n  function _load_blockingQueue() {\n    return _blockingQueue = _interopRequireDefault(__webpack_require__(84));\n  }\n\n  var _promise;\n\n  function _load_promise() {\n    return _promise = _interopRequireWildcard(__webpack_require__(40));\n  }\n\n  var _promise2;\n\n  function _load_promise2() {\n    return _promise2 = __webpack_require__(40);\n  }\n\n  var _map;\n\n  function _load_map() {\n    return _map = _interopRequireDefault(__webpack_require__(20));\n  }\n\n  var _fsNormalized;\n\n  function _load_fsNormalized() {\n    return _fsNormalized = __webpack_require__(164);\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const constants = exports.constants = typeof (_fs || _load_fs()).default.constants !== 'undefined' ? (_fs || _load_fs()).default.constants : {\n    R_OK: (_fs || _load_fs()).default.R_OK,\n    W_OK: (_fs || _load_fs()).default.W_OK,\n    X_OK: (_fs || _load_fs()).default.X_OK\n  };\n  const lockQueue = exports.lockQueue = new (_blockingQueue || _load_blockingQueue()).default('fs lock');\n  const readFileBuffer = exports.readFileBuffer = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readFile);\n  const open = exports.open = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.open);\n  const writeFile = exports.writeFile = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.writeFile);\n  const readlink = exports.readlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readlink);\n  const realpath = exports.realpath = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.realpath);\n  const readdir = exports.readdir = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.readdir);\n  const rename = exports.rename = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.rename);\n  const access = exports.access = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.access);\n  const stat = exports.stat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.stat);\n  const mkdirp = exports.mkdirp = (0, (_promise2 || _load_promise2()).promisify)(__webpack_require__(116));\n  const exists = exports.exists = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.exists, true);\n  const lstat = exports.lstat = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.lstat);\n  const chmod = exports.chmod = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.chmod);\n  const link = exports.link = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.link);\n  const glob = exports.glob = (0, (_promise2 || _load_promise2()).promisify)((_glob || _load_glob()).default);\n  exports.unlink = (_fsNormalized || _load_fsNormalized()).unlink; // fs.copyFile uses the native file copying instructions on the system, performing much better\n  // than any JS-based solution and consumes fewer resources. Repeated testing to fine tune the\n  // concurrency level revealed 128 as the sweet spot on a quad-core, 16 CPU Intel system with SSD.\n\n  const CONCURRENT_QUEUE_ITEMS = (_fs || _load_fs()).default.copyFile ? 128 : 4;\n  const fsSymlink = (0, (_promise2 || _load_promise2()).promisify)((_fs || _load_fs()).default.symlink);\n\n  const invariant = __webpack_require__(7);\n\n  const stripBOM = __webpack_require__(122);\n\n  const noop = () => {};\n\n  function copy(src, dest, reporter) {\n    return copyBulk([{\n      src,\n      dest\n    }], reporter);\n  }\n\n  function _readFile(loc, encoding) {\n    return new Promise((resolve, reject) => {\n      (_fs || _load_fs()).default.readFile(loc, encoding, function (err, content) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(content);\n        }\n      });\n    });\n  }\n\n  function readFile(loc) {\n    return _readFile(loc, 'utf8').then(normalizeOS);\n  }\n\n  function readFileRaw(loc) {\n    return _readFile(loc, 'binary');\n  }\n\n  function normalizeOS(body) {\n    return body.replace(/\\r\\n/g, '\\n');\n  }\n\n  const cr = '\\r'.charCodeAt(0);\n  const lf = '\\n'.charCodeAt(0);\n  /***/\n},\n/* 6 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getPathKey = getPathKey;\n\n  const os = __webpack_require__(36);\n\n  const path = __webpack_require__(0);\n\n  const userHome = __webpack_require__(45).default;\n\n  var _require = __webpack_require__(171);\n\n  const getCacheDir = _require.getCacheDir,\n        getConfigDir = _require.getConfigDir,\n        getDataDir = _require.getDataDir;\n\n  const isWebpackBundle = __webpack_require__(227);\n\n  const DEPENDENCY_TYPES = exports.DEPENDENCY_TYPES = ['devDependencies', 'dependencies', 'optionalDependencies', 'peerDependencies'];\n  const RESOLUTIONS = exports.RESOLUTIONS = 'resolutions';\n  const MANIFEST_FIELDS = exports.MANIFEST_FIELDS = [RESOLUTIONS, ...DEPENDENCY_TYPES];\n  const SUPPORTED_NODE_VERSIONS = exports.SUPPORTED_NODE_VERSIONS = '^4.8.0 || ^5.7.0 || ^6.2.2 || >=8.0.0';\n  const YARN_REGISTRY = exports.YARN_REGISTRY = 'https://registry.yarnpkg.com';\n  const YARN_DOCS = exports.YARN_DOCS = 'https://yarnpkg.com/en/docs/cli/';\n  const YARN_INSTALLER_SH = exports.YARN_INSTALLER_SH = 'https://yarnpkg.com/install.sh';\n  const YARN_INSTALLER_MSI = exports.YARN_INSTALLER_MSI = 'https://yarnpkg.com/latest.msi';\n  const SELF_UPDATE_VERSION_URL = exports.SELF_UPDATE_VERSION_URL = 'https://yarnpkg.com/latest-version'; // cache version, bump whenever we make backwards incompatible changes\n\n  const CACHE_VERSION = exports.CACHE_VERSION = 2; // lockfile version, bump whenever we make backwards incompatible changes\n\n  const LOCKFILE_VERSION = exports.LOCKFILE_VERSION = 1; // max amount of network requests to perform concurrently\n\n  const NETWORK_CONCURRENCY = exports.NETWORK_CONCURRENCY = 8; // HTTP timeout used when downloading packages\n\n  const NETWORK_TIMEOUT = exports.NETWORK_TIMEOUT = 30 * 1000; // in milliseconds\n  // max amount of child processes to execute concurrently\n\n  const CHILD_CONCURRENCY = exports.CHILD_CONCURRENCY = 5;\n  const REQUIRED_PACKAGE_KEYS = exports.REQUIRED_PACKAGE_KEYS = ['name', 'version', '_uid'];\n\n  function getPreferredCacheDirectories() {\n    const preferredCacheDirectories = [getCacheDir()];\n\n    if (process.getuid) {\n      // $FlowFixMe: process.getuid exists, dammit\n      preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache-${process.getuid()}`));\n    }\n\n    preferredCacheDirectories.push(path.join(os.tmpdir(), `.yarn-cache`));\n    return preferredCacheDirectories;\n  }\n\n  const PREFERRED_MODULE_CACHE_DIRECTORIES = exports.PREFERRED_MODULE_CACHE_DIRECTORIES = getPreferredCacheDirectories();\n  const CONFIG_DIRECTORY = exports.CONFIG_DIRECTORY = getConfigDir();\n  const DATA_DIRECTORY = exports.DATA_DIRECTORY = getDataDir();\n  const LINK_REGISTRY_DIRECTORY = exports.LINK_REGISTRY_DIRECTORY = path.join(DATA_DIRECTORY, 'link');\n  const GLOBAL_MODULE_DIRECTORY = exports.GLOBAL_MODULE_DIRECTORY = path.join(DATA_DIRECTORY, 'global');\n  const NODE_BIN_PATH = exports.NODE_BIN_PATH = process.execPath;\n  const YARN_BIN_PATH = exports.YARN_BIN_PATH = getYarnBinPath(); // Webpack needs to be configured with node.__dirname/__filename = false\n\n  function getYarnBinPath() {\n    if (isWebpackBundle) {\n      return __filename;\n    } else {\n      return path.join(__dirname, '..', 'bin', 'yarn.js');\n    }\n  }\n\n  const NODE_MODULES_FOLDER = exports.NODE_MODULES_FOLDER = 'node_modules';\n  const NODE_PACKAGE_JSON = exports.NODE_PACKAGE_JSON = 'package.json';\n  const POSIX_GLOBAL_PREFIX = exports.POSIX_GLOBAL_PREFIX = `${process.env.DESTDIR || ''}/usr/local`;\n  const FALLBACK_GLOBAL_PREFIX = exports.FALLBACK_GLOBAL_PREFIX = path.join(userHome, '.yarn');\n  const META_FOLDER = exports.META_FOLDER = '.yarn-meta';\n  const INTEGRITY_FILENAME = exports.INTEGRITY_FILENAME = '.yarn-integrity';\n  const LOCKFILE_FILENAME = exports.LOCKFILE_FILENAME = 'yarn.lock';\n  const METADATA_FILENAME = exports.METADATA_FILENAME = '.yarn-metadata.json';\n  const TARBALL_FILENAME = exports.TARBALL_FILENAME = '.yarn-tarball.tgz';\n  const CLEAN_FILENAME = exports.CLEAN_FILENAME = '.yarnclean';\n  const NPM_LOCK_FILENAME = exports.NPM_LOCK_FILENAME = 'package-lock.json';\n  const NPM_SHRINKWRAP_FILENAME = exports.NPM_SHRINKWRAP_FILENAME = 'npm-shrinkwrap.json';\n  const DEFAULT_INDENT = exports.DEFAULT_INDENT = '  ';\n  const SINGLE_INSTANCE_PORT = exports.SINGLE_INSTANCE_PORT = 31997;\n  const SINGLE_INSTANCE_FILENAME = exports.SINGLE_INSTANCE_FILENAME = '.yarn-single-instance';\n  const ENV_PATH_KEY = exports.ENV_PATH_KEY = getPathKey(process.platform, process.env);\n\n  function getPathKey(platform, env) {\n    let pathKey = 'PATH'; // windows calls its path \"Path\" usually, but this is not guaranteed.\n\n    if (platform === 'win32') {\n      pathKey = 'Path';\n\n      for (const key in env) {\n        if (key.toLowerCase() === 'path') {\n          pathKey = key;\n        }\n      }\n    }\n\n    return pathKey;\n  }\n\n  const VERSION_COLOR_SCHEME = exports.VERSION_COLOR_SCHEME = {\n    major: 'red',\n    premajor: 'red',\n    minor: 'yellow',\n    preminor: 'yellow',\n    patch: 'green',\n    prepatch: 'green',\n    prerelease: 'red',\n    unchanged: 'white',\n    unknown: 'red'\n  };\n  /***/\n},\n/* 7 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n  /**\n   * Copyright (c) 2013-present, Facebook, Inc.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   */\n\n  /**\n   * Use invariant() to assert state which your program assumes to be true.\n   *\n   * Provide sprintf-style format (only %s is supported) and arguments\n   * to provide information about what broke and what you were\n   * expecting.\n   *\n   * The invariant message will be stripped in production, but the invariant\n   * will remain to ensure logic does not differ in production.\n   */\n\n  var NODE_ENV = process.env.NODE_ENV;\n\n  var invariant = function (condition, format, a, b, c, d, e, f) {\n    if (NODE_ENV !== 'production') {\n      if (format === undefined) {\n        throw new Error('invariant requires an error message argument');\n      }\n    }\n\n    if (!condition) {\n      var error;\n\n      if (format === undefined) {\n        error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');\n      } else {\n        var args = [a, b, c, d, e, f];\n        var argIndex = 0;\n        error = new Error(format.replace(/%s/g, function () {\n          return args[argIndex++];\n        }));\n        error.name = 'Invariant Violation';\n      }\n\n      error.framesToPop = 1; // we don't care about invariant's own frame\n\n      throw error;\n    }\n  };\n\n  module.exports = invariant;\n  /***/\n},,\n/* 9 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"crypto\");\n  /***/\n},,\n/* 11 */\n\n/***/\nfunction (module, exports) {\n  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func\n  : Function('return this')();\n  if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n  /***/\n},\n/* 12 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.sortAlpha = sortAlpha;\n  exports.entries = entries;\n  exports.removePrefix = removePrefix;\n  exports.removeSuffix = removeSuffix;\n  exports.addSuffix = addSuffix;\n  exports.hyphenate = hyphenate;\n  exports.camelCase = camelCase;\n  exports.compareSortedArrays = compareSortedArrays;\n  exports.sleep = sleep;\n\n  const _camelCase = __webpack_require__(176);\n\n  function sortAlpha(a, b) {\n    // sort alphabetically in a deterministic way\n    const shortLen = Math.min(a.length, b.length);\n\n    for (let i = 0; i < shortLen; i++) {\n      const aChar = a.charCodeAt(i);\n      const bChar = b.charCodeAt(i);\n\n      if (aChar !== bChar) {\n        return aChar - bChar;\n      }\n    }\n\n    return a.length - b.length;\n  }\n\n  function entries(obj) {\n    const entries = [];\n\n    if (obj) {\n      for (const key in obj) {\n        entries.push([key, obj[key]]);\n      }\n    }\n\n    return entries;\n  }\n\n  function removePrefix(pattern, prefix) {\n    if (pattern.startsWith(prefix)) {\n      pattern = pattern.slice(prefix.length);\n    }\n\n    return pattern;\n  }\n\n  function removeSuffix(pattern, suffix) {\n    if (pattern.endsWith(suffix)) {\n      return pattern.slice(0, -suffix.length);\n    }\n\n    return pattern;\n  }\n\n  function addSuffix(pattern, suffix) {\n    if (!pattern.endsWith(suffix)) {\n      return pattern + suffix;\n    }\n\n    return pattern;\n  }\n\n  function hyphenate(str) {\n    return str.replace(/[A-Z]/g, match => {\n      return '-' + match.charAt(0).toLowerCase();\n    });\n  }\n\n  function camelCase(str) {\n    if (/[A-Z]/.test(str)) {\n      return null;\n    } else {\n      return _camelCase(str);\n    }\n  }\n\n  function compareSortedArrays(array1, array2) {\n    if (array1.length !== array2.length) {\n      return false;\n    }\n\n    for (let i = 0, len = array1.length; i < len; i++) {\n      if (array1[i] !== array2[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function sleep(ms) {\n    return new Promise(resolve => {\n      setTimeout(resolve, ms);\n    });\n  }\n  /***/\n\n},\n/* 13 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var store = __webpack_require__(107)('wks');\n\n  var uid = __webpack_require__(111);\n\n  var Symbol = __webpack_require__(11).Symbol;\n\n  var USE_SYMBOL = typeof Symbol == 'function';\n\n  var $exports = module.exports = function (name) {\n    return store[name] || (store[name] = USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n  };\n\n  $exports.store = store;\n  /***/\n},\n/* 14 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.stringify = exports.parse = undefined;\n\n  var _asyncToGenerator2;\n\n  function _load_asyncToGenerator() {\n    return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n  }\n\n  var _parse;\n\n  function _load_parse() {\n    return _parse = __webpack_require__(81);\n  }\n\n  Object.defineProperty(exports, 'parse', {\n    enumerable: true,\n    get: function get() {\n      return _interopRequireDefault(_parse || _load_parse()).default;\n    }\n  });\n\n  var _stringify;\n\n  function _load_stringify() {\n    return _stringify = __webpack_require__(150);\n  }\n\n  Object.defineProperty(exports, 'stringify', {\n    enumerable: true,\n    get: function get() {\n      return _interopRequireDefault(_stringify || _load_stringify()).default;\n    }\n  });\n  exports.implodeEntry = implodeEntry;\n  exports.explodeEntry = explodeEntry;\n\n  var _misc;\n\n  function _load_misc() {\n    return _misc = __webpack_require__(12);\n  }\n\n  var _normalizePattern;\n\n  function _load_normalizePattern() {\n    return _normalizePattern = __webpack_require__(29);\n  }\n\n  var _parse2;\n\n  function _load_parse2() {\n    return _parse2 = _interopRequireDefault(__webpack_require__(81));\n  }\n\n  var _constants;\n\n  function _load_constants() {\n    return _constants = __webpack_require__(6);\n  }\n\n  var _fs;\n\n  function _load_fs() {\n    return _fs = _interopRequireWildcard(__webpack_require__(5));\n  }\n\n  function _interopRequireWildcard(obj) {\n    if (obj && obj.__esModule) {\n      return obj;\n    } else {\n      var newObj = {};\n\n      if (obj != null) {\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n        }\n      }\n\n      newObj.default = obj;\n      return newObj;\n    }\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const invariant = __webpack_require__(7);\n\n  const path = __webpack_require__(0);\n\n  const ssri = __webpack_require__(55);\n\n  function getName(pattern) {\n    return (0, (_normalizePattern || _load_normalizePattern()).normalizePattern)(pattern).name;\n  }\n\n  function blankObjectUndefined(obj) {\n    return obj && Object.keys(obj).length ? obj : undefined;\n  }\n\n  function keyForRemote(remote) {\n    return remote.resolved || (remote.reference && remote.hash ? `${remote.reference}#${remote.hash}` : null);\n  }\n\n  function serializeIntegrity(integrity) {\n    // We need this because `Integrity.toString()` does not use sorting to ensure a stable string output\n    // See https://git.io/vx2Hy\n    return integrity.toString().split(' ').sort().join(' ');\n  }\n\n  function implodeEntry(pattern, obj) {\n    const inferredName = getName(pattern);\n    const integrity = obj.integrity ? serializeIntegrity(obj.integrity) : '';\n    const imploded = {\n      name: inferredName === obj.name ? undefined : obj.name,\n      version: obj.version,\n      uid: obj.uid === obj.version ? undefined : obj.uid,\n      resolved: obj.resolved,\n      registry: obj.registry === 'npm' ? undefined : obj.registry,\n      dependencies: blankObjectUndefined(obj.dependencies),\n      optionalDependencies: blankObjectUndefined(obj.optionalDependencies),\n      permissions: blankObjectUndefined(obj.permissions),\n      prebuiltVariants: blankObjectUndefined(obj.prebuiltVariants)\n    };\n\n    if (integrity) {\n      imploded.integrity = integrity;\n    }\n\n    return imploded;\n  }\n\n  function explodeEntry(pattern, obj) {\n    obj.optionalDependencies = obj.optionalDependencies || {};\n    obj.dependencies = obj.dependencies || {};\n    obj.uid = obj.uid || obj.version;\n    obj.permissions = obj.permissions || {};\n    obj.registry = obj.registry || 'npm';\n    obj.name = obj.name || getName(pattern);\n    const integrity = obj.integrity;\n\n    if (integrity && integrity.isIntegrity) {\n      obj.integrity = ssri.parse(integrity);\n    }\n\n    return obj;\n  }\n\n  class Lockfile {\n    constructor({\n      cache,\n      source,\n      parseResultType\n    } = {}) {\n      this.source = source || '';\n      this.cache = cache;\n      this.parseResultType = parseResultType;\n    } // source string if the `cache` was parsed\n    // if true, we're parsing an old yarn file and need to update integrity fields\n\n\n    hasEntriesExistWithoutIntegrity() {\n      if (!this.cache) {\n        return false;\n      }\n\n      for (const key in this.cache) {\n        // $FlowFixMe - `this.cache` is clearly defined at this point\n        if (!/^.*@(file:|http)/.test(key) && this.cache[key] && !this.cache[key].integrity) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    static fromDirectory(dir, reporter) {\n      return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {\n        // read the manifest in this directory\n        const lockfileLoc = path.join(dir, (_constants || _load_constants()).LOCKFILE_FILENAME);\n        let lockfile;\n        let rawLockfile = '';\n        let parseResult;\n\n        if (yield (_fs || _load_fs()).exists(lockfileLoc)) {\n          rawLockfile = yield (_fs || _load_fs()).readFile(lockfileLoc);\n          parseResult = (0, (_parse2 || _load_parse2()).default)(rawLockfile, lockfileLoc);\n\n          if (reporter) {\n            if (parseResult.type === 'merge') {\n              reporter.info(reporter.lang('lockfileMerged'));\n            } else if (parseResult.type === 'conflict') {\n              reporter.warn(reporter.lang('lockfileConflict'));\n            }\n          }\n\n          lockfile = parseResult.object;\n        } else if (reporter) {\n          reporter.info(reporter.lang('noLockfileFound'));\n        }\n\n        return new Lockfile({\n          cache: lockfile,\n          source: rawLockfile,\n          parseResultType: parseResult && parseResult.type\n        });\n      })();\n    }\n\n    getLocked(pattern) {\n      const cache = this.cache;\n\n      if (!cache) {\n        return undefined;\n      }\n\n      const shrunk = pattern in cache && cache[pattern];\n\n      if (typeof shrunk === 'string') {\n        return this.getLocked(shrunk);\n      } else if (shrunk) {\n        explodeEntry(pattern, shrunk);\n        return shrunk;\n      }\n\n      return undefined;\n    }\n\n    removePattern(pattern) {\n      const cache = this.cache;\n\n      if (!cache) {\n        return;\n      }\n\n      delete cache[pattern];\n    }\n\n    getLockfile(patterns) {\n      const lockfile = {};\n      const seen = new Map(); // order by name so that lockfile manifest is assigned to the first dependency with this manifest\n      // the others that have the same remoteKey will just refer to the first\n      // ordering allows for consistency in lockfile when it is serialized\n\n      const sortedPatternsKeys = Object.keys(patterns).sort((_misc || _load_misc()).sortAlpha);\n\n      for (var _iterator = sortedPatternsKeys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        const pattern = _ref;\n        const pkg = patterns[pattern];\n        const remote = pkg._remote,\n              ref = pkg._reference;\n        invariant(ref, 'Package is missing a reference');\n        invariant(remote, 'Package is missing a remote');\n        const remoteKey = keyForRemote(remote);\n        const seenPattern = remoteKey && seen.get(remoteKey);\n\n        if (seenPattern) {\n          // no point in duplicating it\n          lockfile[pattern] = seenPattern; // if we're relying on our name being inferred and two of the patterns have\n          // different inferred names then we need to set it\n\n          if (!seenPattern.name && getName(pattern) !== pkg.name) {\n            seenPattern.name = pkg.name;\n          }\n\n          continue;\n        }\n\n        const obj = implodeEntry(pattern, {\n          name: pkg.name,\n          version: pkg.version,\n          uid: pkg._uid,\n          resolved: remote.resolved,\n          integrity: remote.integrity,\n          registry: remote.registry,\n          dependencies: pkg.dependencies,\n          peerDependencies: pkg.peerDependencies,\n          optionalDependencies: pkg.optionalDependencies,\n          permissions: ref.permissions,\n          prebuiltVariants: pkg.prebuiltVariants\n        });\n        lockfile[pattern] = obj;\n\n        if (remoteKey) {\n          seen.set(remoteKey, obj);\n        }\n      }\n\n      return lockfile;\n    }\n\n  }\n\n  exports.default = Lockfile;\n  /***/\n},,,\n/* 17 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"stream\");\n  /***/\n},,,\n/* 20 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = nullify;\n\n  function nullify(obj = {}) {\n    if (Array.isArray(obj)) {\n      for (var _iterator = obj, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        const item = _ref;\n        nullify(item);\n      }\n    } else if (obj !== null && typeof obj === 'object' || typeof obj === 'function') {\n      Object.setPrototypeOf(obj, null); // for..in can only be applied to 'object', not 'function'\n\n      if (typeof obj === 'object') {\n        for (const key in obj) {\n          nullify(obj[key]);\n        }\n      }\n    }\n\n    return obj;\n  }\n  /***/\n\n},,\n/* 22 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"assert\");\n  /***/\n},\n/* 23 */\n\n/***/\nfunction (module, exports) {\n  var core = module.exports = {\n    version: '2.5.7'\n  };\n  if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n  /***/\n},,,,\n/* 27 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var isObject = __webpack_require__(34);\n\n  module.exports = function (it) {\n    if (!isObject(it)) throw TypeError(it + ' is not an object!');\n    return it;\n  };\n  /***/\n\n},,\n/* 29 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.normalizePattern = normalizePattern;\n  /**\n   * Explode and normalize a pattern into its name and range.\n   */\n\n  function normalizePattern(pattern) {\n    let hasVersion = false;\n    let range = 'latest';\n    let name = pattern; // if we're a scope then remove the @ and add it back later\n\n    let isScoped = false;\n\n    if (name[0] === '@') {\n      isScoped = true;\n      name = name.slice(1);\n    } // take first part as the name\n\n\n    const parts = name.split('@');\n\n    if (parts.length > 1) {\n      name = parts.shift();\n      range = parts.join('@');\n\n      if (range) {\n        hasVersion = true;\n      } else {\n        range = '*';\n      }\n    } // add back @ scope suffix\n\n\n    if (isScoped) {\n      name = `@${name}`;\n    }\n\n    return {\n      name,\n      range,\n      hasVersion\n    };\n  }\n  /***/\n\n},,\n/* 31 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var dP = __webpack_require__(50);\n\n  var createDesc = __webpack_require__(106);\n\n  module.exports = __webpack_require__(33) ? function (object, key, value) {\n    return dP.f(object, key, createDesc(1, value));\n  } : function (object, key, value) {\n    object[key] = value;\n    return object;\n  };\n  /***/\n},\n/* 32 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /* eslint-disable node/no-deprecated-api */\n  var buffer = __webpack_require__(63);\n\n  var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n  function copyProps(src, dst) {\n    for (var key in src) {\n      dst[key] = src[key];\n    }\n  }\n\n  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n    module.exports = buffer;\n  } else {\n    // Copy properties from require('buffer')\n    copyProps(buffer, exports);\n    exports.Buffer = SafeBuffer;\n  }\n\n  function SafeBuffer(arg, encodingOrOffset, length) {\n    return Buffer(arg, encodingOrOffset, length);\n  } // Copy static methods from Buffer\n\n\n  copyProps(Buffer, SafeBuffer);\n\n  SafeBuffer.from = function (arg, encodingOrOffset, length) {\n    if (typeof arg === 'number') {\n      throw new TypeError('Argument must not be a number');\n    }\n\n    return Buffer(arg, encodingOrOffset, length);\n  };\n\n  SafeBuffer.alloc = function (size, fill, encoding) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    var buf = Buffer(size);\n\n    if (fill !== undefined) {\n      if (typeof encoding === 'string') {\n        buf.fill(fill, encoding);\n      } else {\n        buf.fill(fill);\n      }\n    } else {\n      buf.fill(0);\n    }\n\n    return buf;\n  };\n\n  SafeBuffer.allocUnsafe = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return Buffer(size);\n  };\n\n  SafeBuffer.allocUnsafeSlow = function (size) {\n    if (typeof size !== 'number') {\n      throw new TypeError('Argument must be a number');\n    }\n\n    return buffer.SlowBuffer(size);\n  };\n  /***/\n\n},\n/* 33 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // Thank's IE8 for his funny defineProperty\n  module.exports = !__webpack_require__(85)(function () {\n    return Object.defineProperty({}, 'a', {\n      get: function () {\n        return 7;\n      }\n    }).a != 7;\n  });\n  /***/\n},\n/* 34 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (it) {\n    return typeof it === 'object' ? it !== null : typeof it === 'function';\n  };\n  /***/\n\n},\n/* 35 */\n\n/***/\nfunction (module, exports) {\n  module.exports = {};\n  /***/\n},\n/* 36 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"os\");\n  /***/\n},,,,\n/* 40 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.wait = wait;\n  exports.promisify = promisify;\n  exports.queue = queue;\n\n  function wait(delay) {\n    return new Promise(resolve => {\n      setTimeout(resolve, delay);\n    });\n  }\n\n  function promisify(fn, firstData) {\n    return function (...args) {\n      return new Promise(function (resolve, reject) {\n        args.push(function (err, ...result) {\n          let res = result;\n\n          if (result.length <= 1) {\n            res = result[0];\n          }\n\n          if (firstData) {\n            res = err;\n            err = null;\n          }\n\n          if (err) {\n            reject(err);\n          } else {\n            resolve(res);\n          }\n        });\n        fn.apply(null, args);\n      });\n    };\n  }\n\n  function queue(arr, promiseProducer, concurrency = Infinity) {\n    concurrency = Math.min(concurrency, arr.length); // clone\n\n    arr = arr.slice();\n    const results = [];\n    let total = arr.length;\n\n    if (!total) {\n      return Promise.resolve(results);\n    }\n\n    return new Promise((resolve, reject) => {\n      for (let i = 0; i < concurrency; i++) {\n        next();\n      }\n\n      function next() {\n        const item = arr.shift();\n        const promise = promiseProducer(item);\n        promise.then(function (result) {\n          results.push(result);\n          total--;\n\n          if (total === 0) {\n            resolve(results);\n          } else {\n            if (arr.length) {\n              next();\n            }\n          }\n        }, reject);\n      }\n    });\n  }\n  /***/\n\n},\n/* 41 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var global = __webpack_require__(11);\n\n  var core = __webpack_require__(23);\n\n  var ctx = __webpack_require__(48);\n\n  var hide = __webpack_require__(31);\n\n  var has = __webpack_require__(49);\n\n  var PROTOTYPE = 'prototype';\n\n  var $export = function (type, name, source) {\n    var IS_FORCED = type & $export.F;\n    var IS_GLOBAL = type & $export.G;\n    var IS_STATIC = type & $export.S;\n    var IS_PROTO = type & $export.P;\n    var IS_BIND = type & $export.B;\n    var IS_WRAP = type & $export.W;\n    var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n    var expProto = exports[PROTOTYPE];\n    var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n    var key, own, out;\n    if (IS_GLOBAL) source = name;\n\n    for (key in source) {\n      // contains in native\n      own = !IS_FORCED && target && target[key] !== undefined;\n      if (own && has(exports, key)) continue; // export native or passed\n\n      out = own ? target[key] : source[key]; // prevent global pollution for namespaces\n\n      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context\n      : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library\n      : IS_WRAP && target[key] == out ? function (C) {\n        var F = function (a, b, c) {\n          if (this instanceof C) {\n            switch (arguments.length) {\n              case 0:\n                return new C();\n\n              case 1:\n                return new C(a);\n\n              case 2:\n                return new C(a, b);\n            }\n\n            return new C(a, b, c);\n          }\n\n          return C.apply(this, arguments);\n        };\n\n        F[PROTOTYPE] = C[PROTOTYPE];\n        return F; // make static versions for prototype methods\n      }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n\n      if (IS_PROTO) {\n        (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n\n        if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n      }\n    }\n  }; // type bitmap\n\n\n  $export.F = 1; // forced\n\n  $export.G = 2; // global\n\n  $export.S = 4; // static\n\n  $export.P = 8; // proto\n\n  $export.B = 16; // bind\n\n  $export.W = 32; // wrap\n\n  $export.U = 64; // safe\n\n  $export.R = 128; // real proto method for `library`\n\n  module.exports = $export;\n  /***/\n},\n/* 42 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  try {\n    var util = __webpack_require__(2);\n\n    if (typeof util.inherits !== 'function') throw '';\n    module.exports = util.inherits;\n  } catch (e) {\n    module.exports = __webpack_require__(224);\n  }\n  /***/\n\n},,,\n/* 45 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.home = undefined;\n\n  var _rootUser;\n\n  function _load_rootUser() {\n    return _rootUser = _interopRequireDefault(__webpack_require__(169));\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const path = __webpack_require__(0);\n\n  const home = exports.home = __webpack_require__(36).homedir();\n\n  const userHomeDir = (_rootUser || _load_rootUser()).default ? path.resolve('/usr/local/share') : home;\n  exports.default = userHomeDir;\n  /***/\n},\n/* 46 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (it) {\n    if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n    return it;\n  };\n  /***/\n\n},\n/* 47 */\n\n/***/\nfunction (module, exports) {\n  var toString = {}.toString;\n\n  module.exports = function (it) {\n    return toString.call(it).slice(8, -1);\n  };\n  /***/\n\n},\n/* 48 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // optional / simple context binding\n  var aFunction = __webpack_require__(46);\n\n  module.exports = function (fn, that, length) {\n    aFunction(fn);\n    if (that === undefined) return fn;\n\n    switch (length) {\n      case 1:\n        return function (a) {\n          return fn.call(that, a);\n        };\n\n      case 2:\n        return function (a, b) {\n          return fn.call(that, a, b);\n        };\n\n      case 3:\n        return function (a, b, c) {\n          return fn.call(that, a, b, c);\n        };\n    }\n\n    return function\n      /* ...args */\n    () {\n      return fn.apply(that, arguments);\n    };\n  };\n  /***/\n\n},\n/* 49 */\n\n/***/\nfunction (module, exports) {\n  var hasOwnProperty = {}.hasOwnProperty;\n\n  module.exports = function (it, key) {\n    return hasOwnProperty.call(it, key);\n  };\n  /***/\n\n},\n/* 50 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var anObject = __webpack_require__(27);\n\n  var IE8_DOM_DEFINE = __webpack_require__(184);\n\n  var toPrimitive = __webpack_require__(201);\n\n  var dP = Object.defineProperty;\n  exports.f = __webpack_require__(33) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n    anObject(O);\n    P = toPrimitive(P, true);\n    anObject(Attributes);\n    if (IE8_DOM_DEFINE) try {\n      return dP(O, P, Attributes);\n    } catch (e) {\n      /* empty */\n    }\n    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n    if ('value' in Attributes) O[P] = Attributes.value;\n    return O;\n  };\n  /***/\n},,,,\n/* 54 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"events\");\n  /***/\n},\n/* 55 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  const Buffer = __webpack_require__(32).Buffer;\n\n  const crypto = __webpack_require__(9);\n\n  const Transform = __webpack_require__(17).Transform;\n\n  const SPEC_ALGORITHMS = ['sha256', 'sha384', 'sha512'];\n  const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;\n  const SRI_REGEX = /^([^-]+)-([^?]+)([?\\S*]*)$/;\n  const STRICT_SRI_REGEX = /^([^-]+)-([A-Za-z0-9+/=]{44,88})(\\?[\\x21-\\x7E]*)*$/;\n  const VCHAR_REGEX = /^[\\x21-\\x7E]+$/;\n\n  class Hash {\n    get isHash() {\n      return true;\n    }\n\n    constructor(hash, opts) {\n      const strict = !!(opts && opts.strict);\n      this.source = hash.trim(); // 3.1. Integrity metadata (called \"Hash\" by ssri)\n      // https://w3c.github.io/webappsec-subresource-integrity/#integrity-metadata-description\n\n      const match = this.source.match(strict ? STRICT_SRI_REGEX : SRI_REGEX);\n\n      if (!match) {\n        return;\n      }\n\n      if (strict && !SPEC_ALGORITHMS.some(a => a === match[1])) {\n        return;\n      }\n\n      this.algorithm = match[1];\n      this.digest = match[2];\n      const rawOpts = match[3];\n      this.options = rawOpts ? rawOpts.slice(1).split('?') : [];\n    }\n\n    hexDigest() {\n      return this.digest && Buffer.from(this.digest, 'base64').toString('hex');\n    }\n\n    toJSON() {\n      return this.toString();\n    }\n\n    toString(opts) {\n      if (opts && opts.strict) {\n        // Strict mode enforces the standard as close to the foot of the\n        // letter as it can.\n        if (!( // The spec has very restricted productions for algorithms.\n        // https://www.w3.org/TR/CSP2/#source-list-syntax\n        SPEC_ALGORITHMS.some(x => x === this.algorithm) && // Usually, if someone insists on using a \"different\" base64, we\n        // leave it as-is, since there's multiple standards, and the\n        // specified is not a URL-safe variant.\n        // https://www.w3.org/TR/CSP2/#base64_value\n        this.digest.match(BASE64_REGEX) && // Option syntax is strictly visual chars.\n        // https://w3c.github.io/webappsec-subresource-integrity/#grammardef-option-expression\n        // https://tools.ietf.org/html/rfc5234#appendix-B.1\n        (this.options || []).every(opt => opt.match(VCHAR_REGEX)))) {\n          return '';\n        }\n      }\n\n      const options = this.options && this.options.length ? `?${this.options.join('?')}` : '';\n      return `${this.algorithm}-${this.digest}${options}`;\n    }\n\n  }\n\n  class Integrity {\n    get isIntegrity() {\n      return true;\n    }\n\n    toJSON() {\n      return this.toString();\n    }\n\n    toString(opts) {\n      opts = opts || {};\n      let sep = opts.sep || ' ';\n\n      if (opts.strict) {\n        // Entries must be separated by whitespace, according to spec.\n        sep = sep.replace(/\\S+/g, ' ');\n      }\n\n      return Object.keys(this).map(k => {\n        return this[k].map(hash => {\n          return Hash.prototype.toString.call(hash, opts);\n        }).filter(x => x.length).join(sep);\n      }).filter(x => x.length).join(sep);\n    }\n\n    concat(integrity, opts) {\n      const other = typeof integrity === 'string' ? integrity : stringify(integrity, opts);\n      return parse(`${this.toString(opts)} ${other}`, opts);\n    }\n\n    hexDigest() {\n      return parse(this, {\n        single: true\n      }).hexDigest();\n    }\n\n    match(integrity, opts) {\n      const other = parse(integrity, opts);\n      const algo = other.pickAlgorithm(opts);\n      return this[algo] && other[algo] && this[algo].find(hash => other[algo].find(otherhash => hash.digest === otherhash.digest)) || false;\n    }\n\n    pickAlgorithm(opts) {\n      const pickAlgorithm = opts && opts.pickAlgorithm || getPrioritizedHash;\n      const keys = Object.keys(this);\n\n      if (!keys.length) {\n        throw new Error(`No algorithms available for ${JSON.stringify(this.toString())}`);\n      }\n\n      return keys.reduce((acc, algo) => {\n        return pickAlgorithm(acc, algo) || acc;\n      });\n    }\n\n  }\n\n  module.exports.parse = parse;\n\n  function parse(sri, opts) {\n    opts = opts || {};\n\n    if (typeof sri === 'string') {\n      return _parse(sri, opts);\n    } else if (sri.algorithm && sri.digest) {\n      const fullSri = new Integrity();\n      fullSri[sri.algorithm] = [sri];\n      return _parse(stringify(fullSri, opts), opts);\n    } else {\n      return _parse(stringify(sri, opts), opts);\n    }\n  }\n\n  function _parse(integrity, opts) {\n    // 3.4.3. Parse metadata\n    // https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n    if (opts.single) {\n      return new Hash(integrity, opts);\n    }\n\n    return integrity.trim().split(/\\s+/).reduce((acc, string) => {\n      const hash = new Hash(string, opts);\n\n      if (hash.algorithm && hash.digest) {\n        const algo = hash.algorithm;\n\n        if (!acc[algo]) {\n          acc[algo] = [];\n        }\n\n        acc[algo].push(hash);\n      }\n\n      return acc;\n    }, new Integrity());\n  }\n\n  module.exports.stringify = stringify;\n\n  function stringify(obj, opts) {\n    if (obj.algorithm && obj.digest) {\n      return Hash.prototype.toString.call(obj, opts);\n    } else if (typeof obj === 'string') {\n      return stringify(parse(obj, opts), opts);\n    } else {\n      return Integrity.prototype.toString.call(obj, opts);\n    }\n  }\n\n  module.exports.fromHex = fromHex;\n\n  function fromHex(hexDigest, algorithm, opts) {\n    const optString = opts && opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    return parse(`${algorithm}-${Buffer.from(hexDigest, 'hex').toString('base64')}${optString}`, opts);\n  }\n\n  module.exports.fromData = fromData;\n\n  function fromData(data, opts) {\n    opts = opts || {};\n    const algorithms = opts.algorithms || ['sha512'];\n    const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    return algorithms.reduce((acc, algo) => {\n      const digest = crypto.createHash(algo).update(data).digest('base64');\n      const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n      if (hash.algorithm && hash.digest) {\n        const algo = hash.algorithm;\n\n        if (!acc[algo]) {\n          acc[algo] = [];\n        }\n\n        acc[algo].push(hash);\n      }\n\n      return acc;\n    }, new Integrity());\n  }\n\n  module.exports.fromStream = fromStream;\n\n  function fromStream(stream, opts) {\n    opts = opts || {};\n    const P = opts.Promise || Promise;\n    const istream = integrityStream(opts);\n    return new P((resolve, reject) => {\n      stream.pipe(istream);\n      stream.on('error', reject);\n      istream.on('error', reject);\n      let sri;\n      istream.on('integrity', s => {\n        sri = s;\n      });\n      istream.on('end', () => resolve(sri));\n      istream.on('data', () => {});\n    });\n  }\n\n  module.exports.checkData = checkData;\n\n  function checkData(data, sri, opts) {\n    opts = opts || {};\n    sri = parse(sri, opts);\n\n    if (!Object.keys(sri).length) {\n      if (opts.error) {\n        throw Object.assign(new Error('No valid integrity hashes to check against'), {\n          code: 'EINTEGRITY'\n        });\n      } else {\n        return false;\n      }\n    }\n\n    const algorithm = sri.pickAlgorithm(opts);\n    const digest = crypto.createHash(algorithm).update(data).digest('base64');\n    const newSri = parse({\n      algorithm,\n      digest\n    });\n    const match = newSri.match(sri, opts);\n\n    if (match || !opts.error) {\n      return match;\n    } else if (typeof opts.size === 'number' && data.length !== opts.size) {\n      const err = new Error(`data size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${data.length}`);\n      err.code = 'EBADSIZE';\n      err.found = data.length;\n      err.expected = opts.size;\n      err.sri = sri;\n      throw err;\n    } else {\n      const err = new Error(`Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`);\n      err.code = 'EINTEGRITY';\n      err.found = newSri;\n      err.expected = sri;\n      err.algorithm = algorithm;\n      err.sri = sri;\n      throw err;\n    }\n  }\n\n  module.exports.checkStream = checkStream;\n\n  function checkStream(stream, sri, opts) {\n    opts = opts || {};\n    const P = opts.Promise || Promise;\n    const checker = integrityStream(Object.assign({}, opts, {\n      integrity: sri\n    }));\n    return new P((resolve, reject) => {\n      stream.pipe(checker);\n      stream.on('error', reject);\n      checker.on('error', reject);\n      let sri;\n      checker.on('verified', s => {\n        sri = s;\n      });\n      checker.on('end', () => resolve(sri));\n      checker.on('data', () => {});\n    });\n  }\n\n  module.exports.integrityStream = integrityStream;\n\n  function integrityStream(opts) {\n    opts = opts || {}; // For verification\n\n    const sri = opts.integrity && parse(opts.integrity, opts);\n    const goodSri = sri && Object.keys(sri).length;\n    const algorithm = goodSri && sri.pickAlgorithm(opts);\n    const digests = goodSri && sri[algorithm]; // Calculating stream\n\n    const algorithms = Array.from(new Set((opts.algorithms || ['sha512']).concat(algorithm ? [algorithm] : [])));\n    const hashes = algorithms.map(crypto.createHash);\n    let streamSize = 0;\n    const stream = new Transform({\n      transform(chunk, enc, cb) {\n        streamSize += chunk.length;\n        hashes.forEach(h => h.update(chunk, enc));\n        cb(null, chunk, enc);\n      }\n\n    }).on('end', () => {\n      const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n      const newSri = parse(hashes.map((h, i) => {\n        return `${algorithms[i]}-${h.digest('base64')}${optString}`;\n      }).join(' '), opts); // Integrity verification mode\n\n      const match = goodSri && newSri.match(sri, opts);\n\n      if (typeof opts.size === 'number' && streamSize !== opts.size) {\n        const err = new Error(`stream size mismatch when checking ${sri}.\\n  Wanted: ${opts.size}\\n  Found: ${streamSize}`);\n        err.code = 'EBADSIZE';\n        err.found = streamSize;\n        err.expected = opts.size;\n        err.sri = sri;\n        stream.emit('error', err);\n      } else if (opts.integrity && !match) {\n        const err = new Error(`${sri} integrity checksum failed when using ${algorithm}: wanted ${digests} but got ${newSri}. (${streamSize} bytes)`);\n        err.code = 'EINTEGRITY';\n        err.found = newSri;\n        err.expected = digests;\n        err.algorithm = algorithm;\n        err.sri = sri;\n        stream.emit('error', err);\n      } else {\n        stream.emit('size', streamSize);\n        stream.emit('integrity', newSri);\n        match && stream.emit('verified', match);\n      }\n    });\n    return stream;\n  }\n\n  module.exports.create = createIntegrity;\n\n  function createIntegrity(opts) {\n    opts = opts || {};\n    const algorithms = opts.algorithms || ['sha512'];\n    const optString = opts.options && opts.options.length ? `?${opts.options.join('?')}` : '';\n    const hashes = algorithms.map(crypto.createHash);\n    return {\n      update: function (chunk, enc) {\n        hashes.forEach(h => h.update(chunk, enc));\n        return this;\n      },\n      digest: function (enc) {\n        const integrity = algorithms.reduce((acc, algo) => {\n          const digest = hashes.shift().digest('base64');\n          const hash = new Hash(`${algo}-${digest}${optString}`, opts);\n\n          if (hash.algorithm && hash.digest) {\n            const algo = hash.algorithm;\n\n            if (!acc[algo]) {\n              acc[algo] = [];\n            }\n\n            acc[algo].push(hash);\n          }\n\n          return acc;\n        }, new Integrity());\n        return integrity;\n      }\n    };\n  }\n\n  const NODE_HASHES = new Set(crypto.getHashes()); // This is a Best Effort™ at a reasonable priority for hash algos\n\n  const DEFAULT_PRIORITY = ['md5', 'whirlpool', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512', // TODO - it's unclear _which_ of these Node will actually use as its name\n  //        for the algorithm, so we guesswork it based on the OpenSSL names.\n  'sha3', 'sha3-256', 'sha3-384', 'sha3-512', 'sha3_256', 'sha3_384', 'sha3_512'].filter(algo => NODE_HASHES.has(algo));\n\n  function getPrioritizedHash(algo1, algo2) {\n    return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >= DEFAULT_PRIORITY.indexOf(algo2.toLowerCase()) ? algo1 : algo2;\n  }\n  /***/\n\n},,,,,\n/* 60 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = minimatch;\n  minimatch.Minimatch = Minimatch;\n  var path = {\n    sep: '/'\n  };\n\n  try {\n    path = __webpack_require__(0);\n  } catch (er) {}\n\n  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\n\n  var expand = __webpack_require__(175);\n\n  var plTypes = {\n    '!': {\n      open: '(?:(?!(?:',\n      close: '))[^/]*?)'\n    },\n    '?': {\n      open: '(?:',\n      close: ')?'\n    },\n    '+': {\n      open: '(?:',\n      close: ')+'\n    },\n    '*': {\n      open: '(?:',\n      close: ')*'\n    },\n    '@': {\n      open: '(?:',\n      close: ')'\n    }\n  }; // any single thing other than /\n  // don't need to escape / when using new RegExp()\n\n  var qmark = '[^/]'; // * => any number of characters\n\n  var star = qmark + '*?'; // ** when dots are allowed.  Anything goes, except .. and .\n  // not (^ or / followed by one or two dots followed by $ or /),\n  // followed by anything, any number of times.\n\n  var twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'; // not a ^ or / followed by a dot,\n  // followed by anything, any number of times.\n\n  var twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'; // characters that need to be escaped in RegExp.\n\n  var reSpecials = charSet('().*{}+?[]^$\\\\!'); // \"abc\" -> { a:true, b:true, c:true }\n\n  function charSet(s) {\n    return s.split('').reduce(function (set, c) {\n      set[c] = true;\n      return set;\n    }, {});\n  } // normalizes slashes.\n\n\n  var slashSplit = /\\/+/;\n  minimatch.filter = filter;\n\n  function filter(pattern, options) {\n    options = options || {};\n    return function (p, i, list) {\n      return minimatch(p, pattern, options);\n    };\n  }\n\n  function ext(a, b) {\n    a = a || {};\n    b = b || {};\n    var t = {};\n    Object.keys(b).forEach(function (k) {\n      t[k] = b[k];\n    });\n    Object.keys(a).forEach(function (k) {\n      t[k] = a[k];\n    });\n    return t;\n  }\n\n  minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return minimatch;\n    var orig = minimatch;\n\n    var m = function minimatch(p, pattern, options) {\n      return orig.minimatch(p, pattern, ext(def, options));\n    };\n\n    m.Minimatch = function Minimatch(pattern, options) {\n      return new orig.Minimatch(pattern, ext(def, options));\n    };\n\n    return m;\n  };\n\n  Minimatch.defaults = function (def) {\n    if (!def || !Object.keys(def).length) return Minimatch;\n    return minimatch.defaults(def).Minimatch;\n  };\n\n  function minimatch(p, pattern, options) {\n    if (typeof pattern !== 'string') {\n      throw new TypeError('glob pattern string required');\n    }\n\n    if (!options) options = {}; // shortcut: comments match nothing.\n\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      return false;\n    } // \"\" only matches \"\"\n\n\n    if (pattern.trim() === '') return p === '';\n    return new Minimatch(pattern, options).match(p);\n  }\n\n  function Minimatch(pattern, options) {\n    if (!(this instanceof Minimatch)) {\n      return new Minimatch(pattern, options);\n    }\n\n    if (typeof pattern !== 'string') {\n      throw new TypeError('glob pattern string required');\n    }\n\n    if (!options) options = {};\n    pattern = pattern.trim(); // windows support: need to use /, not \\\n\n    if (path.sep !== '/') {\n      pattern = pattern.split(path.sep).join('/');\n    }\n\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false; // make the set of regexps etc.\n\n    this.make();\n  }\n\n  Minimatch.prototype.debug = function () {};\n\n  Minimatch.prototype.make = make;\n\n  function make() {\n    // don't do it more than once.\n    if (this._made) return;\n    var pattern = this.pattern;\n    var options = this.options; // empty patterns and comments match nothing.\n\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n\n    if (!pattern) {\n      this.empty = true;\n      return;\n    } // step 1: figure out negation, etc.\n\n\n    this.parseNegate(); // step 2: expand braces\n\n    var set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = console.error;\n    this.debug(this.pattern, set); // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n\n    set = this.globParts = set.map(function (s) {\n      return s.split(slashSplit);\n    });\n    this.debug(this.pattern, set); // glob --> regexps\n\n    set = set.map(function (s, si, set) {\n      return s.map(this.parse, this);\n    }, this);\n    this.debug(this.pattern, set); // filter out everything that didn't compile properly.\n\n    set = set.filter(function (s) {\n      return s.indexOf(false) === -1;\n    });\n    this.debug(this.pattern, set);\n    this.set = set;\n  }\n\n  Minimatch.prototype.parseNegate = parseNegate;\n\n  function parseNegate() {\n    var pattern = this.pattern;\n    var negate = false;\n    var options = this.options;\n    var negateOffset = 0;\n    if (options.nonegate) return;\n\n    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n  } // Brace expansion:\n  // a{b,c}d -> abd acd\n  // a{b,}c -> abc ac\n  // a{0..3}d -> a0d a1d a2d a3d\n  // a{b,c{d,e}f}g -> abg acdfg acefg\n  // a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n  //\n  // Invalid sets are not expanded.\n  // a{2..}b -> a{2..}b\n  // a{b}c -> a{b}c\n\n\n  minimatch.braceExpand = function (pattern, options) {\n    return braceExpand(pattern, options);\n  };\n\n  Minimatch.prototype.braceExpand = braceExpand;\n\n  function braceExpand(pattern, options) {\n    if (!options) {\n      if (this instanceof Minimatch) {\n        options = this.options;\n      } else {\n        options = {};\n      }\n    }\n\n    pattern = typeof pattern === 'undefined' ? this.pattern : pattern;\n\n    if (typeof pattern === 'undefined') {\n      throw new TypeError('undefined pattern');\n    }\n\n    if (options.nobrace || !pattern.match(/\\{.*\\}/)) {\n      // shortcut. no need to expand.\n      return [pattern];\n    }\n\n    return expand(pattern);\n  } // parse a component of the expanded set.\n  // At this point, no pattern may contain \"/\" in it\n  // so we're going to return a 2d array, where each entry is the full\n  // pattern, split on '/', and then turned into a regular expression.\n  // A regexp is made at the end which joins each array with an\n  // escaped /, and another full one which joins each regexp with |.\n  //\n  // Following the lead of Bash 4.1, note that \"**\" only has special meaning\n  // when it is the *only* thing in a path portion.  Otherwise, any series\n  // of * is equivalent to a single *.  Globstar behavior is enabled by\n  // default, and can be disabled by setting options.noglobstar.\n\n\n  Minimatch.prototype.parse = parse;\n  var SUBPARSE = {};\n\n  function parse(pattern, isSub) {\n    if (pattern.length > 1024 * 64) {\n      throw new TypeError('pattern is too long');\n    }\n\n    var options = this.options; // shortcuts\n\n    if (!options.noglobstar && pattern === '**') return GLOBSTAR;\n    if (pattern === '') return '';\n    var re = '';\n    var hasMagic = !!options.nocase;\n    var escaping = false; // ? => one single character\n\n    var patternListStack = [];\n    var negativeLists = [];\n    var stateChar;\n    var inClass = false;\n    var reClassStart = -1;\n    var classStart = -1; // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n\n    var patternStart = pattern.charAt(0) === '.' ? '' // anything\n    // not (start or / followed by . or .. followed by / or end)\n    : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))' : '(?!\\\\.)';\n    var self = this;\n\n    function clearStateChar() {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star;\n            hasMagic = true;\n            break;\n\n          case '?':\n            re += qmark;\n            hasMagic = true;\n            break;\n\n          default:\n            re += '\\\\' + stateChar;\n            break;\n        }\n\n        self.debug('clearStateChar %j %j', stateChar, re);\n        stateChar = false;\n      }\n    }\n\n    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c); // skip over any that are escaped.\n\n      if (escaping && reSpecials[c]) {\n        re += '\\\\' + c;\n        escaping = false;\n        continue;\n      }\n\n      switch (c) {\n        case '/':\n          // completely not allowed, even escaped.\n          // Should already be path-split by now.\n          return false;\n\n        case '\\\\':\n          clearStateChar();\n          escaping = true;\n          continue;\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c); // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n\n          if (inClass) {\n            this.debug('  in class');\n            if (c === '!' && i === classStart + 1) c = '^';\n            re += c;\n            continue;\n          } // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n\n\n          self.debug('call clearStateChar %j', stateChar);\n          clearStateChar();\n          stateChar = c; // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n\n          if (options.noext) clearStateChar();\n          continue;\n\n        case '(':\n          if (inClass) {\n            re += '(';\n            continue;\n          }\n\n          if (!stateChar) {\n            re += '\\\\(';\n            continue;\n          }\n\n          patternListStack.push({\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close\n          }); // negation is (?:(?!js)[^/]*)\n\n          re += stateChar === '!' ? '(?:(?!(?:' : '(?:';\n          this.debug('plType %j %j', stateChar, re);\n          stateChar = false;\n          continue;\n\n        case ')':\n          if (inClass || !patternListStack.length) {\n            re += '\\\\)';\n            continue;\n          }\n\n          clearStateChar();\n          hasMagic = true;\n          var pl = patternListStack.pop(); // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n\n          re += pl.close;\n\n          if (pl.type === '!') {\n            negativeLists.push(pl);\n          }\n\n          pl.reEnd = re.length;\n          continue;\n\n        case '|':\n          if (inClass || !patternListStack.length || escaping) {\n            re += '\\\\|';\n            escaping = false;\n            continue;\n          }\n\n          clearStateChar();\n          re += '|';\n          continue;\n        // these are mostly the same in regexp and glob\n\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar();\n\n          if (inClass) {\n            re += '\\\\' + c;\n            continue;\n          }\n\n          inClass = true;\n          classStart = i;\n          reClassStart = re.length;\n          re += c;\n          continue;\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c;\n            escaping = false;\n            continue;\n          } // handle the case where we left a class open.\n          // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n\n\n          if (inClass) {\n            // split where the last [ was, make sure we don't have\n            // an invalid re. if so, re-walk the contents of the\n            // would-be class to re-translate any characters that\n            // were passed through as-is\n            // TODO: It would probably be faster to determine this\n            // without a try/catch and a new RegExp, but it's tricky\n            // to do safely.  For now, this is safe and works.\n            var cs = pattern.substring(classStart + 1, i);\n\n            try {\n              RegExp('[' + cs + ']');\n            } catch (er) {\n              // not a valid class!\n              var sp = this.parse(cs, SUBPARSE);\n              re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]';\n              hasMagic = hasMagic || sp[1];\n              inClass = false;\n              continue;\n            }\n          } // finish up the class.\n\n\n          hasMagic = true;\n          inClass = false;\n          re += c;\n          continue;\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar();\n\n          if (escaping) {\n            // no need\n            escaping = false;\n          } else if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\';\n          }\n\n          re += c;\n      } // switch\n\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n\n\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.substr(classStart + 1);\n      sp = this.parse(cs, SUBPARSE);\n      re = re.substr(0, reClassStart) + '\\\\[' + sp[0];\n      hasMagic = hasMagic || sp[1];\n    } // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n\n\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      var tail = re.slice(pl.reStart + pl.open.length);\n      this.debug('setting tail', re, pl); // maybe some even number of \\, then maybe 1 \\, followed by a |\n\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\';\n        } // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n\n\n        return $1 + $1 + $2 + '|';\n      });\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n      var t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n      hasMagic = true;\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n    } // handle trailing things that only matter at the very end.\n\n\n    clearStateChar();\n\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\';\n    } // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n\n\n    var addPatternStart = false;\n\n    switch (re.charAt(0)) {\n      case '.':\n      case '[':\n      case '(':\n        addPatternStart = true;\n    } // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n\n\n    for (var n = negativeLists.length - 1; n > -1; n--) {\n      var nl = negativeLists[n];\n      var nlBefore = re.slice(0, nl.reStart);\n      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n      var nlAfter = re.slice(nl.reEnd);\n      nlLast += nlAfter; // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n\n      var openParensBefore = nlBefore.split('(').length - 1;\n      var cleanAfter = nlAfter;\n\n      for (i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n      }\n\n      nlAfter = cleanAfter;\n      var dollar = '';\n\n      if (nlAfter === '' && isSub !== SUBPARSE) {\n        dollar = '$';\n      }\n\n      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n      re = newRe;\n    } // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n\n\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re;\n    }\n\n    if (addPatternStart) {\n      re = patternStart + re;\n    } // parsing just a piece of a larger pattern.\n\n\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic];\n    } // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n\n\n    if (!hasMagic) {\n      return globUnescape(pattern);\n    }\n\n    var flags = options.nocase ? 'i' : '';\n\n    try {\n      var regExp = new RegExp('^' + re + '$', flags);\n    } catch (er) {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.');\n    }\n\n    regExp._glob = pattern;\n    regExp._src = re;\n    return regExp;\n  }\n\n  minimatch.makeRe = function (pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe();\n  };\n\n  Minimatch.prototype.makeRe = makeRe;\n\n  function makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp; // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n\n    var set = this.set;\n\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n\n    var options = this.options;\n    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    var flags = options.nocase ? 'i' : '';\n    var re = set.map(function (pattern) {\n      return pattern.map(function (p) {\n        return p === GLOBSTAR ? twoStar : typeof p === 'string' ? regExpEscape(p) : p._src;\n      }).join('\\\\\\/');\n    }).join('|'); // must match entire pattern\n    // ending in a * or ** will make it less strict.\n\n    re = '^(?:' + re + ')$'; // can match anything, as long as it's not this.\n\n    if (this.negate) re = '^(?!' + re + ').*$';\n\n    try {\n      this.regexp = new RegExp(re, flags);\n    } catch (ex) {\n      this.regexp = false;\n    }\n\n    return this.regexp;\n  }\n\n  minimatch.match = function (list, pattern, options) {\n    options = options || {};\n    var mm = new Minimatch(pattern, options);\n    list = list.filter(function (f) {\n      return mm.match(f);\n    });\n\n    if (mm.options.nonull && !list.length) {\n      list.push(pattern);\n    }\n\n    return list;\n  };\n\n  Minimatch.prototype.match = match;\n\n  function match(f, partial) {\n    this.debug('match', f, this.pattern); // short-circuit in the case of busted things.\n    // comments, etc.\n\n    if (this.comment) return false;\n    if (this.empty) return f === '';\n    if (f === '/' && partial) return true;\n    var options = this.options; // windows: need to use /, not \\\n\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/');\n    } // treat the test path as a set of pathparts.\n\n\n    f = f.split(slashSplit);\n    this.debug(this.pattern, 'split', f); // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    var set = this.set;\n    this.debug(this.pattern, 'set', set); // Find the basename of the path by looking for the last non-empty segment\n\n    var filename;\n    var i;\n\n    for (i = f.length - 1; i >= 0; i--) {\n      filename = f[i];\n      if (filename) break;\n    }\n\n    for (i = 0; i < set.length; i++) {\n      var pattern = set[i];\n      var file = f;\n\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n\n      var hit = this.matchOne(file, pattern, partial);\n\n      if (hit) {\n        if (options.flipNegate) return true;\n        return !this.negate;\n      }\n    } // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n\n\n    if (options.flipNegate) return false;\n    return this.negate;\n  } // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n\n\n  Minimatch.prototype.matchOne = function (file, pattern, partial) {\n    var options = this.options;\n    this.debug('matchOne', {\n      'this': this,\n      file: file,\n      pattern: pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f); // should be impossible.\n      // some invalid regexp stuff in the set.\n\n      if (p === false) return false;\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]); // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n\n        var fr = fi;\n        var pr = pi + 1;\n\n        if (pr === pl) {\n          this.debug('** at the end'); // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n\n          return true;\n        } // ok, let's see if we can swallow whatever we can.\n\n\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee); // XXX remove this slice.  Just pass the start index.\n\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee); // found a match.\n\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            } // ** swallows a segment, and continue.\n\n\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        } // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n\n\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) return true;\n        }\n\n        return false;\n      } // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n\n\n      var hit;\n\n      if (typeof p === 'string') {\n        if (options.nocase) {\n          hit = f.toLowerCase() === p.toLowerCase();\n        } else {\n          hit = f === p;\n        }\n\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = f.match(p);\n        this.debug('pattern match', p, f, hit);\n      }\n\n      if (!hit) return false;\n    } // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n\n\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      var emptyFileEnd = fi === fl - 1 && file[fi] === '';\n      return emptyFileEnd;\n    } // should be unreachable.\n\n\n    throw new Error('wtf?');\n  }; // replace stuff like \\* with *\n\n\n  function globUnescape(s) {\n    return s.replace(/\\\\(.)/g, '$1');\n  }\n\n  function regExpEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n  }\n  /***/\n\n},\n/* 61 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var wrappy = __webpack_require__(123);\n\n  module.exports = wrappy(once);\n  module.exports.strict = wrappy(onceStrict);\n  once.proto = once(function () {\n    Object.defineProperty(Function.prototype, 'once', {\n      value: function () {\n        return once(this);\n      },\n      configurable: true\n    });\n    Object.defineProperty(Function.prototype, 'onceStrict', {\n      value: function () {\n        return onceStrict(this);\n      },\n      configurable: true\n    });\n  });\n\n  function once(fn) {\n    var f = function () {\n      if (f.called) return f.value;\n      f.called = true;\n      return f.value = fn.apply(this, arguments);\n    };\n\n    f.called = false;\n    return f;\n  }\n\n  function onceStrict(fn) {\n    var f = function () {\n      if (f.called) throw new Error(f.onceError);\n      f.called = true;\n      return f.value = fn.apply(this, arguments);\n    };\n\n    var name = fn.name || 'Function wrapped with `once`';\n    f.onceError = name + \" shouldn't be called more than once\";\n    f.called = false;\n    return f;\n  }\n  /***/\n\n},,\n/* 63 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"buffer\");\n  /***/\n},,,,\n/* 67 */\n\n/***/\nfunction (module, exports) {\n  // 7.2.1 RequireObjectCoercible(argument)\n  module.exports = function (it) {\n    if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n    return it;\n  };\n  /***/\n\n},\n/* 68 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var isObject = __webpack_require__(34);\n\n  var document = __webpack_require__(11).document; // typeof document.createElement is 'object' in old IE\n\n\n  var is = isObject(document) && isObject(document.createElement);\n\n  module.exports = function (it) {\n    return is ? document.createElement(it) : {};\n  };\n  /***/\n\n},\n/* 69 */\n\n/***/\nfunction (module, exports) {\n  module.exports = true;\n  /***/\n},\n/* 70 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // 25.4.1.5 NewPromiseCapability(C)\n\n  var aFunction = __webpack_require__(46);\n\n  function PromiseCapability(C) {\n    var resolve, reject;\n    this.promise = new C(function ($$resolve, $$reject) {\n      if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');\n      resolve = $$resolve;\n      reject = $$reject;\n    });\n    this.resolve = aFunction(resolve);\n    this.reject = aFunction(reject);\n  }\n\n  module.exports.f = function (C) {\n    return new PromiseCapability(C);\n  };\n  /***/\n\n},\n/* 71 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var def = __webpack_require__(50).f;\n\n  var has = __webpack_require__(49);\n\n  var TAG = __webpack_require__(13)('toStringTag');\n\n  module.exports = function (it, tag, stat) {\n    if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {\n      configurable: true,\n      value: tag\n    });\n  };\n  /***/\n\n},\n/* 72 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var shared = __webpack_require__(107)('keys');\n\n  var uid = __webpack_require__(111);\n\n  module.exports = function (key) {\n    return shared[key] || (shared[key] = uid(key));\n  };\n  /***/\n\n},\n/* 73 */\n\n/***/\nfunction (module, exports) {\n  // 7.1.4 ToInteger\n  var ceil = Math.ceil;\n  var floor = Math.floor;\n\n  module.exports = function (it) {\n    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n  };\n  /***/\n\n},\n/* 74 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // to indexed object, toObject with fallback for non-array-like ES3 strings\n  var IObject = __webpack_require__(131);\n\n  var defined = __webpack_require__(67);\n\n  module.exports = function (it) {\n    return IObject(defined(it));\n  };\n  /***/\n\n},\n/* 75 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // Approach:\n  //\n  // 1. Get the minimatch set\n  // 2. For each pattern in the set, PROCESS(pattern, false)\n  // 3. Store matches per-set, then uniq them\n  //\n  // PROCESS(pattern, inGlobStar)\n  // Get the first [n] items from pattern that are all strings\n  // Join these together.  This is PREFIX.\n  //   If there is no more remaining, then stat(PREFIX) and\n  //   add to matches if it succeeds.  END.\n  //\n  // If inGlobStar and PREFIX is symlink and points to dir\n  //   set ENTRIES = []\n  // else readdir(PREFIX) as ENTRIES\n  //   If fail, END\n  //\n  // with ENTRIES\n  //   If pattern[n] is GLOBSTAR\n  //     // handle the case where the globstar match is empty\n  //     // by pruning it out, and testing the resulting pattern\n  //     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)\n  //     // handle other cases.\n  //     for ENTRY in ENTRIES (not dotfiles)\n  //       // attach globstar + tail onto the entry\n  //       // Mark that this entry is a globstar match\n  //       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)\n  //\n  //   else // not globstar\n  //     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)\n  //       Test ENTRY against pattern[n]\n  //       If fails, continue\n  //       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])\n  //\n  // Caveat:\n  //   Cache all stats and readdirs results to minimize syscall.  Since all\n  //   we ever care about is existence and directory-ness, we can just keep\n  //   `true` for files, and [children,...] for directories, or `false` for\n  //   things that don't exist.\n  module.exports = glob;\n\n  var fs = __webpack_require__(3);\n\n  var rp = __webpack_require__(114);\n\n  var minimatch = __webpack_require__(60);\n\n  var Minimatch = minimatch.Minimatch;\n\n  var inherits = __webpack_require__(42);\n\n  var EE = __webpack_require__(54).EventEmitter;\n\n  var path = __webpack_require__(0);\n\n  var assert = __webpack_require__(22);\n\n  var isAbsolute = __webpack_require__(76);\n\n  var globSync = __webpack_require__(218);\n\n  var common = __webpack_require__(115);\n\n  var alphasort = common.alphasort;\n  var alphasorti = common.alphasorti;\n  var setopts = common.setopts;\n  var ownProp = common.ownProp;\n\n  var inflight = __webpack_require__(223);\n\n  var util = __webpack_require__(2);\n\n  var childrenIgnored = common.childrenIgnored;\n  var isIgnored = common.isIgnored;\n\n  var once = __webpack_require__(61);\n\n  function glob(pattern, options, cb) {\n    if (typeof options === 'function') cb = options, options = {};\n    if (!options) options = {};\n\n    if (options.sync) {\n      if (cb) throw new TypeError('callback provided to sync glob');\n      return globSync(pattern, options);\n    }\n\n    return new Glob(pattern, options, cb);\n  }\n\n  glob.sync = globSync;\n  var GlobSync = glob.GlobSync = globSync.GlobSync; // old api surface\n\n  glob.glob = glob;\n\n  function extend(origin, add) {\n    if (add === null || typeof add !== 'object') {\n      return origin;\n    }\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n\n    return origin;\n  }\n\n  glob.hasMagic = function (pattern, options_) {\n    var options = extend({}, options_);\n    options.noprocess = true;\n    var g = new Glob(pattern, options);\n    var set = g.minimatch.set;\n    if (!pattern) return false;\n    if (set.length > 1) return true;\n\n    for (var j = 0; j < set[0].length; j++) {\n      if (typeof set[0][j] !== 'string') return true;\n    }\n\n    return false;\n  };\n\n  glob.Glob = Glob;\n  inherits(Glob, EE);\n\n  function Glob(pattern, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    }\n\n    if (options && options.sync) {\n      if (cb) throw new TypeError('callback provided to sync glob');\n      return new GlobSync(pattern, options);\n    }\n\n    if (!(this instanceof Glob)) return new Glob(pattern, options, cb);\n    setopts(this, pattern, options);\n    this._didRealPath = false; // process each pattern in the minimatch set\n\n    var n = this.minimatch.set.length; // The matches are stored as {<filename>: true,...} so that\n    // duplicates are automagically pruned.\n    // Later, we do an Object.keys() on these.\n    // Keep them as a list so we can fill in when nonull is set.\n\n    this.matches = new Array(n);\n\n    if (typeof cb === 'function') {\n      cb = once(cb);\n      this.on('error', cb);\n      this.on('end', function (matches) {\n        cb(null, matches);\n      });\n    }\n\n    var self = this;\n    this._processing = 0;\n    this._emitQueue = [];\n    this._processQueue = [];\n    this.paused = false;\n    if (this.noprocess) return this;\n    if (n === 0) return done();\n    var sync = true;\n\n    for (var i = 0; i < n; i++) {\n      this._process(this.minimatch.set[i], i, false, done);\n    }\n\n    sync = false;\n\n    function done() {\n      --self._processing;\n\n      if (self._processing <= 0) {\n        if (sync) {\n          process.nextTick(function () {\n            self._finish();\n          });\n        } else {\n          self._finish();\n        }\n      }\n    }\n  }\n\n  Glob.prototype._finish = function () {\n    assert(this instanceof Glob);\n    if (this.aborted) return;\n    if (this.realpath && !this._didRealpath) return this._realpath();\n    common.finish(this);\n    this.emit('end', this.found);\n  };\n\n  Glob.prototype._realpath = function () {\n    if (this._didRealpath) return;\n    this._didRealpath = true;\n    var n = this.matches.length;\n    if (n === 0) return this._finish();\n    var self = this;\n\n    for (var i = 0; i < this.matches.length; i++) this._realpathSet(i, next);\n\n    function next() {\n      if (--n === 0) self._finish();\n    }\n  };\n\n  Glob.prototype._realpathSet = function (index, cb) {\n    var matchset = this.matches[index];\n    if (!matchset) return cb();\n    var found = Object.keys(matchset);\n    var self = this;\n    var n = found.length;\n    if (n === 0) return cb();\n    var set = this.matches[index] = Object.create(null);\n    found.forEach(function (p, i) {\n      // If there's a problem with the stat, then it means that\n      // one or more of the links in the realpath couldn't be\n      // resolved.  just return the abs value in that case.\n      p = self._makeAbs(p);\n      rp.realpath(p, self.realpathCache, function (er, real) {\n        if (!er) set[real] = true;else if (er.syscall === 'stat') set[p] = true;else self.emit('error', er); // srsly wtf right here\n\n        if (--n === 0) {\n          self.matches[index] = set;\n          cb();\n        }\n      });\n    });\n  };\n\n  Glob.prototype._mark = function (p) {\n    return common.mark(this, p);\n  };\n\n  Glob.prototype._makeAbs = function (f) {\n    return common.makeAbs(this, f);\n  };\n\n  Glob.prototype.abort = function () {\n    this.aborted = true;\n    this.emit('abort');\n  };\n\n  Glob.prototype.pause = function () {\n    if (!this.paused) {\n      this.paused = true;\n      this.emit('pause');\n    }\n  };\n\n  Glob.prototype.resume = function () {\n    if (this.paused) {\n      this.emit('resume');\n      this.paused = false;\n\n      if (this._emitQueue.length) {\n        var eq = this._emitQueue.slice(0);\n\n        this._emitQueue.length = 0;\n\n        for (var i = 0; i < eq.length; i++) {\n          var e = eq[i];\n\n          this._emitMatch(e[0], e[1]);\n        }\n      }\n\n      if (this._processQueue.length) {\n        var pq = this._processQueue.slice(0);\n\n        this._processQueue.length = 0;\n\n        for (var i = 0; i < pq.length; i++) {\n          var p = pq[i];\n          this._processing--;\n\n          this._process(p[0], p[1], p[2], p[3]);\n        }\n      }\n    }\n  };\n\n  Glob.prototype._process = function (pattern, index, inGlobStar, cb) {\n    assert(this instanceof Glob);\n    assert(typeof cb === 'function');\n    if (this.aborted) return;\n    this._processing++;\n\n    if (this.paused) {\n      this._processQueue.push([pattern, index, inGlobStar, cb]);\n\n      return;\n    } //console.error('PROCESS %d', this._processing, pattern)\n    // Get the first [n] parts of pattern that are all strings.\n\n\n    var n = 0;\n\n    while (typeof pattern[n] === 'string') {\n      n++;\n    } // now n is the index of the first one that is *not* a string.\n    // see if there's anything else\n\n\n    var prefix;\n\n    switch (n) {\n      // if not, then this is rather simple\n      case pattern.length:\n        this._processSimple(pattern.join('/'), index, cb);\n\n        return;\n\n      case 0:\n        // pattern *starts* with some non-trivial item.\n        // going to readdir(cwd), but not include the prefix in matches.\n        prefix = null;\n        break;\n\n      default:\n        // pattern has some string bits in the front.\n        // whatever it starts with, whether that's 'absolute' like /foo/bar,\n        // or 'relative' like '../baz'\n        prefix = pattern.slice(0, n).join('/');\n        break;\n    }\n\n    var remain = pattern.slice(n); // get the list of entries.\n\n    var read;\n    if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n      if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n      read = prefix;\n    } else read = prefix;\n\n    var abs = this._makeAbs(read); //if ignored, skip _processing\n\n\n    if (childrenIgnored(this, read)) return cb();\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);\n  };\n\n  Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n\n    this._readdir(abs, inGlobStar, function (er, entries) {\n      return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n  };\n\n  Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    // if the abs isn't a dir, then nothing can match!\n    if (!entries) return cb(); // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === '.';\n    var matchedEntries = [];\n\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n\n      if (e.charAt(0) !== '.' || dotOk) {\n        var m;\n\n        if (negate && !prefix) {\n          m = !e.match(pn);\n        } else {\n          m = e.match(pn);\n        }\n\n        if (m) matchedEntries.push(e);\n      }\n    } //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)\n\n\n    var len = matchedEntries.length; // If there are no matched entries, then nothing matches.\n\n    if (len === 0) return cb(); // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n\n    if (remain.length === 1 && !this.mark && !this.stat) {\n      if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n      for (var i = 0; i < len; i++) {\n        var e = matchedEntries[i];\n\n        if (prefix) {\n          if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n        }\n\n        if (e.charAt(0) === '/' && !this.nomount) {\n          e = path.join(this.root, e);\n        }\n\n        this._emitMatch(index, e);\n      } // This was the last one, and no stats were needed\n\n\n      return cb();\n    } // now test all matched entries as stand-ins for that part\n    // of the pattern.\n\n\n    remain.shift();\n\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n      var newPattern;\n\n      if (prefix) {\n        if (prefix !== '/') e = prefix + '/' + e;else e = prefix + e;\n      }\n\n      this._process([e].concat(remain), index, inGlobStar, cb);\n    }\n\n    cb();\n  };\n\n  Glob.prototype._emitMatch = function (index, e) {\n    if (this.aborted) return;\n    if (isIgnored(this, e)) return;\n\n    if (this.paused) {\n      this._emitQueue.push([index, e]);\n\n      return;\n    }\n\n    var abs = isAbsolute(e) ? e : this._makeAbs(e);\n    if (this.mark) e = this._mark(e);\n    if (this.absolute) e = abs;\n    if (this.matches[index][e]) return;\n\n    if (this.nodir) {\n      var c = this.cache[abs];\n      if (c === 'DIR' || Array.isArray(c)) return;\n    }\n\n    this.matches[index][e] = true;\n    var st = this.statCache[abs];\n    if (st) this.emit('stat', e, st);\n    this.emit('match', e);\n  };\n\n  Glob.prototype._readdirInGlobStar = function (abs, cb) {\n    if (this.aborted) return; // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n\n    if (this.follow) return this._readdir(abs, false, cb);\n    var lstatkey = 'lstat\\0' + abs;\n    var self = this;\n    var lstatcb = inflight(lstatkey, lstatcb_);\n    if (lstatcb) fs.lstat(abs, lstatcb);\n\n    function lstatcb_(er, lstat) {\n      if (er && er.code === 'ENOENT') return cb();\n      var isSym = lstat && lstat.isSymbolicLink();\n      self.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.\n      // don't bother doing a readdir in that case.\n\n      if (!isSym && lstat && !lstat.isDirectory()) {\n        self.cache[abs] = 'FILE';\n        cb();\n      } else self._readdir(abs, false, cb);\n    }\n  };\n\n  Glob.prototype._readdir = function (abs, inGlobStar, cb) {\n    if (this.aborted) return;\n    cb = inflight('readdir\\0' + abs + '\\0' + inGlobStar, cb);\n    if (!cb) return; //console.error('RD %j %j', +inGlobStar, abs)\n\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);\n\n    if (ownProp(this.cache, abs)) {\n      var c = this.cache[abs];\n      if (!c || c === 'FILE') return cb();\n      if (Array.isArray(c)) return cb(null, c);\n    }\n\n    var self = this;\n    fs.readdir(abs, readdirCb(this, abs, cb));\n  };\n\n  function readdirCb(self, abs, cb) {\n    return function (er, entries) {\n      if (er) self._readdirError(abs, er, cb);else self._readdirEntries(abs, entries, cb);\n    };\n  }\n\n  Glob.prototype._readdirEntries = function (abs, entries, cb) {\n    if (this.aborted) return; // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n\n    if (!this.mark && !this.stat) {\n      for (var i = 0; i < entries.length; i++) {\n        var e = entries[i];\n        if (abs === '/') e = abs + e;else e = abs + '/' + e;\n        this.cache[e] = true;\n      }\n    }\n\n    this.cache[abs] = entries;\n    return cb(null, entries);\n  };\n\n  Glob.prototype._readdirError = function (f, er, cb) {\n    if (this.aborted) return; // handle errors, and cache the information\n\n    switch (er.code) {\n      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n\n      case 'ENOTDIR':\n        // totally normal. means it *does* exist.\n        var abs = this._makeAbs(f);\n\n        this.cache[abs] = 'FILE';\n\n        if (abs === this.cwdAbs) {\n          var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n          error.path = this.cwd;\n          error.code = er.code;\n          this.emit('error', error);\n          this.abort();\n        }\n\n        break;\n\n      case 'ENOENT': // not terribly unusual\n\n      case 'ELOOP':\n      case 'ENAMETOOLONG':\n      case 'UNKNOWN':\n        this.cache[this._makeAbs(f)] = false;\n        break;\n\n      default:\n        // some unusual error.  Treat as failure.\n        this.cache[this._makeAbs(f)] = false;\n\n        if (this.strict) {\n          this.emit('error', er); // If the error is handled, then we abort\n          // if not, we threw out of here\n\n          this.abort();\n        }\n\n        if (!this.silent) console.error('glob error', er);\n        break;\n    }\n\n    return cb();\n  };\n\n  Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {\n    var self = this;\n\n    this._readdir(abs, inGlobStar, function (er, entries) {\n      self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);\n    });\n  };\n\n  Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {\n    //console.error('pgs2', prefix, remain[0], entries)\n    // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n    if (!entries) return cb(); // test without the globstar, and with every child both below\n    // and replacing the globstar.\n\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [prefix] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state\n\n    this._process(noGlobStar, index, false, cb);\n\n    var isSym = this.symlinks[abs];\n    var len = entries.length; // If it's a symlink, and we're in a globstar, then stop\n\n    if (isSym && inGlobStar) return cb();\n\n    for (var i = 0; i < len; i++) {\n      var e = entries[i];\n      if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state\n\n      var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n\n      this._process(instead, index, true, cb);\n\n      var below = gspref.concat(entries[i], remain);\n\n      this._process(below, index, true, cb);\n    }\n\n    cb();\n  };\n\n  Glob.prototype._processSimple = function (prefix, index, cb) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var self = this;\n\n    this._stat(prefix, function (er, exists) {\n      self._processSimple2(prefix, index, er, exists, cb);\n    });\n  };\n\n  Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {\n    //console.error('ps2', prefix, exists)\n    if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results\n\n    if (!exists) return cb();\n\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n      var trail = /[\\/\\\\]$/.test(prefix);\n\n      if (prefix.charAt(0) === '/') {\n        prefix = path.join(this.root, prefix);\n      } else {\n        prefix = path.resolve(this.root, prefix);\n        if (trail) prefix += '/';\n      }\n    }\n\n    if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/'); // Mark this as a match\n\n    this._emitMatch(index, prefix);\n\n    cb();\n  }; // Returns either 'DIR', 'FILE', or false\n\n\n  Glob.prototype._stat = function (f, cb) {\n    var abs = this._makeAbs(f);\n\n    var needDir = f.slice(-1) === '/';\n    if (f.length > this.maxLength) return cb();\n\n    if (!this.stat && ownProp(this.cache, abs)) {\n      var c = this.cache[abs];\n      if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it\n\n      if (!needDir || c === 'DIR') return cb(null, c);\n      if (needDir && c === 'FILE') return cb(); // otherwise we have to stat, because maybe c=true\n      // if we know it exists, but not what it is.\n    }\n\n    var exists;\n    var stat = this.statCache[abs];\n\n    if (stat !== undefined) {\n      if (stat === false) return cb(null, stat);else {\n        var type = stat.isDirectory() ? 'DIR' : 'FILE';\n        if (needDir && type === 'FILE') return cb();else return cb(null, type, stat);\n      }\n    }\n\n    var self = this;\n    var statcb = inflight('stat\\0' + abs, lstatcb_);\n    if (statcb) fs.lstat(abs, statcb);\n\n    function lstatcb_(er, lstat) {\n      if (lstat && lstat.isSymbolicLink()) {\n        // If it's a symlink, then treat it as the target, unless\n        // the target does not exist, then treat it as a file.\n        return fs.stat(abs, function (er, stat) {\n          if (er) self._stat2(f, abs, null, lstat, cb);else self._stat2(f, abs, er, stat, cb);\n        });\n      } else {\n        self._stat2(f, abs, er, lstat, cb);\n      }\n    }\n  };\n\n  Glob.prototype._stat2 = function (f, abs, er, stat, cb) {\n    if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n      this.statCache[abs] = false;\n      return cb();\n    }\n\n    var needDir = f.slice(-1) === '/';\n    this.statCache[abs] = stat;\n    if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);\n    var c = true;\n    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === 'FILE') return cb();\n    return cb(null, c, stat);\n  };\n  /***/\n\n},\n/* 76 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  function posix(path) {\n    return path.charAt(0) === '/';\n  }\n\n  function win32(path) {\n    // https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56\n    var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;\n    var result = splitDeviceRe.exec(path);\n    var device = result[1] || '';\n    var isUnc = Boolean(device && device.charAt(1) !== ':'); // UNC paths are always absolute\n\n    return Boolean(result[2] || isUnc);\n  }\n\n  module.exports = process.platform === 'win32' ? win32 : posix;\n  module.exports.posix = posix;\n  module.exports.win32 = win32;\n  /***/\n},,,\n/* 79 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"tty\");\n  /***/\n},,\n/* 81 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  exports.default = function (str, fileLoc = 'lockfile') {\n    str = (0, (_stripBom || _load_stripBom()).default)(str);\n    return hasMergeConflicts(str) ? parseWithConflict(str, fileLoc) : {\n      type: 'success',\n      object: parse(str, fileLoc)\n    };\n  };\n\n  var _util;\n\n  function _load_util() {\n    return _util = _interopRequireDefault(__webpack_require__(2));\n  }\n\n  var _invariant;\n\n  function _load_invariant() {\n    return _invariant = _interopRequireDefault(__webpack_require__(7));\n  }\n\n  var _stripBom;\n\n  function _load_stripBom() {\n    return _stripBom = _interopRequireDefault(__webpack_require__(122));\n  }\n\n  var _constants;\n\n  function _load_constants() {\n    return _constants = __webpack_require__(6);\n  }\n\n  var _errors;\n\n  function _load_errors() {\n    return _errors = __webpack_require__(4);\n  }\n\n  var _map;\n\n  function _load_map() {\n    return _map = _interopRequireDefault(__webpack_require__(20));\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n  /* eslint quotes: 0 */\n\n\n  const VERSION_REGEX = /^yarn lockfile v(\\d+)$/;\n  const TOKEN_TYPES = {\n    boolean: 'BOOLEAN',\n    string: 'STRING',\n    identifier: 'IDENTIFIER',\n    eof: 'EOF',\n    colon: 'COLON',\n    newline: 'NEWLINE',\n    comment: 'COMMENT',\n    indent: 'INDENT',\n    invalid: 'INVALID',\n    number: 'NUMBER',\n    comma: 'COMMA'\n  };\n  const VALID_PROP_VALUE_TOKENS = [TOKEN_TYPES.boolean, TOKEN_TYPES.string, TOKEN_TYPES.number];\n\n  function isValidPropValueToken(token) {\n    return VALID_PROP_VALUE_TOKENS.indexOf(token.type) >= 0;\n  }\n\n  function* tokenise(input) {\n    let lastNewline = false;\n    let line = 1;\n    let col = 0;\n\n    function buildToken(type, value) {\n      return {\n        line,\n        col,\n        type,\n        value\n      };\n    }\n\n    while (input.length) {\n      let chop = 0;\n\n      if (input[0] === '\\n' || input[0] === '\\r') {\n        chop++; // If this is a \\r\\n line, ignore both chars but only add one new line\n\n        if (input[1] === '\\n') {\n          chop++;\n        }\n\n        line++;\n        col = 0;\n        yield buildToken(TOKEN_TYPES.newline);\n      } else if (input[0] === '#') {\n        chop++;\n        let val = '';\n\n        while (input[chop] !== '\\n') {\n          val += input[chop];\n          chop++;\n        }\n\n        yield buildToken(TOKEN_TYPES.comment, val);\n      } else if (input[0] === ' ') {\n        if (lastNewline) {\n          let indent = '';\n\n          for (let i = 0; input[i] === ' '; i++) {\n            indent += input[i];\n          }\n\n          if (indent.length % 2) {\n            throw new TypeError('Invalid number of spaces');\n          } else {\n            chop = indent.length;\n            yield buildToken(TOKEN_TYPES.indent, indent.length / 2);\n          }\n        } else {\n          chop++;\n        }\n      } else if (input[0] === '\"') {\n        let val = '';\n\n        for (let i = 0;; i++) {\n          const currentChar = input[i];\n          val += currentChar;\n\n          if (i > 0 && currentChar === '\"') {\n            const isEscaped = input[i - 1] === '\\\\' && input[i - 2] !== '\\\\';\n\n            if (!isEscaped) {\n              break;\n            }\n          }\n        }\n\n        chop = val.length;\n\n        try {\n          yield buildToken(TOKEN_TYPES.string, JSON.parse(val));\n        } catch (err) {\n          if (err instanceof SyntaxError) {\n            yield buildToken(TOKEN_TYPES.invalid);\n          } else {\n            throw err;\n          }\n        }\n      } else if (/^[0-9]/.test(input)) {\n        let val = '';\n\n        for (let i = 0; /^[0-9]$/.test(input[i]); i++) {\n          val += input[i];\n        }\n\n        chop = val.length;\n        yield buildToken(TOKEN_TYPES.number, +val);\n      } else if (/^true/.test(input)) {\n        yield buildToken(TOKEN_TYPES.boolean, true);\n        chop = 4;\n      } else if (/^false/.test(input)) {\n        yield buildToken(TOKEN_TYPES.boolean, false);\n        chop = 5;\n      } else if (input[0] === ':') {\n        yield buildToken(TOKEN_TYPES.colon);\n        chop++;\n      } else if (input[0] === ',') {\n        yield buildToken(TOKEN_TYPES.comma);\n        chop++;\n      } else if (/^[a-zA-Z\\/-]/g.test(input)) {\n        let name = '';\n\n        for (let i = 0; i < input.length; i++) {\n          const char = input[i];\n\n          if (char === ':' || char === ' ' || char === '\\n' || char === '\\r' || char === ',') {\n            break;\n          } else {\n            name += char;\n          }\n        }\n\n        chop = name.length;\n        yield buildToken(TOKEN_TYPES.string, name);\n      } else {\n        yield buildToken(TOKEN_TYPES.invalid);\n      }\n\n      if (!chop) {\n        // will trigger infinite recursion\n        yield buildToken(TOKEN_TYPES.invalid);\n      }\n\n      col += chop;\n      lastNewline = input[0] === '\\n' || input[0] === '\\r' && input[1] === '\\n';\n      input = input.slice(chop);\n    }\n\n    yield buildToken(TOKEN_TYPES.eof);\n  }\n\n  class Parser {\n    constructor(input, fileLoc = 'lockfile') {\n      this.comments = [];\n      this.tokens = tokenise(input);\n      this.fileLoc = fileLoc;\n    }\n\n    onComment(token) {\n      const value = token.value;\n      (0, (_invariant || _load_invariant()).default)(typeof value === 'string', 'expected token value to be a string');\n      const comment = value.trim();\n      const versionMatch = comment.match(VERSION_REGEX);\n\n      if (versionMatch) {\n        const version = +versionMatch[1];\n\n        if (version > (_constants || _load_constants()).LOCKFILE_VERSION) {\n          throw new (_errors || _load_errors()).MessageError(`Can't install from a lockfile of version ${version} as you're on an old yarn version that only supports ` + `versions up to ${(_constants || _load_constants()).LOCKFILE_VERSION}. Run \\`$ yarn self-update\\` to upgrade to the latest version.`);\n        }\n      }\n\n      this.comments.push(comment);\n    }\n\n    next() {\n      const item = this.tokens.next();\n      (0, (_invariant || _load_invariant()).default)(item, 'expected a token');\n      const done = item.done,\n            value = item.value;\n\n      if (done || !value) {\n        throw new Error('No more tokens');\n      } else if (value.type === TOKEN_TYPES.comment) {\n        this.onComment(value);\n        return this.next();\n      } else {\n        return this.token = value;\n      }\n    }\n\n    unexpected(msg = 'Unexpected token') {\n      throw new SyntaxError(`${msg} ${this.token.line}:${this.token.col} in ${this.fileLoc}`);\n    }\n\n    expect(tokType) {\n      if (this.token.type === tokType) {\n        this.next();\n      } else {\n        this.unexpected();\n      }\n    }\n\n    eat(tokType) {\n      if (this.token.type === tokType) {\n        this.next();\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    parse(indent = 0) {\n      const obj = (0, (_map || _load_map()).default)();\n\n      while (true) {\n        const propToken = this.token;\n\n        if (propToken.type === TOKEN_TYPES.newline) {\n          const nextToken = this.next();\n\n          if (!indent) {\n            // if we have 0 indentation then the next token doesn't matter\n            continue;\n          }\n\n          if (nextToken.type !== TOKEN_TYPES.indent) {\n            // if we have no indentation after a newline then we've gone down a level\n            break;\n          }\n\n          if (nextToken.value === indent) {\n            // all is good, the indent is on our level\n            this.next();\n          } else {\n            // the indentation is less than our level\n            break;\n          }\n        } else if (propToken.type === TOKEN_TYPES.indent) {\n          if (propToken.value === indent) {\n            this.next();\n          } else {\n            break;\n          }\n        } else if (propToken.type === TOKEN_TYPES.eof) {\n          break;\n        } else if (propToken.type === TOKEN_TYPES.string) {\n          // property key\n          const key = propToken.value;\n          (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');\n          const keys = [key];\n          this.next(); // support multiple keys\n\n          while (this.token.type === TOKEN_TYPES.comma) {\n            this.next(); // skip comma\n\n            const keyToken = this.token;\n\n            if (keyToken.type !== TOKEN_TYPES.string) {\n              this.unexpected('Expected string');\n            }\n\n            const key = keyToken.value;\n            (0, (_invariant || _load_invariant()).default)(key, 'Expected a key');\n            keys.push(key);\n            this.next();\n          }\n\n          const valToken = this.token;\n\n          if (valToken.type === TOKEN_TYPES.colon) {\n            // object\n            this.next(); // parse object\n\n            const val = this.parse(indent + 1);\n\n            for (var _iterator = keys, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n              var _ref;\n\n              if (_isArray) {\n                if (_i >= _iterator.length) break;\n                _ref = _iterator[_i++];\n              } else {\n                _i = _iterator.next();\n                if (_i.done) break;\n                _ref = _i.value;\n              }\n\n              const key = _ref;\n              obj[key] = val;\n            }\n\n            if (indent && this.token.type !== TOKEN_TYPES.indent) {\n              break;\n            }\n          } else if (isValidPropValueToken(valToken)) {\n            // plain value\n            for (var _iterator2 = keys, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n              var _ref2;\n\n              if (_isArray2) {\n                if (_i2 >= _iterator2.length) break;\n                _ref2 = _iterator2[_i2++];\n              } else {\n                _i2 = _iterator2.next();\n                if (_i2.done) break;\n                _ref2 = _i2.value;\n              }\n\n              const key = _ref2;\n              obj[key] = valToken.value;\n            }\n\n            this.next();\n          } else {\n            this.unexpected('Invalid value type');\n          }\n        } else {\n          this.unexpected(`Unknown token: ${(_util || _load_util()).default.inspect(propToken)}`);\n        }\n      }\n\n      return obj;\n    }\n\n  }\n\n  const MERGE_CONFLICT_ANCESTOR = '|||||||';\n  const MERGE_CONFLICT_END = '>>>>>>>';\n  const MERGE_CONFLICT_SEP = '=======';\n  const MERGE_CONFLICT_START = '<<<<<<<';\n  /**\n   * Extract the two versions of the lockfile from a merge conflict.\n   */\n\n  function extractConflictVariants(str) {\n    const variants = [[], []];\n    const lines = str.split(/\\r?\\n/g);\n    let skip = false;\n\n    while (lines.length) {\n      const line = lines.shift();\n\n      if (line.startsWith(MERGE_CONFLICT_START)) {\n        // get the first variant\n        while (lines.length) {\n          const conflictLine = lines.shift();\n\n          if (conflictLine === MERGE_CONFLICT_SEP) {\n            skip = false;\n            break;\n          } else if (skip || conflictLine.startsWith(MERGE_CONFLICT_ANCESTOR)) {\n            skip = true;\n            continue;\n          } else {\n            variants[0].push(conflictLine);\n          }\n        } // get the second variant\n\n\n        while (lines.length) {\n          const conflictLine = lines.shift();\n\n          if (conflictLine.startsWith(MERGE_CONFLICT_END)) {\n            break;\n          } else {\n            variants[1].push(conflictLine);\n          }\n        }\n      } else {\n        variants[0].push(line);\n        variants[1].push(line);\n      }\n    }\n\n    return [variants[0].join('\\n'), variants[1].join('\\n')];\n  }\n  /**\n   * Check if a lockfile has merge conflicts.\n   */\n\n\n  function hasMergeConflicts(str) {\n    return str.includes(MERGE_CONFLICT_START) && str.includes(MERGE_CONFLICT_SEP) && str.includes(MERGE_CONFLICT_END);\n  }\n  /**\n   * Parse the lockfile.\n   */\n\n\n  function parse(str, fileLoc) {\n    const parser = new Parser(str, fileLoc);\n    parser.next();\n    return parser.parse();\n  }\n  /**\n   * Parse and merge the two variants in a conflicted lockfile.\n   */\n\n\n  function parseWithConflict(str, fileLoc) {\n    const variants = extractConflictVariants(str);\n\n    try {\n      return {\n        type: 'merge',\n        object: Object.assign({}, parse(variants[0], fileLoc), parse(variants[1], fileLoc))\n      };\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        return {\n          type: 'conflict',\n          object: {}\n        };\n      } else {\n        throw err;\n      }\n    }\n  }\n  /***/\n\n},,,\n/* 84 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n\n  var _map;\n\n  function _load_map() {\n    return _map = _interopRequireDefault(__webpack_require__(20));\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  }\n\n  const debug = __webpack_require__(212)('yarn');\n\n  class BlockingQueue {\n    constructor(alias, maxConcurrency = Infinity) {\n      this.concurrencyQueue = [];\n      this.maxConcurrency = maxConcurrency;\n      this.runningCount = 0;\n      this.warnedStuck = false;\n      this.alias = alias;\n      this.first = true;\n      this.running = (0, (_map || _load_map()).default)();\n      this.queue = (0, (_map || _load_map()).default)();\n      this.stuckTick = this.stuckTick.bind(this);\n    }\n\n    stillActive() {\n      if (this.stuckTimer) {\n        clearTimeout(this.stuckTimer);\n      }\n\n      this.stuckTimer = setTimeout(this.stuckTick, 5000); // We need to check the existence of unref because of https://github.com/facebook/jest/issues/4559\n      // $FlowFixMe: Node's setInterval returns a Timeout, not a Number\n\n      this.stuckTimer.unref && this.stuckTimer.unref();\n    }\n\n    stuckTick() {\n      if (this.runningCount === 1) {\n        this.warnedStuck = true;\n        debug(`The ${JSON.stringify(this.alias)} blocking queue may be stuck. 5 seconds ` + `without any activity with 1 worker: ${Object.keys(this.running)[0]}`);\n      }\n    }\n\n    push(key, factory) {\n      if (this.first) {\n        this.first = false;\n      } else {\n        this.stillActive();\n      }\n\n      return new Promise((resolve, reject) => {\n        // we're already running so push ourselves to the queue\n        const queue = this.queue[key] = this.queue[key] || [];\n        queue.push({\n          factory,\n          resolve,\n          reject\n        });\n\n        if (!this.running[key]) {\n          this.shift(key);\n        }\n      });\n    }\n\n    shift(key) {\n      if (this.running[key]) {\n        delete this.running[key];\n        this.runningCount--;\n\n        if (this.stuckTimer) {\n          clearTimeout(this.stuckTimer);\n          this.stuckTimer = null;\n        }\n\n        if (this.warnedStuck) {\n          this.warnedStuck = false;\n          debug(`${JSON.stringify(this.alias)} blocking queue finally resolved. Nothing to worry about.`);\n        }\n      }\n\n      const queue = this.queue[key];\n\n      if (!queue) {\n        return;\n      }\n\n      var _queue$shift = queue.shift();\n\n      const resolve = _queue$shift.resolve,\n            reject = _queue$shift.reject,\n            factory = _queue$shift.factory;\n\n      if (!queue.length) {\n        delete this.queue[key];\n      }\n\n      const next = () => {\n        this.shift(key);\n        this.shiftConcurrencyQueue();\n      };\n\n      const run = () => {\n        this.running[key] = true;\n        this.runningCount++;\n        factory().then(function (val) {\n          resolve(val);\n          next();\n          return null;\n        }).catch(function (err) {\n          reject(err);\n          next();\n        });\n      };\n\n      this.maybePushConcurrencyQueue(run);\n    }\n\n    maybePushConcurrencyQueue(run) {\n      if (this.runningCount < this.maxConcurrency) {\n        run();\n      } else {\n        this.concurrencyQueue.push(run);\n      }\n    }\n\n    shiftConcurrencyQueue() {\n      if (this.runningCount < this.maxConcurrency) {\n        const fn = this.concurrencyQueue.shift();\n\n        if (fn) {\n          fn();\n        }\n      }\n    }\n\n  }\n\n  exports.default = BlockingQueue;\n  /***/\n},\n/* 85 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (exec) {\n    try {\n      return !!exec();\n    } catch (e) {\n      return true;\n    }\n  };\n  /***/\n\n},,,,,,,,,,,,,,,\n/* 100 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // getting tag from 19.1.3.6 Object.prototype.toString()\n  var cof = __webpack_require__(47);\n\n  var TAG = __webpack_require__(13)('toStringTag'); // ES3 wrong here\n\n\n  var ARG = cof(function () {\n    return arguments;\n  }()) == 'Arguments'; // fallback for IE11 Script Access Denied error\n\n  var tryGet = function (it, key) {\n    try {\n      return it[key];\n    } catch (e) {\n      /* empty */\n    }\n  };\n\n  module.exports = function (it) {\n    var O, T, B;\n    return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case\n    : ARG ? cof(O) // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n  };\n  /***/\n\n},\n/* 101 */\n\n/***/\nfunction (module, exports) {\n  // IE 8- don't enum bug keys\n  module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');\n  /***/\n},\n/* 102 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var document = __webpack_require__(11).document;\n\n  module.exports = document && document.documentElement;\n  /***/\n},\n/* 103 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var LIBRARY = __webpack_require__(69);\n\n  var $export = __webpack_require__(41);\n\n  var redefine = __webpack_require__(197);\n\n  var hide = __webpack_require__(31);\n\n  var Iterators = __webpack_require__(35);\n\n  var $iterCreate = __webpack_require__(188);\n\n  var setToStringTag = __webpack_require__(71);\n\n  var getPrototypeOf = __webpack_require__(194);\n\n  var ITERATOR = __webpack_require__(13)('iterator');\n\n  var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\n\n  var FF_ITERATOR = '@@iterator';\n  var KEYS = 'keys';\n  var VALUES = 'values';\n\n  var returnThis = function () {\n    return this;\n  };\n\n  module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n    $iterCreate(Constructor, NAME, next);\n\n    var getMethod = function (kind) {\n      if (!BUGGY && kind in proto) return proto[kind];\n\n      switch (kind) {\n        case KEYS:\n          return function keys() {\n            return new Constructor(this, kind);\n          };\n\n        case VALUES:\n          return function values() {\n            return new Constructor(this, kind);\n          };\n      }\n\n      return function entries() {\n        return new Constructor(this, kind);\n      };\n    };\n\n    var TAG = NAME + ' Iterator';\n    var DEF_VALUES = DEFAULT == VALUES;\n    var VALUES_BUG = false;\n    var proto = Base.prototype;\n    var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n    var $default = $native || getMethod(DEFAULT);\n    var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n    var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n    var methods, key, IteratorPrototype; // Fix native\n\n    if ($anyNative) {\n      IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n\n      if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n        // Set @@toStringTag to native iterators\n        setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines\n\n        if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n      }\n    } // fix Array#{values, @@iterator}.name in V8 / FF\n\n\n    if (DEF_VALUES && $native && $native.name !== VALUES) {\n      VALUES_BUG = true;\n\n      $default = function values() {\n        return $native.call(this);\n      };\n    } // Define iterator\n\n\n    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n      hide(proto, ITERATOR, $default);\n    } // Plug for library\n\n\n    Iterators[NAME] = $default;\n    Iterators[TAG] = returnThis;\n\n    if (DEFAULT) {\n      methods = {\n        values: DEF_VALUES ? $default : getMethod(VALUES),\n        keys: IS_SET ? $default : getMethod(KEYS),\n        entries: $entries\n      };\n      if (FORCED) for (key in methods) {\n        if (!(key in proto)) redefine(proto, key, methods[key]);\n      } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n    }\n\n    return methods;\n  };\n  /***/\n\n},\n/* 104 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (exec) {\n    try {\n      return {\n        e: false,\n        v: exec()\n      };\n    } catch (e) {\n      return {\n        e: true,\n        v: e\n      };\n    }\n  };\n  /***/\n\n},\n/* 105 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var anObject = __webpack_require__(27);\n\n  var isObject = __webpack_require__(34);\n\n  var newPromiseCapability = __webpack_require__(70);\n\n  module.exports = function (C, x) {\n    anObject(C);\n    if (isObject(x) && x.constructor === C) return x;\n    var promiseCapability = newPromiseCapability.f(C);\n    var resolve = promiseCapability.resolve;\n    resolve(x);\n    return promiseCapability.promise;\n  };\n  /***/\n\n},\n/* 106 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (bitmap, value) {\n    return {\n      enumerable: !(bitmap & 1),\n      configurable: !(bitmap & 2),\n      writable: !(bitmap & 4),\n      value: value\n    };\n  };\n  /***/\n\n},\n/* 107 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var core = __webpack_require__(23);\n\n  var global = __webpack_require__(11);\n\n  var SHARED = '__core-js_shared__';\n  var store = global[SHARED] || (global[SHARED] = {});\n  (module.exports = function (key, value) {\n    return store[key] || (store[key] = value !== undefined ? value : {});\n  })('versions', []).push({\n    version: core.version,\n    mode: __webpack_require__(69) ? 'pure' : 'global',\n    copyright: '© 2018 Denis Pushkarev (zloirock.ru)'\n  });\n  /***/\n},\n/* 108 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 7.3.20 SpeciesConstructor(O, defaultConstructor)\n  var anObject = __webpack_require__(27);\n\n  var aFunction = __webpack_require__(46);\n\n  var SPECIES = __webpack_require__(13)('species');\n\n  module.exports = function (O, D) {\n    var C = anObject(O).constructor;\n    var S;\n    return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n  };\n  /***/\n\n},\n/* 109 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var ctx = __webpack_require__(48);\n\n  var invoke = __webpack_require__(185);\n\n  var html = __webpack_require__(102);\n\n  var cel = __webpack_require__(68);\n\n  var global = __webpack_require__(11);\n\n  var process = global.process;\n  var setTask = global.setImmediate;\n  var clearTask = global.clearImmediate;\n  var MessageChannel = global.MessageChannel;\n  var Dispatch = global.Dispatch;\n  var counter = 0;\n  var queue = {};\n  var ONREADYSTATECHANGE = 'onreadystatechange';\n  var defer, channel, port;\n\n  var run = function () {\n    var id = +this; // eslint-disable-next-line no-prototype-builtins\n\n    if (queue.hasOwnProperty(id)) {\n      var fn = queue[id];\n      delete queue[id];\n      fn();\n    }\n  };\n\n  var listener = function (event) {\n    run.call(event.data);\n  }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\n\n  if (!setTask || !clearTask) {\n    setTask = function setImmediate(fn) {\n      var args = [];\n      var i = 1;\n\n      while (arguments.length > i) args.push(arguments[i++]);\n\n      queue[++counter] = function () {\n        // eslint-disable-next-line no-new-func\n        invoke(typeof fn == 'function' ? fn : Function(fn), args);\n      };\n\n      defer(counter);\n      return counter;\n    };\n\n    clearTask = function clearImmediate(id) {\n      delete queue[id];\n    }; // Node.js 0.8-\n\n\n    if (__webpack_require__(47)(process) == 'process') {\n      defer = function (id) {\n        process.nextTick(ctx(run, id, 1));\n      }; // Sphere (JS game engine) Dispatch API\n\n    } else if (Dispatch && Dispatch.now) {\n      defer = function (id) {\n        Dispatch.now(ctx(run, id, 1));\n      }; // Browsers with MessageChannel, includes WebWorkers\n\n    } else if (MessageChannel) {\n      channel = new MessageChannel();\n      port = channel.port2;\n      channel.port1.onmessage = listener;\n      defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers\n      // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n    } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {\n      defer = function (id) {\n        global.postMessage(id + '', '*');\n      };\n\n      global.addEventListener('message', listener, false); // IE8-\n    } else if (ONREADYSTATECHANGE in cel('script')) {\n      defer = function (id) {\n        html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {\n          html.removeChild(this);\n          run.call(id);\n        };\n      }; // Rest old browsers\n\n    } else {\n      defer = function (id) {\n        setTimeout(ctx(run, id, 1), 0);\n      };\n    }\n  }\n\n  module.exports = {\n    set: setTask,\n    clear: clearTask\n  };\n  /***/\n},\n/* 110 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 7.1.15 ToLength\n  var toInteger = __webpack_require__(73);\n\n  var min = Math.min;\n\n  module.exports = function (it) {\n    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n  };\n  /***/\n\n},\n/* 111 */\n\n/***/\nfunction (module, exports) {\n  var id = 0;\n  var px = Math.random();\n\n  module.exports = function (key) {\n    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n  };\n  /***/\n\n},\n/* 112 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /**\n   * This is the common logic for both the Node.js and web browser\n   * implementations of `debug()`.\n   *\n   * Expose `debug()` as the module.\n   */\n  exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n  exports.coerce = coerce;\n  exports.disable = disable;\n  exports.enable = enable;\n  exports.enabled = enabled;\n  exports.humanize = __webpack_require__(229);\n  /**\n   * Active `debug` instances.\n   */\n\n  exports.instances = [];\n  /**\n   * The currently active debug mode names, and names to skip.\n   */\n\n  exports.names = [];\n  exports.skips = [];\n  /**\n   * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n   *\n   * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n   */\n\n  exports.formatters = {};\n  /**\n   * Select a color.\n   * @param {String} namespace\n   * @return {Number}\n   * @api private\n   */\n\n  function selectColor(namespace) {\n    var hash = 0,\n        i;\n\n    for (i in namespace) {\n      hash = (hash << 5) - hash + namespace.charCodeAt(i);\n      hash |= 0; // Convert to 32bit integer\n    }\n\n    return exports.colors[Math.abs(hash) % exports.colors.length];\n  }\n  /**\n   * Create a debugger with the given `namespace`.\n   *\n   * @param {String} namespace\n   * @return {Function}\n   * @api public\n   */\n\n\n  function createDebug(namespace) {\n    var prevTime;\n\n    function debug() {\n      // disabled?\n      if (!debug.enabled) return;\n      var self = debug; // set `diff` timestamp\n\n      var curr = +new Date();\n      var ms = curr - (prevTime || curr);\n      self.diff = ms;\n      self.prev = prevTime;\n      self.curr = curr;\n      prevTime = curr; // turn the `arguments` into a proper Array\n\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < args.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      args[0] = exports.coerce(args[0]);\n\n      if ('string' !== typeof args[0]) {\n        // anything else let's inspect with %O\n        args.unshift('%O');\n      } // apply any `formatters` transformations\n\n\n      var index = 0;\n      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {\n        // if we encounter an escaped % then don't increase the array index\n        if (match === '%%') return match;\n        index++;\n        var formatter = exports.formatters[format];\n\n        if ('function' === typeof formatter) {\n          var val = args[index];\n          match = formatter.call(self, val); // now we need to remove `args[index]` since it's inlined in the `format`\n\n          args.splice(index, 1);\n          index--;\n        }\n\n        return match;\n      }); // apply env-specific formatting (colors, etc.)\n\n      exports.formatArgs.call(self, args);\n      var logFn = debug.log || exports.log || console.log.bind(console);\n      logFn.apply(self, args);\n    }\n\n    debug.namespace = namespace;\n    debug.enabled = exports.enabled(namespace);\n    debug.useColors = exports.useColors();\n    debug.color = selectColor(namespace);\n    debug.destroy = destroy; // env-specific initialization logic for debug instances\n\n    if ('function' === typeof exports.init) {\n      exports.init(debug);\n    }\n\n    exports.instances.push(debug);\n    return debug;\n  }\n\n  function destroy() {\n    var index = exports.instances.indexOf(this);\n\n    if (index !== -1) {\n      exports.instances.splice(index, 1);\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Enables a debug mode by namespaces. This can include modes\n   * separated by a colon and wildcards.\n   *\n   * @param {String} namespaces\n   * @api public\n   */\n\n\n  function enable(namespaces) {\n    exports.save(namespaces);\n    exports.names = [];\n    exports.skips = [];\n    var i;\n    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n    var len = split.length;\n\n    for (i = 0; i < len; i++) {\n      if (!split[i]) continue; // ignore empty strings\n\n      namespaces = split[i].replace(/\\*/g, '.*?');\n\n      if (namespaces[0] === '-') {\n        exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n      } else {\n        exports.names.push(new RegExp('^' + namespaces + '$'));\n      }\n    }\n\n    for (i = 0; i < exports.instances.length; i++) {\n      var instance = exports.instances[i];\n      instance.enabled = exports.enabled(instance.namespace);\n    }\n  }\n  /**\n   * Disable debug output.\n   *\n   * @api public\n   */\n\n\n  function disable() {\n    exports.enable('');\n  }\n  /**\n   * Returns true if the given mode name is enabled, false otherwise.\n   *\n   * @param {String} name\n   * @return {Boolean}\n   * @api public\n   */\n\n\n  function enabled(name) {\n    if (name[name.length - 1] === '*') {\n      return true;\n    }\n\n    var i, len;\n\n    for (i = 0, len = exports.skips.length; i < len; i++) {\n      if (exports.skips[i].test(name)) {\n        return false;\n      }\n    }\n\n    for (i = 0, len = exports.names.length; i < len; i++) {\n      if (exports.names[i].test(name)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Coerce `val`.\n   *\n   * @param {Mixed} val\n   * @return {Mixed}\n   * @api private\n   */\n\n\n  function coerce(val) {\n    if (val instanceof Error) return val.stack || val.message;\n    return val;\n  }\n  /***/\n\n},,\n/* 114 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = realpath;\n  realpath.realpath = realpath;\n  realpath.sync = realpathSync;\n  realpath.realpathSync = realpathSync;\n  realpath.monkeypatch = monkeypatch;\n  realpath.unmonkeypatch = unmonkeypatch;\n\n  var fs = __webpack_require__(3);\n\n  var origRealpath = fs.realpath;\n  var origRealpathSync = fs.realpathSync;\n  var version = process.version;\n  var ok = /^v[0-5]\\./.test(version);\n\n  var old = __webpack_require__(217);\n\n  function newError(er) {\n    return er && er.syscall === 'realpath' && (er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG');\n  }\n\n  function realpath(p, cache, cb) {\n    if (ok) {\n      return origRealpath(p, cache, cb);\n    }\n\n    if (typeof cache === 'function') {\n      cb = cache;\n      cache = null;\n    }\n\n    origRealpath(p, cache, function (er, result) {\n      if (newError(er)) {\n        old.realpath(p, cache, cb);\n      } else {\n        cb(er, result);\n      }\n    });\n  }\n\n  function realpathSync(p, cache) {\n    if (ok) {\n      return origRealpathSync(p, cache);\n    }\n\n    try {\n      return origRealpathSync(p, cache);\n    } catch (er) {\n      if (newError(er)) {\n        return old.realpathSync(p, cache);\n      } else {\n        throw er;\n      }\n    }\n  }\n\n  function monkeypatch() {\n    fs.realpath = realpath;\n    fs.realpathSync = realpathSync;\n  }\n\n  function unmonkeypatch() {\n    fs.realpath = origRealpath;\n    fs.realpathSync = origRealpathSync;\n  }\n  /***/\n\n},\n/* 115 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  exports.alphasort = alphasort;\n  exports.alphasorti = alphasorti;\n  exports.setopts = setopts;\n  exports.ownProp = ownProp;\n  exports.makeAbs = makeAbs;\n  exports.finish = finish;\n  exports.mark = mark;\n  exports.isIgnored = isIgnored;\n  exports.childrenIgnored = childrenIgnored;\n\n  function ownProp(obj, field) {\n    return Object.prototype.hasOwnProperty.call(obj, field);\n  }\n\n  var path = __webpack_require__(0);\n\n  var minimatch = __webpack_require__(60);\n\n  var isAbsolute = __webpack_require__(76);\n\n  var Minimatch = minimatch.Minimatch;\n\n  function alphasorti(a, b) {\n    return a.toLowerCase().localeCompare(b.toLowerCase());\n  }\n\n  function alphasort(a, b) {\n    return a.localeCompare(b);\n  }\n\n  function setupIgnores(self, options) {\n    self.ignore = options.ignore || [];\n    if (!Array.isArray(self.ignore)) self.ignore = [self.ignore];\n\n    if (self.ignore.length) {\n      self.ignore = self.ignore.map(ignoreMap);\n    }\n  } // ignore patterns are always in dot:true mode.\n\n\n  function ignoreMap(pattern) {\n    var gmatcher = null;\n\n    if (pattern.slice(-3) === '/**') {\n      var gpattern = pattern.replace(/(\\/\\*\\*)+$/, '');\n      gmatcher = new Minimatch(gpattern, {\n        dot: true\n      });\n    }\n\n    return {\n      matcher: new Minimatch(pattern, {\n        dot: true\n      }),\n      gmatcher: gmatcher\n    };\n  }\n\n  function setopts(self, pattern, options) {\n    if (!options) options = {}; // base-matching: just use globstar for that.\n\n    if (options.matchBase && -1 === pattern.indexOf(\"/\")) {\n      if (options.noglobstar) {\n        throw new Error(\"base matching requires globstar\");\n      }\n\n      pattern = \"**/\" + pattern;\n    }\n\n    self.silent = !!options.silent;\n    self.pattern = pattern;\n    self.strict = options.strict !== false;\n    self.realpath = !!options.realpath;\n    self.realpathCache = options.realpathCache || Object.create(null);\n    self.follow = !!options.follow;\n    self.dot = !!options.dot;\n    self.mark = !!options.mark;\n    self.nodir = !!options.nodir;\n    if (self.nodir) self.mark = true;\n    self.sync = !!options.sync;\n    self.nounique = !!options.nounique;\n    self.nonull = !!options.nonull;\n    self.nosort = !!options.nosort;\n    self.nocase = !!options.nocase;\n    self.stat = !!options.stat;\n    self.noprocess = !!options.noprocess;\n    self.absolute = !!options.absolute;\n    self.maxLength = options.maxLength || Infinity;\n    self.cache = options.cache || Object.create(null);\n    self.statCache = options.statCache || Object.create(null);\n    self.symlinks = options.symlinks || Object.create(null);\n    setupIgnores(self, options);\n    self.changedCwd = false;\n    var cwd = process.cwd();\n    if (!ownProp(options, \"cwd\")) self.cwd = cwd;else {\n      self.cwd = path.resolve(options.cwd);\n      self.changedCwd = self.cwd !== cwd;\n    }\n    self.root = options.root || path.resolve(self.cwd, \"/\");\n    self.root = path.resolve(self.root);\n    if (process.platform === \"win32\") self.root = self.root.replace(/\\\\/g, \"/\"); // TODO: is an absolute `cwd` supposed to be resolved against `root`?\n    // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')\n\n    self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);\n    if (process.platform === \"win32\") self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");\n    self.nomount = !!options.nomount; // disable comments and negation in Minimatch.\n    // Note that they are not supported in Glob itself anyway.\n\n    options.nonegate = true;\n    options.nocomment = true;\n    self.minimatch = new Minimatch(pattern, options);\n    self.options = self.minimatch.options;\n  }\n\n  function finish(self) {\n    var nou = self.nounique;\n    var all = nou ? [] : Object.create(null);\n\n    for (var i = 0, l = self.matches.length; i < l; i++) {\n      var matches = self.matches[i];\n\n      if (!matches || Object.keys(matches).length === 0) {\n        if (self.nonull) {\n          // do like the shell, and spit out the literal glob\n          var literal = self.minimatch.globSet[i];\n          if (nou) all.push(literal);else all[literal] = true;\n        }\n      } else {\n        // had matches\n        var m = Object.keys(matches);\n        if (nou) all.push.apply(all, m);else m.forEach(function (m) {\n          all[m] = true;\n        });\n      }\n    }\n\n    if (!nou) all = Object.keys(all);\n    if (!self.nosort) all = all.sort(self.nocase ? alphasorti : alphasort); // at *some* point we statted all of these\n\n    if (self.mark) {\n      for (var i = 0; i < all.length; i++) {\n        all[i] = self._mark(all[i]);\n      }\n\n      if (self.nodir) {\n        all = all.filter(function (e) {\n          var notDir = !/\\/$/.test(e);\n          var c = self.cache[e] || self.cache[makeAbs(self, e)];\n          if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);\n          return notDir;\n        });\n      }\n    }\n\n    if (self.ignore.length) all = all.filter(function (m) {\n      return !isIgnored(self, m);\n    });\n    self.found = all;\n  }\n\n  function mark(self, p) {\n    var abs = makeAbs(self, p);\n    var c = self.cache[abs];\n    var m = p;\n\n    if (c) {\n      var isDir = c === 'DIR' || Array.isArray(c);\n      var slash = p.slice(-1) === '/';\n      if (isDir && !slash) m += '/';else if (!isDir && slash) m = m.slice(0, -1);\n\n      if (m !== p) {\n        var mabs = makeAbs(self, m);\n        self.statCache[mabs] = self.statCache[abs];\n        self.cache[mabs] = self.cache[abs];\n      }\n    }\n\n    return m;\n  } // lotta situps...\n\n\n  function makeAbs(self, f) {\n    var abs = f;\n\n    if (f.charAt(0) === '/') {\n      abs = path.join(self.root, f);\n    } else if (isAbsolute(f) || f === '') {\n      abs = f;\n    } else if (self.changedCwd) {\n      abs = path.resolve(self.cwd, f);\n    } else {\n      abs = path.resolve(f);\n    }\n\n    if (process.platform === 'win32') abs = abs.replace(/\\\\/g, '/');\n    return abs;\n  } // Return true, if pattern ends with globstar '**', for the accompanying parent directory.\n  // Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents\n\n\n  function isIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function (item) {\n      return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path));\n    });\n  }\n\n  function childrenIgnored(self, path) {\n    if (!self.ignore.length) return false;\n    return self.ignore.some(function (item) {\n      return !!(item.gmatcher && item.gmatcher.match(path));\n    });\n  }\n  /***/\n\n},\n/* 116 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var path = __webpack_require__(0);\n\n  var fs = __webpack_require__(3);\n\n  var _0777 = parseInt('0777', 8);\n\n  module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\n  function mkdirP(p, opts, f, made) {\n    if (typeof opts === 'function') {\n      f = opts;\n      opts = {};\n    } else if (!opts || typeof opts !== 'object') {\n      opts = {\n        mode: opts\n      };\n    }\n\n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n\n    if (mode === undefined) {\n      mode = _0777 & ~process.umask();\n    }\n\n    if (!made) made = null;\n\n    var cb = f || function () {};\n\n    p = path.resolve(p);\n    xfs.mkdir(p, mode, function (er) {\n      if (!er) {\n        made = made || p;\n        return cb(null, made);\n      }\n\n      switch (er.code) {\n        case 'ENOENT':\n          mkdirP(path.dirname(p), opts, function (er, made) {\n            if (er) cb(er, made);else mkdirP(p, opts, cb, made);\n          });\n          break;\n        // In the case of any other error, just see if there's a dir\n        // there already.  If so, then hooray!  If not, then something\n        // is borked.\n\n        default:\n          xfs.stat(p, function (er2, stat) {\n            // if the stat fails, then that's super weird.\n            // let the original error be the failure reason.\n            if (er2 || !stat.isDirectory()) cb(er, made);else cb(null, made);\n          });\n          break;\n      }\n    });\n  }\n\n  mkdirP.sync = function sync(p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n      opts = {\n        mode: opts\n      };\n    }\n\n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n\n    if (mode === undefined) {\n      mode = _0777 & ~process.umask();\n    }\n\n    if (!made) made = null;\n    p = path.resolve(p);\n\n    try {\n      xfs.mkdirSync(p, mode);\n      made = made || p;\n    } catch (err0) {\n      switch (err0.code) {\n        case 'ENOENT':\n          made = sync(path.dirname(p), opts, made);\n          sync(p, opts, made);\n          break;\n        // In the case of any other error, just see if there's a dir\n        // there already.  If so, then hooray!  If not, then something\n        // is borked.\n\n        default:\n          var stat;\n\n          try {\n            stat = xfs.statSync(p);\n          } catch (err1) {\n            throw err0;\n          }\n\n          if (!stat.isDirectory()) throw err0;\n          break;\n      }\n    }\n\n    return made;\n  };\n  /***/\n\n},,,,,,\n/* 122 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  module.exports = x => {\n    if (typeof x !== 'string') {\n      throw new TypeError('Expected a string, got ' + typeof x);\n    } // Catches EFBBBF (UTF-8 BOM) because the buffer-to-string\n    // conversion translates it to FEFF (UTF-16 BOM)\n\n\n    if (x.charCodeAt(0) === 0xFEFF) {\n      return x.slice(1);\n    }\n\n    return x;\n  };\n  /***/\n\n},\n/* 123 */\n\n/***/\nfunction (module, exports) {\n  // Returns a wrapper function that returns a wrapped callback\n  // The wrapper function should do some stuff, and return a\n  // presumably different callback function.\n  // This makes sure that own properties are retained, so that\n  // decorations and such are not lost along the way.\n  module.exports = wrappy;\n\n  function wrappy(fn, cb) {\n    if (fn && cb) return wrappy(fn)(cb);\n    if (typeof fn !== 'function') throw new TypeError('need wrapper function');\n    Object.keys(fn).forEach(function (k) {\n      wrapper[k] = fn[k];\n    });\n    return wrapper;\n\n    function wrapper() {\n      var args = new Array(arguments.length);\n\n      for (var i = 0; i < args.length; i++) {\n        args[i] = arguments[i];\n      }\n\n      var ret = fn.apply(this, args);\n      var cb = args[args.length - 1];\n\n      if (typeof ret === 'function' && ret !== cb) {\n        Object.keys(cb).forEach(function (k) {\n          ret[k] = cb[k];\n        });\n      }\n\n      return ret;\n    }\n  }\n  /***/\n\n},,,,,,,,\n/* 131 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // fallback for non-array-like ES3 and non-enumerable old V8 strings\n  var cof = __webpack_require__(47); // eslint-disable-next-line no-prototype-builtins\n\n\n  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n    return cof(it) == 'String' ? it.split('') : Object(it);\n  };\n  /***/\n},\n/* 132 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 19.1.2.14 / 15.2.3.14 Object.keys(O)\n  var $keys = __webpack_require__(195);\n\n  var enumBugKeys = __webpack_require__(101);\n\n  module.exports = Object.keys || function keys(O) {\n    return $keys(O, enumBugKeys);\n  };\n  /***/\n\n},\n/* 133 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 7.1.13 ToObject(argument)\n  var defined = __webpack_require__(67);\n\n  module.exports = function (it) {\n    return Object(defined(it));\n  };\n  /***/\n\n},,,,,,,,,,,,\n/* 145 */\n\n/***/\nfunction (module, exports) {\n  module.exports = {\n    \"name\": \"yarn\",\n    \"installationMethod\": \"unknown\",\n    \"version\": \"1.10.0-0\",\n    \"license\": \"BSD-2-Clause\",\n    \"preferGlobal\": true,\n    \"description\": \"📦🐈 Fast, reliable, and secure dependency management.\",\n    \"dependencies\": {\n      \"@zkochan/cmd-shim\": \"^2.2.4\",\n      \"babel-runtime\": \"^6.26.0\",\n      \"bytes\": \"^3.0.0\",\n      \"camelcase\": \"^4.0.0\",\n      \"chalk\": \"^2.1.0\",\n      \"commander\": \"^2.9.0\",\n      \"death\": \"^1.0.0\",\n      \"debug\": \"^3.0.0\",\n      \"deep-equal\": \"^1.0.1\",\n      \"detect-indent\": \"^5.0.0\",\n      \"dnscache\": \"^1.0.1\",\n      \"glob\": \"^7.1.1\",\n      \"gunzip-maybe\": \"^1.4.0\",\n      \"hash-for-dep\": \"^1.2.3\",\n      \"imports-loader\": \"^0.8.0\",\n      \"ini\": \"^1.3.4\",\n      \"inquirer\": \"^3.0.1\",\n      \"invariant\": \"^2.2.0\",\n      \"is-builtin-module\": \"^2.0.0\",\n      \"is-ci\": \"^1.0.10\",\n      \"is-webpack-bundle\": \"^1.0.0\",\n      \"leven\": \"^2.0.0\",\n      \"loud-rejection\": \"^1.2.0\",\n      \"micromatch\": \"^2.3.11\",\n      \"mkdirp\": \"^0.5.1\",\n      \"node-emoji\": \"^1.6.1\",\n      \"normalize-url\": \"^2.0.0\",\n      \"npm-logical-tree\": \"^1.2.1\",\n      \"object-path\": \"^0.11.2\",\n      \"proper-lockfile\": \"^2.0.0\",\n      \"puka\": \"^1.0.0\",\n      \"read\": \"^1.0.7\",\n      \"request\": \"^2.87.0\",\n      \"request-capture-har\": \"^1.2.2\",\n      \"rimraf\": \"^2.5.0\",\n      \"semver\": \"^5.1.0\",\n      \"ssri\": \"^5.3.0\",\n      \"strip-ansi\": \"^4.0.0\",\n      \"strip-bom\": \"^3.0.0\",\n      \"tar-fs\": \"^1.16.0\",\n      \"tar-stream\": \"^1.6.1\",\n      \"uuid\": \"^3.0.1\",\n      \"v8-compile-cache\": \"^2.0.0\",\n      \"validate-npm-package-license\": \"^3.0.3\",\n      \"yn\": \"^2.0.0\"\n    },\n    \"devDependencies\": {\n      \"babel-core\": \"^6.26.0\",\n      \"babel-eslint\": \"^7.2.3\",\n      \"babel-loader\": \"^6.2.5\",\n      \"babel-plugin-array-includes\": \"^2.0.3\",\n      \"babel-plugin-transform-builtin-extend\": \"^1.1.2\",\n      \"babel-plugin-transform-inline-imports-commonjs\": \"^1.0.0\",\n      \"babel-plugin-transform-runtime\": \"^6.4.3\",\n      \"babel-preset-env\": \"^1.6.0\",\n      \"babel-preset-flow\": \"^6.23.0\",\n      \"babel-preset-stage-0\": \"^6.0.0\",\n      \"babylon\": \"^6.5.0\",\n      \"commitizen\": \"^2.9.6\",\n      \"cz-conventional-changelog\": \"^2.0.0\",\n      \"eslint\": \"^4.3.0\",\n      \"eslint-config-fb-strict\": \"^22.0.0\",\n      \"eslint-plugin-babel\": \"^5.0.0\",\n      \"eslint-plugin-flowtype\": \"^2.35.0\",\n      \"eslint-plugin-jasmine\": \"^2.6.2\",\n      \"eslint-plugin-jest\": \"^21.0.0\",\n      \"eslint-plugin-jsx-a11y\": \"^6.0.2\",\n      \"eslint-plugin-prefer-object-spread\": \"^1.2.1\",\n      \"eslint-plugin-prettier\": \"^2.1.2\",\n      \"eslint-plugin-react\": \"^7.1.0\",\n      \"eslint-plugin-relay\": \"^0.0.24\",\n      \"eslint-plugin-yarn-internal\": \"file:scripts/eslint-rules\",\n      \"execa\": \"^0.10.0\",\n      \"flow-bin\": \"^0.66.0\",\n      \"git-release-notes\": \"^3.0.0\",\n      \"gulp\": \"^3.9.0\",\n      \"gulp-babel\": \"^7.0.0\",\n      \"gulp-if\": \"^2.0.1\",\n      \"gulp-newer\": \"^1.0.0\",\n      \"gulp-plumber\": \"^1.0.1\",\n      \"gulp-sourcemaps\": \"^2.2.0\",\n      \"gulp-util\": \"^3.0.7\",\n      \"gulp-watch\": \"^5.0.0\",\n      \"jest\": \"^22.4.4\",\n      \"jsinspect\": \"^0.12.6\",\n      \"minimatch\": \"^3.0.4\",\n      \"mock-stdin\": \"^0.3.0\",\n      \"prettier\": \"^1.5.2\",\n      \"temp\": \"^0.8.3\",\n      \"webpack\": \"^2.1.0-beta.25\",\n      \"yargs\": \"^6.3.0\"\n    },\n    \"resolutions\": {\n      \"sshpk\": \"^1.14.2\"\n    },\n    \"engines\": {\n      \"node\": \">=4.0.0\"\n    },\n    \"repository\": \"yarnpkg/yarn\",\n    \"bin\": {\n      \"yarn\": \"./bin/yarn.js\",\n      \"yarnpkg\": \"./bin/yarn.js\"\n    },\n    \"scripts\": {\n      \"build\": \"gulp build\",\n      \"build-bundle\": \"node ./scripts/build-webpack.js\",\n      \"build-chocolatey\": \"powershell ./scripts/build-chocolatey.ps1\",\n      \"build-deb\": \"./scripts/build-deb.sh\",\n      \"build-dist\": \"bash ./scripts/build-dist.sh\",\n      \"build-win-installer\": \"scripts\\\\build-windows-installer.bat\",\n      \"changelog\": \"git-release-notes $(git describe --tags --abbrev=0 $(git describe --tags --abbrev=0)^)..$(git describe --tags --abbrev=0) scripts/changelog.md\",\n      \"dupe-check\": \"yarn jsinspect ./src\",\n      \"lint\": \"eslint . && flow check\",\n      \"pkg-tests\": \"yarn --cwd packages/pkg-tests jest yarn.test.js\",\n      \"prettier\": \"eslint src __tests__ --fix\",\n      \"release-branch\": \"./scripts/release-branch.sh\",\n      \"test\": \"yarn lint && yarn test-only\",\n      \"test-only\": \"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --verbose\",\n      \"test-only-debug\": \"node --inspect-brk --max_old_space_size=4096 node_modules/jest/bin/jest.js --runInBand --verbose\",\n      \"test-coverage\": \"node --max_old_space_size=4096 node_modules/jest/bin/jest.js --coverage --verbose\",\n      \"watch\": \"gulp watch\",\n      \"commit\": \"git-cz\"\n    },\n    \"jest\": {\n      \"collectCoverageFrom\": [\"src/**/*.js\"],\n      \"testEnvironment\": \"node\",\n      \"modulePathIgnorePatterns\": [\"__tests__/fixtures/\", \"packages/pkg-tests/pkg-tests-fixtures\", \"dist/\"],\n      \"testPathIgnorePatterns\": [\"__tests__/(fixtures|__mocks__)/\", \"updates/\", \"_(temp|mock|install|init|helpers).js$\", \"packages/pkg-tests\"]\n    },\n    \"config\": {\n      \"commitizen\": {\n        \"path\": \"./node_modules/cz-conventional-changelog\"\n      }\n    }\n  };\n  /***/\n},,,,,\n/* 150 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.default = stringify;\n\n  var _misc;\n\n  function _load_misc() {\n    return _misc = __webpack_require__(12);\n  }\n\n  var _constants;\n\n  function _load_constants() {\n    return _constants = __webpack_require__(6);\n  }\n\n  var _package;\n\n  function _load_package() {\n    return _package = __webpack_require__(145);\n  }\n\n  const NODE_VERSION = process.version;\n\n  function shouldWrapKey(str) {\n    return str.indexOf('true') === 0 || str.indexOf('false') === 0 || /[:\\s\\n\\\\\",\\[\\]]/g.test(str) || /^[0-9]/g.test(str) || !/^[a-zA-Z]/g.test(str);\n  }\n\n  function maybeWrap(str) {\n    if (typeof str === 'boolean' || typeof str === 'number' || shouldWrapKey(str)) {\n      return JSON.stringify(str);\n    } else {\n      return str;\n    }\n  }\n\n  const priorities = {\n    name: 1,\n    version: 2,\n    uid: 3,\n    resolved: 4,\n    integrity: 5,\n    registry: 6,\n    dependencies: 7\n  };\n\n  function priorityThenAlphaSort(a, b) {\n    if (priorities[a] || priorities[b]) {\n      return (priorities[a] || 100) > (priorities[b] || 100) ? 1 : -1;\n    } else {\n      return (0, (_misc || _load_misc()).sortAlpha)(a, b);\n    }\n  }\n\n  function _stringify(obj, options) {\n    if (typeof obj !== 'object') {\n      throw new TypeError();\n    }\n\n    const indent = options.indent;\n    const lines = []; // Sorting order needs to be consistent between runs, we run native sort by name because there are no\n    // problems with it being unstable because there are no to keys the same\n    // However priorities can be duplicated and native sort can shuffle things from run to run\n\n    const keys = Object.keys(obj).sort(priorityThenAlphaSort);\n    let addedKeys = [];\n\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      const val = obj[key];\n\n      if (val == null || addedKeys.indexOf(key) >= 0) {\n        continue;\n      }\n\n      const valKeys = [key]; // get all keys that have the same value equality, we only want this for objects\n\n      if (typeof val === 'object') {\n        for (let j = i + 1; j < keys.length; j++) {\n          const key = keys[j];\n\n          if (val === obj[key]) {\n            valKeys.push(key);\n          }\n        }\n      }\n\n      const keyLine = valKeys.sort((_misc || _load_misc()).sortAlpha).map(maybeWrap).join(', ');\n\n      if (typeof val === 'string' || typeof val === 'boolean' || typeof val === 'number') {\n        lines.push(`${keyLine} ${maybeWrap(val)}`);\n      } else if (typeof val === 'object') {\n        lines.push(`${keyLine}:\\n${_stringify(val, {\n          indent: indent + '  '\n        })}` + (options.topLevel ? '\\n' : ''));\n      } else {\n        throw new TypeError();\n      }\n\n      addedKeys = addedKeys.concat(valKeys);\n    }\n\n    return indent + lines.join(`\\n${indent}`);\n  }\n\n  function stringify(obj, noHeader, enableVersions) {\n    const val = _stringify(obj, {\n      indent: '',\n      topLevel: true\n    });\n\n    if (noHeader) {\n      return val;\n    }\n\n    const lines = [];\n    lines.push('# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.');\n    lines.push(`# yarn lockfile v${(_constants || _load_constants()).LOCKFILE_VERSION}`);\n\n    if (enableVersions) {\n      lines.push(`# yarn v${(_package || _load_package()).version}`);\n      lines.push(`# node ${NODE_VERSION}`);\n    }\n\n    lines.push('\\n');\n    lines.push(val);\n    return lines.join('\\n');\n  }\n  /***/\n\n},,,,,,,,,,,,,,\n/* 164 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.fileDatesEqual = exports.copyFile = exports.unlink = undefined;\n\n  var _asyncToGenerator2;\n\n  function _load_asyncToGenerator() {\n    return _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(1));\n  } // We want to preserve file timestamps when copying a file, since yarn uses them to decide if a file has\n  // changed compared to the cache.\n  // There are some OS specific cases here:\n  // * On linux, fs.copyFile does not preserve timestamps, but does on OSX and Win.\n  // * On windows, you must open a file with write permissions to call `fs.futimes`.\n  // * On OSX you can open with read permissions and still call `fs.futimes`.\n\n\n  let fixTimes = (() => {\n    var _ref3 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (fd, dest, data) {\n      const doOpen = fd === undefined;\n      let openfd = fd ? fd : -1;\n\n      if (disableTimestampCorrection === undefined) {\n        // if timestamps match already, no correction is needed.\n        // the need to correct timestamps varies based on OS and node versions.\n        const destStat = yield lstat(dest);\n        disableTimestampCorrection = fileDatesEqual(destStat.mtime, data.mtime);\n      }\n\n      if (disableTimestampCorrection) {\n        return;\n      }\n\n      if (doOpen) {\n        try {\n          openfd = yield open(dest, 'a', data.mode);\n        } catch (er) {\n          // file is likely read-only\n          try {\n            openfd = yield open(dest, 'r', data.mode);\n          } catch (err) {\n            // We can't even open this file for reading.\n            return;\n          }\n        }\n      }\n\n      try {\n        if (openfd) {\n          yield futimes(openfd, data.atime, data.mtime);\n        }\n      } catch (er) {// If `futimes` throws an exception, we probably have a case of a read-only file on Windows.\n        // In this case we can just return. The incorrect timestamp will just cause that file to be recopied\n        // on subsequent installs, which will effect yarn performance but not break anything.\n      } finally {\n        if (doOpen && openfd) {\n          yield close(openfd);\n        }\n      }\n    });\n\n    return function fixTimes(_x7, _x8, _x9) {\n      return _ref3.apply(this, arguments);\n    };\n  })(); // Compare file timestamps.\n  // Some versions of Node on windows zero the milliseconds when utime is used.\n\n\n  var _fs;\n\n  function _load_fs() {\n    return _fs = _interopRequireDefault(__webpack_require__(3));\n  }\n\n  var _promise;\n\n  function _load_promise() {\n    return _promise = __webpack_require__(40);\n  }\n\n  function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : {\n      default: obj\n    };\n  } // This module serves as a wrapper for file operations that are inconsistant across node and OS versions.\n\n\n  let disableTimestampCorrection = undefined; // OS dependent. will be detected on first file copy.\n\n  const readFileBuffer = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.readFile);\n  const close = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.close);\n  const lstat = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.lstat);\n  const open = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.open);\n  const futimes = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.futimes);\n  const write = (0, (_promise || _load_promise()).promisify)((_fs || _load_fs()).default.write);\n  const unlink = exports.unlink = (0, (_promise || _load_promise()).promisify)(__webpack_require__(233));\n  /**\n   * Unlinks the destination to force a recreation. This is needed on case-insensitive file systems\n   * to force the correct naming when the filename has changed only in character-casing. (Jest -> jest).\n   */\n\n  const copyFile = exports.copyFile = (() => {\n    var _ref = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (data, cleanup) {\n      try {\n        yield unlink(data.dest);\n        yield copyFilePoly(data.src, data.dest, 0, data);\n      } finally {\n        if (cleanup) {\n          cleanup();\n        }\n      }\n    });\n\n    return function copyFile(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  })(); // Node 8.5.0 introduced `fs.copyFile` which is much faster, so use that when available.\n  // Otherwise we fall back to reading and writing files as buffers.\n\n\n  const copyFilePoly = (src, dest, flags, data) => {\n    if ((_fs || _load_fs()).default.copyFile) {\n      return new Promise((resolve, reject) => (_fs || _load_fs()).default.copyFile(src, dest, flags, err => {\n        if (err) {\n          reject(err);\n        } else {\n          fixTimes(undefined, dest, data).then(() => resolve()).catch(ex => reject(ex));\n        }\n      }));\n    } else {\n      return copyWithBuffer(src, dest, flags, data);\n    }\n  };\n\n  const copyWithBuffer = (() => {\n    var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (src, dest, flags, data) {\n      // Use open -> write -> futimes -> close sequence to avoid opening the file twice:\n      // one with writeFile and one with utimes\n      const fd = yield open(dest, 'w', data.mode);\n\n      try {\n        const buffer = yield readFileBuffer(src);\n        yield write(fd, buffer, 0, buffer.length);\n        yield fixTimes(fd, dest, data);\n      } finally {\n        yield close(fd);\n      }\n    });\n\n    return function copyWithBuffer(_x3, _x4, _x5, _x6) {\n      return _ref2.apply(this, arguments);\n    };\n  })();\n\n  const fileDatesEqual = exports.fileDatesEqual = (a, b) => {\n    const aTime = a.getTime();\n    const bTime = b.getTime();\n\n    if (process.platform !== 'win32') {\n      return aTime === bTime;\n    } // See https://github.com/nodejs/node/pull/12607\n    // Submillisecond times from stat and utimes are truncated on Windows,\n    // causing a file with mtime 8.0079998 and 8.0081144 to become 8.007 and 8.008\n    // and making it impossible to update these files to their correct timestamps.\n\n\n    if (Math.abs(aTime - bTime) <= 1) {\n      return true;\n    }\n\n    const aTimeSec = Math.floor(aTime / 1000);\n    const bTimeSec = Math.floor(bTime / 1000); // See https://github.com/nodejs/node/issues/2069\n    // Some versions of Node on windows zero the milliseconds when utime is used\n    // So if any of the time has a milliseconds part of zero we suspect that the\n    // bug is present and compare only seconds.\n\n    if (aTime - aTimeSec * 1000 === 0 || bTime - bTimeSec * 1000 === 0) {\n      return aTimeSec === bTimeSec;\n    }\n\n    return aTime === bTime;\n  };\n  /***/\n\n},,,,,\n/* 169 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.isFakeRoot = isFakeRoot;\n  exports.isRootUser = isRootUser;\n\n  function getUid() {\n    if (process.platform !== 'win32' && process.getuid) {\n      return process.getuid();\n    }\n\n    return null;\n  }\n\n  exports.default = isRootUser(getUid()) && !isFakeRoot();\n\n  function isFakeRoot() {\n    return Boolean(process.env.FAKEROOTKEY);\n  }\n\n  function isRootUser(uid) {\n    return uid === 0;\n  }\n  /***/\n\n},,\n/* 171 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  exports.getDataDir = getDataDir;\n  exports.getCacheDir = getCacheDir;\n  exports.getConfigDir = getConfigDir;\n\n  const path = __webpack_require__(0);\n\n  const userHome = __webpack_require__(45).default;\n\n  const FALLBACK_CONFIG_DIR = path.join(userHome, '.config', 'yarn');\n  const FALLBACK_CACHE_DIR = path.join(userHome, '.cache', 'yarn');\n\n  function getDataDir() {\n    if (process.platform === 'win32') {\n      const WIN32_APPDATA_DIR = getLocalAppDataDir();\n      return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Data');\n    } else if (process.env.XDG_DATA_HOME) {\n      return path.join(process.env.XDG_DATA_HOME, 'yarn');\n    } else {\n      // This could arguably be ~/Library/Application Support/Yarn on Macs,\n      // but that feels unintuitive for a cli tool\n      // Instead, use our prior fallback. Some day this could be\n      // path.join(userHome, '.local', 'share', 'yarn')\n      // or return path.join(WIN32_APPDATA_DIR, 'Data') on win32\n      return FALLBACK_CONFIG_DIR;\n    }\n  }\n\n  function getCacheDir() {\n    if (process.platform === 'win32') {\n      // process.env.TEMP also exists, but most apps put caches here\n      return path.join(getLocalAppDataDir() || path.join(userHome, 'AppData', 'Local', 'Yarn'), 'Cache');\n    } else if (process.env.XDG_CACHE_HOME) {\n      return path.join(process.env.XDG_CACHE_HOME, 'yarn');\n    } else if (process.platform === 'darwin') {\n      return path.join(userHome, 'Library', 'Caches', 'Yarn');\n    } else {\n      return FALLBACK_CACHE_DIR;\n    }\n  }\n\n  function getConfigDir() {\n    if (process.platform === 'win32') {\n      // Use our prior fallback. Some day this could be\n      // return path.join(WIN32_APPDATA_DIR, 'Config')\n      const WIN32_APPDATA_DIR = getLocalAppDataDir();\n      return WIN32_APPDATA_DIR == null ? FALLBACK_CONFIG_DIR : path.join(WIN32_APPDATA_DIR, 'Config');\n    } else if (process.env.XDG_CONFIG_HOME) {\n      return path.join(process.env.XDG_CONFIG_HOME, 'yarn');\n    } else {\n      return FALLBACK_CONFIG_DIR;\n    }\n  }\n\n  function getLocalAppDataDir() {\n    return process.env.LOCALAPPDATA ? path.join(process.env.LOCALAPPDATA, 'Yarn') : null;\n  }\n  /***/\n\n},,\n/* 173 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = {\n    \"default\": __webpack_require__(179),\n    __esModule: true\n  };\n  /***/\n},\n/* 174 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  module.exports = balanced;\n\n  function balanced(a, b, str) {\n    if (a instanceof RegExp) a = maybeMatch(a, str);\n    if (b instanceof RegExp) b = maybeMatch(b, str);\n    var r = range(a, b, str);\n    return r && {\n      start: r[0],\n      end: r[1],\n      pre: str.slice(0, r[0]),\n      body: str.slice(r[0] + a.length, r[1]),\n      post: str.slice(r[1] + b.length)\n    };\n  }\n\n  function maybeMatch(reg, str) {\n    var m = str.match(reg);\n    return m ? m[0] : null;\n  }\n\n  balanced.range = range;\n\n  function range(a, b, str) {\n    var begs, beg, left, right, result;\n    var ai = str.indexOf(a);\n    var bi = str.indexOf(b, ai + 1);\n    var i = ai;\n\n    if (ai >= 0 && bi > 0) {\n      begs = [];\n      left = str.length;\n\n      while (i >= 0 && !result) {\n        if (i == ai) {\n          begs.push(i);\n          ai = str.indexOf(a, i + 1);\n        } else if (begs.length == 1) {\n          result = [begs.pop(), bi];\n        } else {\n          beg = begs.pop();\n\n          if (beg < left) {\n            left = beg;\n            right = bi;\n          }\n\n          bi = str.indexOf(b, i + 1);\n        }\n\n        i = ai < bi && ai >= 0 ? ai : bi;\n      }\n\n      if (begs.length) {\n        result = [left, right];\n      }\n    }\n\n    return result;\n  }\n  /***/\n\n},\n/* 175 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var concatMap = __webpack_require__(178);\n\n  var balanced = __webpack_require__(174);\n\n  module.exports = expandTop;\n  var escSlash = '\\0SLASH' + Math.random() + '\\0';\n  var escOpen = '\\0OPEN' + Math.random() + '\\0';\n  var escClose = '\\0CLOSE' + Math.random() + '\\0';\n  var escComma = '\\0COMMA' + Math.random() + '\\0';\n  var escPeriod = '\\0PERIOD' + Math.random() + '\\0';\n\n  function numeric(str) {\n    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);\n  }\n\n  function escapeBraces(str) {\n    return str.split('\\\\\\\\').join(escSlash).split('\\\\{').join(escOpen).split('\\\\}').join(escClose).split('\\\\,').join(escComma).split('\\\\.').join(escPeriod);\n  }\n\n  function unescapeBraces(str) {\n    return str.split(escSlash).join('\\\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');\n  } // Basically just str.split(\",\"), but handling cases\n  // where we have nested braced sections, which should be\n  // treated as individual members, like {a,{b,c},d}\n\n\n  function parseCommaParts(str) {\n    if (!str) return [''];\n    var parts = [];\n    var m = balanced('{', '}', str);\n    if (!m) return str.split(',');\n    var pre = m.pre;\n    var body = m.body;\n    var post = m.post;\n    var p = pre.split(',');\n    p[p.length - 1] += '{' + body + '}';\n    var postParts = parseCommaParts(post);\n\n    if (post.length) {\n      p[p.length - 1] += postParts.shift();\n      p.push.apply(p, postParts);\n    }\n\n    parts.push.apply(parts, p);\n    return parts;\n  }\n\n  function expandTop(str) {\n    if (!str) return []; // I don't know why Bash 4.3 does this, but it does.\n    // Anything starting with {} will have the first two bytes preserved\n    // but *only* at the top level, so {},a}b will not expand to anything,\n    // but a{},b}c will be expanded to [a}c,abc].\n    // One could argue that this is a bug in Bash, but since the goal of\n    // this module is to match Bash's rules, we escape a leading {}\n\n    if (str.substr(0, 2) === '{}') {\n      str = '\\\\{\\\\}' + str.substr(2);\n    }\n\n    return expand(escapeBraces(str), true).map(unescapeBraces);\n  }\n\n  function identity(e) {\n    return e;\n  }\n\n  function embrace(str) {\n    return '{' + str + '}';\n  }\n\n  function isPadded(el) {\n    return /^-?0\\d/.test(el);\n  }\n\n  function lte(i, y) {\n    return i <= y;\n  }\n\n  function gte(i, y) {\n    return i >= y;\n  }\n\n  function expand(str, isTop) {\n    var expansions = [];\n    var m = balanced('{', '}', str);\n    if (!m || /\\$$/.test(m.pre)) return [str];\n    var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n    var isSequence = isNumericSequence || isAlphaSequence;\n    var isOptions = m.body.indexOf(',') >= 0;\n\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,.*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post;\n        return expand(str);\n      }\n\n      return [str];\n    }\n\n    var n;\n\n    if (isSequence) {\n      n = m.body.split(/\\.\\./);\n    } else {\n      n = parseCommaParts(m.body);\n\n      if (n.length === 1) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand(n[0], false).map(embrace);\n\n        if (n.length === 1) {\n          var post = m.post.length ? expand(m.post, false) : [''];\n          return post.map(function (p) {\n            return m.pre + n[0] + p;\n          });\n        }\n      }\n    } // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    // no need to expand pre, since it is guaranteed to be free of brace-sets\n\n\n    var pre = m.pre;\n    var post = m.post.length ? expand(m.post, false) : [''];\n    var N;\n\n    if (isSequence) {\n      var x = numeric(n[0]);\n      var y = numeric(n[1]);\n      var width = Math.max(n[0].length, n[1].length);\n      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;\n      var test = lte;\n      var reverse = y < x;\n\n      if (reverse) {\n        incr *= -1;\n        test = gte;\n      }\n\n      var pad = n.some(isPadded);\n      N = [];\n\n      for (var i = x; test(i, y); i += incr) {\n        var c;\n\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i);\n          if (c === '\\\\') c = '';\n        } else {\n          c = String(i);\n\n          if (pad) {\n            var need = width - c.length;\n\n            if (need > 0) {\n              var z = new Array(need + 1).join('0');\n              if (i < 0) c = '-' + z + c.slice(1);else c = z + c;\n            }\n          }\n        }\n\n        N.push(c);\n      }\n    } else {\n      N = concatMap(n, function (el) {\n        return expand(el, false);\n      });\n    }\n\n    for (var j = 0; j < N.length; j++) {\n      for (var k = 0; k < post.length; k++) {\n        var expansion = pre + N[j] + post[k];\n        if (!isTop || isSequence || expansion) expansions.push(expansion);\n      }\n    }\n\n    return expansions;\n  }\n  /***/\n\n},\n/* 176 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  function preserveCamelCase(str) {\n    let isLastCharLower = false;\n    let isLastCharUpper = false;\n    let isLastLastCharUpper = false;\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n\n      if (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {\n        str = str.substr(0, i) + '-' + str.substr(i);\n        isLastCharLower = false;\n        isLastLastCharUpper = isLastCharUpper;\n        isLastCharUpper = true;\n        i++;\n      } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {\n        str = str.substr(0, i - 1) + '-' + str.substr(i - 1);\n        isLastLastCharUpper = isLastCharUpper;\n        isLastCharUpper = false;\n        isLastCharLower = true;\n      } else {\n        isLastCharLower = c.toLowerCase() === c;\n        isLastLastCharUpper = isLastCharUpper;\n        isLastCharUpper = c.toUpperCase() === c;\n      }\n    }\n\n    return str;\n  }\n\n  module.exports = function (str) {\n    if (arguments.length > 1) {\n      str = Array.from(arguments).map(x => x.trim()).filter(x => x.length).join('-');\n    } else {\n      str = str.trim();\n    }\n\n    if (str.length === 0) {\n      return '';\n    }\n\n    if (str.length === 1) {\n      return str.toLowerCase();\n    }\n\n    if (/^[a-z0-9]+$/.test(str)) {\n      return str;\n    }\n\n    const hasUpperCase = str !== str.toLowerCase();\n\n    if (hasUpperCase) {\n      str = preserveCamelCase(str);\n    }\n\n    return str.replace(/^[_.\\- ]+/, '').toLowerCase().replace(/[_.\\- ]+(\\w|$)/g, (m, p1) => p1.toUpperCase());\n  };\n  /***/\n\n},,\n/* 178 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (xs, fn) {\n    var res = [];\n\n    for (var i = 0; i < xs.length; i++) {\n      var x = fn(xs[i], i);\n      if (isArray(x)) res.push.apply(res, x);else res.push(x);\n    }\n\n    return res;\n  };\n\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n  /***/\n\n},\n/* 179 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  __webpack_require__(205);\n\n  __webpack_require__(207);\n\n  __webpack_require__(210);\n\n  __webpack_require__(206);\n\n  __webpack_require__(208);\n\n  __webpack_require__(209);\n\n  module.exports = __webpack_require__(23).Promise;\n  /***/\n},\n/* 180 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function () {\n    /* empty */\n  };\n  /***/\n\n},\n/* 181 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (it, Constructor, name, forbiddenField) {\n    if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {\n      throw TypeError(name + ': incorrect invocation!');\n    }\n\n    return it;\n  };\n  /***/\n\n},\n/* 182 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // false -> Array#indexOf\n  // true  -> Array#includes\n  var toIObject = __webpack_require__(74);\n\n  var toLength = __webpack_require__(110);\n\n  var toAbsoluteIndex = __webpack_require__(200);\n\n  module.exports = function (IS_INCLUDES) {\n    return function ($this, el, fromIndex) {\n      var O = toIObject($this);\n      var length = toLength(O.length);\n      var index = toAbsoluteIndex(fromIndex, length);\n      var value; // Array#includes uses SameValueZero equality algorithm\n      // eslint-disable-next-line no-self-compare\n\n      if (IS_INCLUDES && el != el) while (length > index) {\n        value = O[index++]; // eslint-disable-next-line no-self-compare\n\n        if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not\n      } else for (; length > index; index++) if (IS_INCLUDES || index in O) {\n        if (O[index] === el) return IS_INCLUDES || index || 0;\n      }\n      return !IS_INCLUDES && -1;\n    };\n  };\n  /***/\n\n},\n/* 183 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var ctx = __webpack_require__(48);\n\n  var call = __webpack_require__(187);\n\n  var isArrayIter = __webpack_require__(186);\n\n  var anObject = __webpack_require__(27);\n\n  var toLength = __webpack_require__(110);\n\n  var getIterFn = __webpack_require__(203);\n\n  var BREAK = {};\n  var RETURN = {};\n\n  var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {\n    var iterFn = ITERATOR ? function () {\n      return iterable;\n    } : getIterFn(iterable);\n    var f = ctx(fn, that, entries ? 2 : 1);\n    var index = 0;\n    var length, step, iterator, result;\n    if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator\n\n    if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {\n      result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n      if (result === BREAK || result === RETURN) return result;\n    } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {\n      result = call(iterator, f, step.value, entries);\n      if (result === BREAK || result === RETURN) return result;\n    }\n  };\n\n  exports.BREAK = BREAK;\n  exports.RETURN = RETURN;\n  /***/\n},\n/* 184 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = !__webpack_require__(33) && !__webpack_require__(85)(function () {\n    return Object.defineProperty(__webpack_require__(68)('div'), 'a', {\n      get: function () {\n        return 7;\n      }\n    }).a != 7;\n  });\n  /***/\n},\n/* 185 */\n\n/***/\nfunction (module, exports) {\n  // fast apply, http://jsperf.lnkit.com/fast-apply/5\n  module.exports = function (fn, args, that) {\n    var un = that === undefined;\n\n    switch (args.length) {\n      case 0:\n        return un ? fn() : fn.call(that);\n\n      case 1:\n        return un ? fn(args[0]) : fn.call(that, args[0]);\n\n      case 2:\n        return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);\n\n      case 3:\n        return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);\n\n      case 4:\n        return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);\n    }\n\n    return fn.apply(that, args);\n  };\n  /***/\n\n},\n/* 186 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // check on default Array iterator\n  var Iterators = __webpack_require__(35);\n\n  var ITERATOR = __webpack_require__(13)('iterator');\n\n  var ArrayProto = Array.prototype;\n\n  module.exports = function (it) {\n    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n  };\n  /***/\n\n},\n/* 187 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // call something on iterator step with safe closing on error\n  var anObject = __webpack_require__(27);\n\n  module.exports = function (iterator, fn, value, entries) {\n    try {\n      return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)\n    } catch (e) {\n      var ret = iterator['return'];\n      if (ret !== undefined) anObject(ret.call(iterator));\n      throw e;\n    }\n  };\n  /***/\n\n},\n/* 188 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var create = __webpack_require__(192);\n\n  var descriptor = __webpack_require__(106);\n\n  var setToStringTag = __webpack_require__(71);\n\n  var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\n  __webpack_require__(31)(IteratorPrototype, __webpack_require__(13)('iterator'), function () {\n    return this;\n  });\n\n  module.exports = function (Constructor, NAME, next) {\n    Constructor.prototype = create(IteratorPrototype, {\n      next: descriptor(1, next)\n    });\n    setToStringTag(Constructor, NAME + ' Iterator');\n  };\n  /***/\n\n},\n/* 189 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var ITERATOR = __webpack_require__(13)('iterator');\n\n  var SAFE_CLOSING = false;\n\n  try {\n    var riter = [7][ITERATOR]();\n\n    riter['return'] = function () {\n      SAFE_CLOSING = true;\n    }; // eslint-disable-next-line no-throw-literal\n\n\n    Array.from(riter, function () {\n      throw 2;\n    });\n  } catch (e) {\n    /* empty */\n  }\n\n  module.exports = function (exec, skipClosing) {\n    if (!skipClosing && !SAFE_CLOSING) return false;\n    var safe = false;\n\n    try {\n      var arr = [7];\n      var iter = arr[ITERATOR]();\n\n      iter.next = function () {\n        return {\n          done: safe = true\n        };\n      };\n\n      arr[ITERATOR] = function () {\n        return iter;\n      };\n\n      exec(arr);\n    } catch (e) {\n      /* empty */\n    }\n\n    return safe;\n  };\n  /***/\n\n},\n/* 190 */\n\n/***/\nfunction (module, exports) {\n  module.exports = function (done, value) {\n    return {\n      value: value,\n      done: !!done\n    };\n  };\n  /***/\n\n},\n/* 191 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var global = __webpack_require__(11);\n\n  var macrotask = __webpack_require__(109).set;\n\n  var Observer = global.MutationObserver || global.WebKitMutationObserver;\n  var process = global.process;\n  var Promise = global.Promise;\n  var isNode = __webpack_require__(47)(process) == 'process';\n\n  module.exports = function () {\n    var head, last, notify;\n\n    var flush = function () {\n      var parent, fn;\n      if (isNode && (parent = process.domain)) parent.exit();\n\n      while (head) {\n        fn = head.fn;\n        head = head.next;\n\n        try {\n          fn();\n        } catch (e) {\n          if (head) notify();else last = undefined;\n          throw e;\n        }\n      }\n\n      last = undefined;\n      if (parent) parent.enter();\n    }; // Node.js\n\n\n    if (isNode) {\n      notify = function () {\n        process.nextTick(flush);\n      }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339\n\n    } else if (Observer && !(global.navigator && global.navigator.standalone)) {\n      var toggle = true;\n      var node = document.createTextNode('');\n      new Observer(flush).observe(node, {\n        characterData: true\n      }); // eslint-disable-line no-new\n\n      notify = function () {\n        node.data = toggle = !toggle;\n      }; // environments with maybe non-completely correct, but existent Promise\n\n    } else if (Promise && Promise.resolve) {\n      // Promise.resolve without an argument throws an error in LG WebOS 2\n      var promise = Promise.resolve(undefined);\n\n      notify = function () {\n        promise.then(flush);\n      }; // for other environments - macrotask based on:\n      // - setImmediate\n      // - MessageChannel\n      // - window.postMessag\n      // - onreadystatechange\n      // - setTimeout\n\n    } else {\n      notify = function () {\n        // strange IE + webpack dev server bug - use .call(global)\n        macrotask.call(global, flush);\n      };\n    }\n\n    return function (fn) {\n      var task = {\n        fn: fn,\n        next: undefined\n      };\n      if (last) last.next = task;\n\n      if (!head) {\n        head = task;\n        notify();\n      }\n\n      last = task;\n    };\n  };\n  /***/\n\n},\n/* 192 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n  var anObject = __webpack_require__(27);\n\n  var dPs = __webpack_require__(193);\n\n  var enumBugKeys = __webpack_require__(101);\n\n  var IE_PROTO = __webpack_require__(72)('IE_PROTO');\n\n  var Empty = function () {\n    /* empty */\n  };\n\n  var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype\n\n  var createDict = function () {\n    // Thrash, waste and sodomy: IE GC bug\n    var iframe = __webpack_require__(68)('iframe');\n\n    var i = enumBugKeys.length;\n    var lt = '<';\n    var gt = '>';\n    var iframeDocument;\n    iframe.style.display = 'none';\n\n    __webpack_require__(102).appendChild(iframe);\n\n    iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n    // createDict = iframe.contentWindow.Object;\n    // html.removeChild(iframe);\n\n    iframeDocument = iframe.contentWindow.document;\n    iframeDocument.open();\n    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n    iframeDocument.close();\n    createDict = iframeDocument.F;\n\n    while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n\n    return createDict();\n  };\n\n  module.exports = Object.create || function create(O, Properties) {\n    var result;\n\n    if (O !== null) {\n      Empty[PROTOTYPE] = anObject(O);\n      result = new Empty();\n      Empty[PROTOTYPE] = null; // add \"__proto__\" for Object.getPrototypeOf polyfill\n\n      result[IE_PROTO] = O;\n    } else result = createDict();\n\n    return Properties === undefined ? result : dPs(result, Properties);\n  };\n  /***/\n\n},\n/* 193 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var dP = __webpack_require__(50);\n\n  var anObject = __webpack_require__(27);\n\n  var getKeys = __webpack_require__(132);\n\n  module.exports = __webpack_require__(33) ? Object.defineProperties : function defineProperties(O, Properties) {\n    anObject(O);\n    var keys = getKeys(Properties);\n    var length = keys.length;\n    var i = 0;\n    var P;\n\n    while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n\n    return O;\n  };\n  /***/\n},\n/* 194 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n  var has = __webpack_require__(49);\n\n  var toObject = __webpack_require__(133);\n\n  var IE_PROTO = __webpack_require__(72)('IE_PROTO');\n\n  var ObjectProto = Object.prototype;\n\n  module.exports = Object.getPrototypeOf || function (O) {\n    O = toObject(O);\n    if (has(O, IE_PROTO)) return O[IE_PROTO];\n\n    if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n      return O.constructor.prototype;\n    }\n\n    return O instanceof Object ? ObjectProto : null;\n  };\n  /***/\n\n},\n/* 195 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var has = __webpack_require__(49);\n\n  var toIObject = __webpack_require__(74);\n\n  var arrayIndexOf = __webpack_require__(182)(false);\n\n  var IE_PROTO = __webpack_require__(72)('IE_PROTO');\n\n  module.exports = function (object, names) {\n    var O = toIObject(object);\n    var i = 0;\n    var result = [];\n    var key;\n\n    for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key); // Don't enum bug & hidden keys\n\n\n    while (names.length > i) if (has(O, key = names[i++])) {\n      ~arrayIndexOf(result, key) || result.push(key);\n    }\n\n    return result;\n  };\n  /***/\n\n},\n/* 196 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var hide = __webpack_require__(31);\n\n  module.exports = function (target, src, safe) {\n    for (var key in src) {\n      if (safe && target[key]) target[key] = src[key];else hide(target, key, src[key]);\n    }\n\n    return target;\n  };\n  /***/\n\n},\n/* 197 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(31);\n  /***/\n},\n/* 198 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var global = __webpack_require__(11);\n\n  var core = __webpack_require__(23);\n\n  var dP = __webpack_require__(50);\n\n  var DESCRIPTORS = __webpack_require__(33);\n\n  var SPECIES = __webpack_require__(13)('species');\n\n  module.exports = function (KEY) {\n    var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];\n    if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n      configurable: true,\n      get: function () {\n        return this;\n      }\n    });\n  };\n  /***/\n\n},\n/* 199 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var toInteger = __webpack_require__(73);\n\n  var defined = __webpack_require__(67); // true  -> String#at\n  // false -> String#codePointAt\n\n\n  module.exports = function (TO_STRING) {\n    return function (that, pos) {\n      var s = String(defined(that));\n      var i = toInteger(pos);\n      var l = s.length;\n      var a, b;\n      if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n      a = s.charCodeAt(i);\n      return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n    };\n  };\n  /***/\n\n},\n/* 200 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var toInteger = __webpack_require__(73);\n\n  var max = Math.max;\n  var min = Math.min;\n\n  module.exports = function (index, length) {\n    index = toInteger(index);\n    return index < 0 ? max(index + length, 0) : min(index, length);\n  };\n  /***/\n\n},\n/* 201 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // 7.1.1 ToPrimitive(input [, PreferredType])\n  var isObject = __webpack_require__(34); // instead of the ES6 spec version, we didn't implement @@toPrimitive case\n  // and the second argument - flag - preferred type is a string\n\n\n  module.exports = function (it, S) {\n    if (!isObject(it)) return it;\n    var fn, val;\n    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n    throw TypeError(\"Can't convert object to primitive value\");\n  };\n  /***/\n\n},\n/* 202 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var global = __webpack_require__(11);\n\n  var navigator = global.navigator;\n  module.exports = navigator && navigator.userAgent || '';\n  /***/\n},\n/* 203 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var classof = __webpack_require__(100);\n\n  var ITERATOR = __webpack_require__(13)('iterator');\n\n  var Iterators = __webpack_require__(35);\n\n  module.exports = __webpack_require__(23).getIteratorMethod = function (it) {\n    if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];\n  };\n  /***/\n\n},\n/* 204 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var addToUnscopables = __webpack_require__(180);\n\n  var step = __webpack_require__(190);\n\n  var Iterators = __webpack_require__(35);\n\n  var toIObject = __webpack_require__(74); // 22.1.3.4 Array.prototype.entries()\n  // 22.1.3.13 Array.prototype.keys()\n  // 22.1.3.29 Array.prototype.values()\n  // 22.1.3.30 Array.prototype[@@iterator]()\n\n\n  module.exports = __webpack_require__(103)(Array, 'Array', function (iterated, kind) {\n    this._t = toIObject(iterated); // target\n\n    this._i = 0; // next index\n\n    this._k = kind; // kind\n    // 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n  }, function () {\n    var O = this._t;\n    var kind = this._k;\n    var index = this._i++;\n\n    if (!O || index >= O.length) {\n      this._t = undefined;\n      return step(1);\n    }\n\n    if (kind == 'keys') return step(0, index);\n    if (kind == 'values') return step(0, O[index]);\n    return step(0, [index, O[index]]);\n  }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\n  Iterators.Arguments = Iterators.Array;\n  addToUnscopables('keys');\n  addToUnscopables('values');\n  addToUnscopables('entries');\n  /***/\n},\n/* 205 */\n\n/***/\nfunction (module, exports) {\n  /***/\n},\n/* 206 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var LIBRARY = __webpack_require__(69);\n\n  var global = __webpack_require__(11);\n\n  var ctx = __webpack_require__(48);\n\n  var classof = __webpack_require__(100);\n\n  var $export = __webpack_require__(41);\n\n  var isObject = __webpack_require__(34);\n\n  var aFunction = __webpack_require__(46);\n\n  var anInstance = __webpack_require__(181);\n\n  var forOf = __webpack_require__(183);\n\n  var speciesConstructor = __webpack_require__(108);\n\n  var task = __webpack_require__(109).set;\n\n  var microtask = __webpack_require__(191)();\n\n  var newPromiseCapabilityModule = __webpack_require__(70);\n\n  var perform = __webpack_require__(104);\n\n  var userAgent = __webpack_require__(202);\n\n  var promiseResolve = __webpack_require__(105);\n\n  var PROMISE = 'Promise';\n  var TypeError = global.TypeError;\n  var process = global.process;\n  var versions = process && process.versions;\n  var v8 = versions && versions.v8 || '';\n  var $Promise = global[PROMISE];\n  var isNode = classof(process) == 'process';\n\n  var empty = function () {\n    /* empty */\n  };\n\n  var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;\n  var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;\n  var USE_NATIVE = !!function () {\n    try {\n      // correct subclassing with @@species support\n      var promise = $Promise.resolve(1);\n\n      var FakePromise = (promise.constructor = {})[__webpack_require__(13)('species')] = function (exec) {\n        exec(empty, empty);\n      }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n\n\n      return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565\n      // we can't detect it synchronously, so just check versions\n      && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;\n    } catch (e) {\n      /* empty */\n    }\n  }(); // helpers\n\n  var isThenable = function (it) {\n    var then;\n    return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n  };\n\n  var notify = function (promise, isReject) {\n    if (promise._n) return;\n    promise._n = true;\n    var chain = promise._c;\n    microtask(function () {\n      var value = promise._v;\n      var ok = promise._s == 1;\n      var i = 0;\n\n      var run = function (reaction) {\n        var handler = ok ? reaction.ok : reaction.fail;\n        var resolve = reaction.resolve;\n        var reject = reaction.reject;\n        var domain = reaction.domain;\n        var result, then, exited;\n\n        try {\n          if (handler) {\n            if (!ok) {\n              if (promise._h == 2) onHandleUnhandled(promise);\n              promise._h = 1;\n            }\n\n            if (handler === true) result = value;else {\n              if (domain) domain.enter();\n              result = handler(value); // may throw\n\n              if (domain) {\n                domain.exit();\n                exited = true;\n              }\n            }\n\n            if (result === reaction.promise) {\n              reject(TypeError('Promise-chain cycle'));\n            } else if (then = isThenable(result)) {\n              then.call(result, resolve, reject);\n            } else resolve(result);\n          } else reject(value);\n        } catch (e) {\n          if (domain && !exited) domain.exit();\n          reject(e);\n        }\n      };\n\n      while (chain.length > i) run(chain[i++]); // variable length - can't use forEach\n\n\n      promise._c = [];\n      promise._n = false;\n      if (isReject && !promise._h) onUnhandled(promise);\n    });\n  };\n\n  var onUnhandled = function (promise) {\n    task.call(global, function () {\n      var value = promise._v;\n      var unhandled = isUnhandled(promise);\n      var result, handler, console;\n\n      if (unhandled) {\n        result = perform(function () {\n          if (isNode) {\n            process.emit('unhandledRejection', value, promise);\n          } else if (handler = global.onunhandledrejection) {\n            handler({\n              promise: promise,\n              reason: value\n            });\n          } else if ((console = global.console) && console.error) {\n            console.error('Unhandled promise rejection', value);\n          }\n        }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n\n        promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n      }\n\n      promise._a = undefined;\n      if (unhandled && result.e) throw result.v;\n    });\n  };\n\n  var isUnhandled = function (promise) {\n    return promise._h !== 1 && (promise._a || promise._c).length === 0;\n  };\n\n  var onHandleUnhandled = function (promise) {\n    task.call(global, function () {\n      var handler;\n\n      if (isNode) {\n        process.emit('rejectionHandled', promise);\n      } else if (handler = global.onrejectionhandled) {\n        handler({\n          promise: promise,\n          reason: promise._v\n        });\n      }\n    });\n  };\n\n  var $reject = function (value) {\n    var promise = this;\n    if (promise._d) return;\n    promise._d = true;\n    promise = promise._w || promise; // unwrap\n\n    promise._v = value;\n    promise._s = 2;\n    if (!promise._a) promise._a = promise._c.slice();\n    notify(promise, true);\n  };\n\n  var $resolve = function (value) {\n    var promise = this;\n    var then;\n    if (promise._d) return;\n    promise._d = true;\n    promise = promise._w || promise; // unwrap\n\n    try {\n      if (promise === value) throw TypeError(\"Promise can't be resolved itself\");\n\n      if (then = isThenable(value)) {\n        microtask(function () {\n          var wrapper = {\n            _w: promise,\n            _d: false\n          }; // wrap\n\n          try {\n            then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n          } catch (e) {\n            $reject.call(wrapper, e);\n          }\n        });\n      } else {\n        promise._v = value;\n        promise._s = 1;\n        notify(promise, false);\n      }\n    } catch (e) {\n      $reject.call({\n        _w: promise,\n        _d: false\n      }, e); // wrap\n    }\n  }; // constructor polyfill\n\n\n  if (!USE_NATIVE) {\n    // 25.4.3.1 Promise(executor)\n    $Promise = function Promise(executor) {\n      anInstance(this, $Promise, PROMISE, '_h');\n      aFunction(executor);\n      Internal.call(this);\n\n      try {\n        executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n      } catch (err) {\n        $reject.call(this, err);\n      }\n    }; // eslint-disable-next-line no-unused-vars\n\n\n    Internal = function Promise(executor) {\n      this._c = []; // <- awaiting reactions\n\n      this._a = undefined; // <- checked in isUnhandled reactions\n\n      this._s = 0; // <- state\n\n      this._d = false; // <- done\n\n      this._v = undefined; // <- value\n\n      this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n\n      this._n = false; // <- notify\n    };\n\n    Internal.prototype = __webpack_require__(196)($Promise.prototype, {\n      // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n      then: function then(onFulfilled, onRejected) {\n        var reaction = newPromiseCapability(speciesConstructor(this, $Promise));\n        reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n        reaction.fail = typeof onRejected == 'function' && onRejected;\n        reaction.domain = isNode ? process.domain : undefined;\n\n        this._c.push(reaction);\n\n        if (this._a) this._a.push(reaction);\n        if (this._s) notify(this, false);\n        return reaction.promise;\n      },\n      // 25.4.5.1 Promise.prototype.catch(onRejected)\n      'catch': function (onRejected) {\n        return this.then(undefined, onRejected);\n      }\n    });\n\n    OwnPromiseCapability = function () {\n      var promise = new Internal();\n      this.promise = promise;\n      this.resolve = ctx($resolve, promise, 1);\n      this.reject = ctx($reject, promise, 1);\n    };\n\n    newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n      return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n    };\n  }\n\n  $export($export.G + $export.W + $export.F * !USE_NATIVE, {\n    Promise: $Promise\n  });\n\n  __webpack_require__(71)($Promise, PROMISE);\n\n  __webpack_require__(198)(PROMISE);\n\n  Wrapper = __webpack_require__(23)[PROMISE]; // statics\n\n  $export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n    // 25.4.4.5 Promise.reject(r)\n    reject: function reject(r) {\n      var capability = newPromiseCapability(this);\n      var $$reject = capability.reject;\n      $$reject(r);\n      return capability.promise;\n    }\n  });\n  $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n    // 25.4.4.6 Promise.resolve(x)\n    resolve: function resolve(x) {\n      return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);\n    }\n  });\n  $export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(189)(function (iter) {\n    $Promise.all(iter)['catch'](empty);\n  })), PROMISE, {\n    // 25.4.4.1 Promise.all(iterable)\n    all: function all(iterable) {\n      var C = this;\n      var capability = newPromiseCapability(C);\n      var resolve = capability.resolve;\n      var reject = capability.reject;\n      var result = perform(function () {\n        var values = [];\n        var index = 0;\n        var remaining = 1;\n        forOf(iterable, false, function (promise) {\n          var $index = index++;\n          var alreadyCalled = false;\n          values.push(undefined);\n          remaining++;\n          C.resolve(promise).then(function (value) {\n            if (alreadyCalled) return;\n            alreadyCalled = true;\n            values[$index] = value;\n            --remaining || resolve(values);\n          }, reject);\n        });\n        --remaining || resolve(values);\n      });\n      if (result.e) reject(result.v);\n      return capability.promise;\n    },\n    // 25.4.4.4 Promise.race(iterable)\n    race: function race(iterable) {\n      var C = this;\n      var capability = newPromiseCapability(C);\n      var reject = capability.reject;\n      var result = perform(function () {\n        forOf(iterable, false, function (promise) {\n          C.resolve(promise).then(capability.resolve, reject);\n        });\n      });\n      if (result.e) reject(result.v);\n      return capability.promise;\n    }\n  });\n  /***/\n},\n/* 207 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var $at = __webpack_require__(199)(true); // 21.1.3.27 String.prototype[@@iterator]()\n\n\n  __webpack_require__(103)(String, 'String', function (iterated) {\n    this._t = String(iterated); // target\n\n    this._i = 0; // next index\n    // 21.1.5.2.1 %StringIteratorPrototype%.next()\n  }, function () {\n    var O = this._t;\n    var index = this._i;\n    var point;\n    if (index >= O.length) return {\n      value: undefined,\n      done: true\n    };\n    point = $at(O, index);\n    this._i += point.length;\n    return {\n      value: point,\n      done: false\n    };\n  });\n  /***/\n\n},\n/* 208 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // https://github.com/tc39/proposal-promise-finally\n\n  var $export = __webpack_require__(41);\n\n  var core = __webpack_require__(23);\n\n  var global = __webpack_require__(11);\n\n  var speciesConstructor = __webpack_require__(108);\n\n  var promiseResolve = __webpack_require__(105);\n\n  $export($export.P + $export.R, 'Promise', {\n    'finally': function (onFinally) {\n      var C = speciesConstructor(this, core.Promise || global.Promise);\n      var isFunction = typeof onFinally == 'function';\n      return this.then(isFunction ? function (x) {\n        return promiseResolve(C, onFinally()).then(function () {\n          return x;\n        });\n      } : onFinally, isFunction ? function (e) {\n        return promiseResolve(C, onFinally()).then(function () {\n          throw e;\n        });\n      } : onFinally);\n    }\n  });\n  /***/\n},\n/* 209 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\"; // https://github.com/tc39/proposal-promise-try\n\n  var $export = __webpack_require__(41);\n\n  var newPromiseCapability = __webpack_require__(70);\n\n  var perform = __webpack_require__(104);\n\n  $export($export.S, 'Promise', {\n    'try': function (callbackfn) {\n      var promiseCapability = newPromiseCapability.f(this);\n      var result = perform(callbackfn);\n      (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);\n      return promiseCapability.promise;\n    }\n  });\n  /***/\n},\n/* 210 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  __webpack_require__(204);\n\n  var global = __webpack_require__(11);\n\n  var hide = __webpack_require__(31);\n\n  var Iterators = __webpack_require__(35);\n\n  var TO_STRING_TAG = __webpack_require__(13)('toStringTag');\n\n  var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' + 'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' + 'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' + 'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' + 'TextTrackList,TouchList').split(',');\n\n  for (var i = 0; i < DOMIterables.length; i++) {\n    var NAME = DOMIterables[i];\n    var Collection = global[NAME];\n    var proto = Collection && Collection.prototype;\n    if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = Iterators.Array;\n  }\n  /***/\n\n},\n/* 211 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /**\n   * This is the web browser implementation of `debug()`.\n   *\n   * Expose `debug()` as the module.\n   */\n  exports = module.exports = __webpack_require__(112);\n  exports.log = log;\n  exports.formatArgs = formatArgs;\n  exports.save = save;\n  exports.load = load;\n  exports.useColors = useColors;\n  exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();\n  /**\n   * Colors.\n   */\n\n  exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];\n  /**\n   * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n   * and the Firebug extension (any Firefox version) are known\n   * to support \"%c\" CSS customizations.\n   *\n   * TODO: add a `localStorage` variable to explicitly enable/disable colors\n   */\n\n  function useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n      return true;\n    } // Internet Explorer and Edge do not support colors.\n\n\n    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n      return false;\n    } // is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\n\n    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773\n    typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n  }\n  /**\n   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n   */\n\n\n  exports.formatters.j = function (v) {\n    try {\n      return JSON.stringify(v);\n    } catch (err) {\n      return '[UnexpectedJSONParseError]: ' + err.message;\n    }\n  };\n  /**\n   * Colorize log arguments if enabled.\n   *\n   * @api public\n   */\n\n\n  function formatArgs(args) {\n    var useColors = this.useColors;\n    args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);\n    if (!useColors) return;\n    var c = 'color: ' + this.color;\n    args.splice(1, 0, c, 'color: inherit'); // the final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n\n    var index = 0;\n    var lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, function (match) {\n      if ('%%' === match) return;\n      index++;\n\n      if ('%c' === match) {\n        // we only are interested in the *last* %c\n        // (the user may have provided their own)\n        lastC = index;\n      }\n    });\n    args.splice(lastC, 0, c);\n  }\n  /**\n   * Invokes `console.log()` when available.\n   * No-op when `console.log` is not a \"function\".\n   *\n   * @api public\n   */\n\n\n  function log() {\n    // this hackery is required for IE8/9, where\n    // the `console.log` function doesn't have 'apply'\n    return 'object' === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);\n  }\n  /**\n   * Save `namespaces`.\n   *\n   * @param {String} namespaces\n   * @api private\n   */\n\n\n  function save(namespaces) {\n    try {\n      if (null == namespaces) {\n        exports.storage.removeItem('debug');\n      } else {\n        exports.storage.debug = namespaces;\n      }\n    } catch (e) {}\n  }\n  /**\n   * Load `namespaces`.\n   *\n   * @return {String} returns the previously persisted debug modes\n   * @api private\n   */\n\n\n  function load() {\n    var r;\n\n    try {\n      r = exports.storage.debug;\n    } catch (e) {} // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\n\n    if (!r && typeof process !== 'undefined' && 'env' in process) {\n      r = process.env.DEBUG;\n    }\n\n    return r;\n  }\n  /**\n   * Enable namespaces listed in `localStorage.debug` initially.\n   */\n\n\n  exports.enable(load());\n  /**\n   * Localstorage attempts to return the localstorage.\n   *\n   * This is necessary because safari throws\n   * when a user disables cookies/localstorage\n   * and you attempt to access it.\n   *\n   * @return {LocalStorage}\n   * @api private\n   */\n\n  function localstorage() {\n    try {\n      return window.localStorage;\n    } catch (e) {}\n  }\n  /***/\n\n},\n/* 212 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /**\n   * Detect Electron renderer process, which is node, but we should\n   * treat as a browser.\n   */\n  if (typeof process === 'undefined' || process.type === 'renderer') {\n    module.exports = __webpack_require__(211);\n  } else {\n    module.exports = __webpack_require__(213);\n  }\n  /***/\n\n},\n/* 213 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  /**\n   * Module dependencies.\n   */\n  var tty = __webpack_require__(79);\n\n  var util = __webpack_require__(2);\n  /**\n   * This is the Node.js implementation of `debug()`.\n   *\n   * Expose `debug()` as the module.\n   */\n\n\n  exports = module.exports = __webpack_require__(112);\n  exports.init = init;\n  exports.log = log;\n  exports.formatArgs = formatArgs;\n  exports.save = save;\n  exports.load = load;\n  exports.useColors = useColors;\n  /**\n   * Colors.\n   */\n\n  exports.colors = [6, 2, 3, 4, 5, 1];\n\n  try {\n    var supportsColor = __webpack_require__(239);\n\n    if (supportsColor && supportsColor.level >= 2) {\n      exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];\n    }\n  } catch (err) {// swallow - we only care if `supports-color` is available; it doesn't have to be.\n  }\n  /**\n   * Build up the default `inspectOpts` object from the environment variables.\n   *\n   *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n   */\n\n\n  exports.inspectOpts = Object.keys(process.env).filter(function (key) {\n    return /^debug_/i.test(key);\n  }).reduce(function (obj, key) {\n    // camel-case\n    var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {\n      return k.toUpperCase();\n    }); // coerce string value into JS value\n\n    var val = process.env[key];\n    if (/^(yes|on|true|enabled)$/i.test(val)) val = true;else if (/^(no|off|false|disabled)$/i.test(val)) val = false;else if (val === 'null') val = null;else val = Number(val);\n    obj[prop] = val;\n    return obj;\n  }, {});\n  /**\n   * Is stdout a TTY? Colored output is enabled when `true`.\n   */\n\n  function useColors() {\n    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);\n  }\n  /**\n   * Map %o to `util.inspect()`, all on a single line.\n   */\n\n\n  exports.formatters.o = function (v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts).split('\\n').map(function (str) {\n      return str.trim();\n    }).join(' ');\n  };\n  /**\n   * Map %o to `util.inspect()`, allowing multiple lines if needed.\n   */\n\n\n  exports.formatters.O = function (v) {\n    this.inspectOpts.colors = this.useColors;\n    return util.inspect(v, this.inspectOpts);\n  };\n  /**\n   * Adds ANSI color escape codes if enabled.\n   *\n   * @api public\n   */\n\n\n  function formatArgs(args) {\n    var name = this.namespace;\n    var useColors = this.useColors;\n\n    if (useColors) {\n      var c = this.color;\n      var colorCode = '\\u001b[3' + (c < 8 ? c : '8;5;' + c);\n      var prefix = '  ' + colorCode + ';1m' + name + ' ' + '\\u001b[0m';\n      args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n      args.push(colorCode + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n    } else {\n      args[0] = getDate() + name + ' ' + args[0];\n    }\n  }\n\n  function getDate() {\n    if (exports.inspectOpts.hideDate) {\n      return '';\n    } else {\n      return new Date().toISOString() + ' ';\n    }\n  }\n  /**\n   * Invokes `util.format()` with the specified arguments and writes to stderr.\n   */\n\n\n  function log() {\n    return process.stderr.write(util.format.apply(util, arguments) + '\\n');\n  }\n  /**\n   * Save `namespaces`.\n   *\n   * @param {String} namespaces\n   * @api private\n   */\n\n\n  function save(namespaces) {\n    if (null == namespaces) {\n      // If you set a process.env field to null or undefined, it gets cast to the\n      // string 'null' or 'undefined'. Just delete instead.\n      delete process.env.DEBUG;\n    } else {\n      process.env.DEBUG = namespaces;\n    }\n  }\n  /**\n   * Load `namespaces`.\n   *\n   * @return {String} returns the previously persisted debug modes\n   * @api private\n   */\n\n\n  function load() {\n    return process.env.DEBUG;\n  }\n  /**\n   * Init logic for `debug` instances.\n   *\n   * Create a new `inspectOpts` object in case `useColors` is set\n   * differently for a particular `debug` instance.\n   */\n\n\n  function init(debug) {\n    debug.inspectOpts = {};\n    var keys = Object.keys(exports.inspectOpts);\n\n    for (var i = 0; i < keys.length; i++) {\n      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n    }\n  }\n  /**\n   * Enable namespaces listed in `process.env.DEBUG` initially.\n   */\n\n\n  exports.enable(load());\n  /***/\n},,,,\n/* 217 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // Copyright Joyent, Inc. and other Node contributors.\n  //\n  // Permission is hereby granted, free of charge, to any person obtaining a\n  // copy of this software and associated documentation files (the\n  // \"Software\"), to deal in the Software without restriction, including\n  // without limitation the rights to use, copy, modify, merge, publish,\n  // distribute, sublicense, and/or sell copies of the Software, and to permit\n  // persons to whom the Software is furnished to do so, subject to the\n  // following conditions:\n  //\n  // The above copyright notice and this permission notice shall be included\n  // in all copies or substantial portions of the Software.\n  //\n  // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n  // USE OR OTHER DEALINGS IN THE SOFTWARE.\n  var pathModule = __webpack_require__(0);\n\n  var isWindows = process.platform === 'win32';\n\n  var fs = __webpack_require__(3); // JavaScript implementation of realpath, ported from node pre-v6\n\n\n  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);\n\n  function rethrow() {\n    // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and\n    // is fairly slow to generate.\n    var callback;\n\n    if (DEBUG) {\n      var backtrace = new Error();\n      callback = debugCallback;\n    } else callback = missingCallback;\n\n    return callback;\n\n    function debugCallback(err) {\n      if (err) {\n        backtrace.message = err.message;\n        err = backtrace;\n        missingCallback(err);\n      }\n    }\n\n    function missingCallback(err) {\n      if (err) {\n        if (process.throwDeprecation) throw err; // Forgot a callback but don't know where? Use NODE_DEBUG=fs\n        else if (!process.noDeprecation) {\n          var msg = 'fs: missing callback ' + (err.stack || err.message);\n          if (process.traceDeprecation) console.trace(msg);else console.error(msg);\n        }\n      }\n    }\n  }\n\n  function maybeCallback(cb) {\n    return typeof cb === 'function' ? cb : rethrow();\n  }\n\n  var normalize = pathModule.normalize; // Regexp that finds the next partion of a (partial) path\n  // result is [base_with_slash, base], e.g. ['somedir/', 'somedir']\n\n  if (isWindows) {\n    var nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;\n  } else {\n    var nextPartRe = /(.*?)(?:[\\/]+|$)/g;\n  } // Regex to find the device root, including trailing slash. E.g. 'c:\\\\'.\n\n\n  if (isWindows) {\n    var splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;\n  } else {\n    var splitRootRe = /^[\\/]*/;\n  }\n\n  exports.realpathSync = function realpathSync(p, cache) {\n    // make p is absolute\n    p = pathModule.resolve(p);\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n      return cache[p];\n    }\n\n    var original = p,\n        seenLinks = {},\n        knownHard = {}; // current character position in p\n\n    var pos; // the partial path so far, including a trailing slash if any\n\n    var current; // the partial path without a trailing slash (except when pointing at a root)\n\n    var base; // the partial path scanned in the previous round, with slash\n\n    var previous;\n    start();\n\n    function start() {\n      // Skip over roots\n      var m = splitRootRe.exec(p);\n      pos = m[0].length;\n      current = m[0];\n      base = m[0];\n      previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n      if (isWindows && !knownHard[base]) {\n        fs.lstatSync(base);\n        knownHard[base] = true;\n      }\n    } // walk down the path, swapping out linked pathparts for their real\n    // values\n    // NB: p.length changes.\n\n\n    while (pos < p.length) {\n      // find the next part\n      nextPartRe.lastIndex = pos;\n      var result = nextPartRe.exec(p);\n      previous = current;\n      current += result[0];\n      base = previous + result[1];\n      pos = nextPartRe.lastIndex; // continue if not a symlink\n\n      if (knownHard[base] || cache && cache[base] === base) {\n        continue;\n      }\n\n      var resolvedLink;\n\n      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n        // some known symbolic link.  no need to stat again.\n        resolvedLink = cache[base];\n      } else {\n        var stat = fs.lstatSync(base);\n\n        if (!stat.isSymbolicLink()) {\n          knownHard[base] = true;\n          if (cache) cache[base] = base;\n          continue;\n        } // read the link if it wasn't read before\n        // dev/ino always return 0 on windows, so skip the check.\n\n\n        var linkTarget = null;\n\n        if (!isWindows) {\n          var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n          if (seenLinks.hasOwnProperty(id)) {\n            linkTarget = seenLinks[id];\n          }\n        }\n\n        if (linkTarget === null) {\n          fs.statSync(base);\n          linkTarget = fs.readlinkSync(base);\n        }\n\n        resolvedLink = pathModule.resolve(previous, linkTarget); // track this, if given a cache.\n\n        if (cache) cache[base] = resolvedLink;\n        if (!isWindows) seenLinks[id] = linkTarget;\n      } // resolve the link, then start over\n\n\n      p = pathModule.resolve(resolvedLink, p.slice(pos));\n      start();\n    }\n\n    if (cache) cache[original] = p;\n    return p;\n  };\n\n  exports.realpath = function realpath(p, cache, cb) {\n    if (typeof cb !== 'function') {\n      cb = maybeCallback(cache);\n      cache = null;\n    } // make p is absolute\n\n\n    p = pathModule.resolve(p);\n\n    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {\n      return process.nextTick(cb.bind(null, null, cache[p]));\n    }\n\n    var original = p,\n        seenLinks = {},\n        knownHard = {}; // current character position in p\n\n    var pos; // the partial path so far, including a trailing slash if any\n\n    var current; // the partial path without a trailing slash (except when pointing at a root)\n\n    var base; // the partial path scanned in the previous round, with slash\n\n    var previous;\n    start();\n\n    function start() {\n      // Skip over roots\n      var m = splitRootRe.exec(p);\n      pos = m[0].length;\n      current = m[0];\n      base = m[0];\n      previous = ''; // On windows, check that the root exists. On unix there is no need.\n\n      if (isWindows && !knownHard[base]) {\n        fs.lstat(base, function (err) {\n          if (err) return cb(err);\n          knownHard[base] = true;\n          LOOP();\n        });\n      } else {\n        process.nextTick(LOOP);\n      }\n    } // walk down the path, swapping out linked pathparts for their real\n    // values\n\n\n    function LOOP() {\n      // stop if scanned past end of path\n      if (pos >= p.length) {\n        if (cache) cache[original] = p;\n        return cb(null, p);\n      } // find the next part\n\n\n      nextPartRe.lastIndex = pos;\n      var result = nextPartRe.exec(p);\n      previous = current;\n      current += result[0];\n      base = previous + result[1];\n      pos = nextPartRe.lastIndex; // continue if not a symlink\n\n      if (knownHard[base] || cache && cache[base] === base) {\n        return process.nextTick(LOOP);\n      }\n\n      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {\n        // known symbolic link.  no need to stat again.\n        return gotResolvedLink(cache[base]);\n      }\n\n      return fs.lstat(base, gotStat);\n    }\n\n    function gotStat(err, stat) {\n      if (err) return cb(err); // if not a symlink, skip to the next path part\n\n      if (!stat.isSymbolicLink()) {\n        knownHard[base] = true;\n        if (cache) cache[base] = base;\n        return process.nextTick(LOOP);\n      } // stat & read the link if not read before\n      // call gotTarget as soon as the link target is known\n      // dev/ino always return 0 on windows, so skip the check.\n\n\n      if (!isWindows) {\n        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);\n\n        if (seenLinks.hasOwnProperty(id)) {\n          return gotTarget(null, seenLinks[id], base);\n        }\n      }\n\n      fs.stat(base, function (err) {\n        if (err) return cb(err);\n        fs.readlink(base, function (err, target) {\n          if (!isWindows) seenLinks[id] = target;\n          gotTarget(err, target);\n        });\n      });\n    }\n\n    function gotTarget(err, target, base) {\n      if (err) return cb(err);\n      var resolvedLink = pathModule.resolve(previous, target);\n      if (cache) cache[base] = resolvedLink;\n      gotResolvedLink(resolvedLink);\n    }\n\n    function gotResolvedLink(resolvedLink) {\n      // resolve the link, then start over\n      p = pathModule.resolve(resolvedLink, p.slice(pos));\n      start();\n    }\n  };\n  /***/\n\n},\n/* 218 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = globSync;\n  globSync.GlobSync = GlobSync;\n\n  var fs = __webpack_require__(3);\n\n  var rp = __webpack_require__(114);\n\n  var minimatch = __webpack_require__(60);\n\n  var Minimatch = minimatch.Minimatch;\n\n  var Glob = __webpack_require__(75).Glob;\n\n  var util = __webpack_require__(2);\n\n  var path = __webpack_require__(0);\n\n  var assert = __webpack_require__(22);\n\n  var isAbsolute = __webpack_require__(76);\n\n  var common = __webpack_require__(115);\n\n  var alphasort = common.alphasort;\n  var alphasorti = common.alphasorti;\n  var setopts = common.setopts;\n  var ownProp = common.ownProp;\n  var childrenIgnored = common.childrenIgnored;\n  var isIgnored = common.isIgnored;\n\n  function globSync(pattern, options) {\n    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n    return new GlobSync(pattern, options).found;\n  }\n\n  function GlobSync(pattern, options) {\n    if (!pattern) throw new Error('must provide pattern');\n    if (typeof options === 'function' || arguments.length === 3) throw new TypeError('callback provided to sync glob\\n' + 'See: https://github.com/isaacs/node-glob/issues/167');\n    if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);\n    setopts(this, pattern, options);\n    if (this.noprocess) return this;\n    var n = this.minimatch.set.length;\n    this.matches = new Array(n);\n\n    for (var i = 0; i < n; i++) {\n      this._process(this.minimatch.set[i], i, false);\n    }\n\n    this._finish();\n  }\n\n  GlobSync.prototype._finish = function () {\n    assert(this instanceof GlobSync);\n\n    if (this.realpath) {\n      var self = this;\n      this.matches.forEach(function (matchset, index) {\n        var set = self.matches[index] = Object.create(null);\n\n        for (var p in matchset) {\n          try {\n            p = self._makeAbs(p);\n            var real = rp.realpathSync(p, self.realpathCache);\n            set[real] = true;\n          } catch (er) {\n            if (er.syscall === 'stat') set[self._makeAbs(p)] = true;else throw er;\n          }\n        }\n      });\n    }\n\n    common.finish(this);\n  };\n\n  GlobSync.prototype._process = function (pattern, index, inGlobStar) {\n    assert(this instanceof GlobSync); // Get the first [n] parts of pattern that are all strings.\n\n    var n = 0;\n\n    while (typeof pattern[n] === 'string') {\n      n++;\n    } // now n is the index of the first one that is *not* a string.\n    // See if there's anything else\n\n\n    var prefix;\n\n    switch (n) {\n      // if not, then this is rather simple\n      case pattern.length:\n        this._processSimple(pattern.join('/'), index);\n\n        return;\n\n      case 0:\n        // pattern *starts* with some non-trivial item.\n        // going to readdir(cwd), but not include the prefix in matches.\n        prefix = null;\n        break;\n\n      default:\n        // pattern has some string bits in the front.\n        // whatever it starts with, whether that's 'absolute' like /foo/bar,\n        // or 'relative' like '../baz'\n        prefix = pattern.slice(0, n).join('/');\n        break;\n    }\n\n    var remain = pattern.slice(n); // get the list of entries.\n\n    var read;\n    if (prefix === null) read = '.';else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {\n      if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;\n      read = prefix;\n    } else read = prefix;\n\n    var abs = this._makeAbs(read); //if ignored, skip processing\n\n\n    if (childrenIgnored(this, read)) return;\n    var isGlobStar = remain[0] === minimatch.GLOBSTAR;\n    if (isGlobStar) this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);else this._processReaddir(prefix, read, abs, remain, index, inGlobStar);\n  };\n\n  GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar); // if the abs isn't a dir, then nothing can match!\n\n\n    if (!entries) return; // It will only match dot entries if it starts with a dot, or if\n    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.\n\n    var pn = remain[0];\n    var negate = !!this.minimatch.negate;\n    var rawGlob = pn._glob;\n    var dotOk = this.dot || rawGlob.charAt(0) === '.';\n    var matchedEntries = [];\n\n    for (var i = 0; i < entries.length; i++) {\n      var e = entries[i];\n\n      if (e.charAt(0) !== '.' || dotOk) {\n        var m;\n\n        if (negate && !prefix) {\n          m = !e.match(pn);\n        } else {\n          m = e.match(pn);\n        }\n\n        if (m) matchedEntries.push(e);\n      }\n    }\n\n    var len = matchedEntries.length; // If there are no matched entries, then nothing matches.\n\n    if (len === 0) return; // if this is the last remaining pattern bit, then no need for\n    // an additional stat *unless* the user has specified mark or\n    // stat explicitly.  We know they exist, since readdir returned\n    // them.\n\n    if (remain.length === 1 && !this.mark && !this.stat) {\n      if (!this.matches[index]) this.matches[index] = Object.create(null);\n\n      for (var i = 0; i < len; i++) {\n        var e = matchedEntries[i];\n\n        if (prefix) {\n          if (prefix.slice(-1) !== '/') e = prefix + '/' + e;else e = prefix + e;\n        }\n\n        if (e.charAt(0) === '/' && !this.nomount) {\n          e = path.join(this.root, e);\n        }\n\n        this._emitMatch(index, e);\n      } // This was the last one, and no stats were needed\n\n\n      return;\n    } // now test all matched entries as stand-ins for that part\n    // of the pattern.\n\n\n    remain.shift();\n\n    for (var i = 0; i < len; i++) {\n      var e = matchedEntries[i];\n      var newPattern;\n      if (prefix) newPattern = [prefix, e];else newPattern = [e];\n\n      this._process(newPattern.concat(remain), index, inGlobStar);\n    }\n  };\n\n  GlobSync.prototype._emitMatch = function (index, e) {\n    if (isIgnored(this, e)) return;\n\n    var abs = this._makeAbs(e);\n\n    if (this.mark) e = this._mark(e);\n\n    if (this.absolute) {\n      e = abs;\n    }\n\n    if (this.matches[index][e]) return;\n\n    if (this.nodir) {\n      var c = this.cache[abs];\n      if (c === 'DIR' || Array.isArray(c)) return;\n    }\n\n    this.matches[index][e] = true;\n    if (this.stat) this._stat(e);\n  };\n\n  GlobSync.prototype._readdirInGlobStar = function (abs) {\n    // follow all symlinked directories forever\n    // just proceed as if this is a non-globstar situation\n    if (this.follow) return this._readdir(abs, false);\n    var entries;\n    var lstat;\n    var stat;\n\n    try {\n      lstat = fs.lstatSync(abs);\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        // lstat failed, doesn't exist\n        return null;\n      }\n    }\n\n    var isSym = lstat && lstat.isSymbolicLink();\n    this.symlinks[abs] = isSym; // If it's not a symlink or a dir, then it's definitely a regular file.\n    // don't bother doing a readdir in that case.\n\n    if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';else entries = this._readdir(abs, false);\n    return entries;\n  };\n\n  GlobSync.prototype._readdir = function (abs, inGlobStar) {\n    var entries;\n    if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);\n\n    if (ownProp(this.cache, abs)) {\n      var c = this.cache[abs];\n      if (!c || c === 'FILE') return null;\n      if (Array.isArray(c)) return c;\n    }\n\n    try {\n      return this._readdirEntries(abs, fs.readdirSync(abs));\n    } catch (er) {\n      this._readdirError(abs, er);\n\n      return null;\n    }\n  };\n\n  GlobSync.prototype._readdirEntries = function (abs, entries) {\n    // if we haven't asked to stat everything, then just\n    // assume that everything in there exists, so we can avoid\n    // having to stat it a second time.\n    if (!this.mark && !this.stat) {\n      for (var i = 0; i < entries.length; i++) {\n        var e = entries[i];\n        if (abs === '/') e = abs + e;else e = abs + '/' + e;\n        this.cache[e] = true;\n      }\n    }\n\n    this.cache[abs] = entries; // mark and cache dir-ness\n\n    return entries;\n  };\n\n  GlobSync.prototype._readdirError = function (f, er) {\n    // handle errors, and cache the information\n    switch (er.code) {\n      case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205\n\n      case 'ENOTDIR':\n        // totally normal. means it *does* exist.\n        var abs = this._makeAbs(f);\n\n        this.cache[abs] = 'FILE';\n\n        if (abs === this.cwdAbs) {\n          var error = new Error(er.code + ' invalid cwd ' + this.cwd);\n          error.path = this.cwd;\n          error.code = er.code;\n          throw error;\n        }\n\n        break;\n\n      case 'ENOENT': // not terribly unusual\n\n      case 'ELOOP':\n      case 'ENAMETOOLONG':\n      case 'UNKNOWN':\n        this.cache[this._makeAbs(f)] = false;\n        break;\n\n      default:\n        // some unusual error.  Treat as failure.\n        this.cache[this._makeAbs(f)] = false;\n        if (this.strict) throw er;\n        if (!this.silent) console.error('glob error', er);\n        break;\n    }\n  };\n\n  GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {\n    var entries = this._readdir(abs, inGlobStar); // no entries means not a dir, so it can never have matches\n    // foo.txt/** doesn't match foo.txt\n\n\n    if (!entries) return; // test without the globstar, and with every child both below\n    // and replacing the globstar.\n\n    var remainWithoutGlobStar = remain.slice(1);\n    var gspref = prefix ? [prefix] : [];\n    var noGlobStar = gspref.concat(remainWithoutGlobStar); // the noGlobStar pattern exits the inGlobStar state\n\n    this._process(noGlobStar, index, false);\n\n    var len = entries.length;\n    var isSym = this.symlinks[abs]; // If it's a symlink, and we're in a globstar, then stop\n\n    if (isSym && inGlobStar) return;\n\n    for (var i = 0; i < len; i++) {\n      var e = entries[i];\n      if (e.charAt(0) === '.' && !this.dot) continue; // these two cases enter the inGlobStar state\n\n      var instead = gspref.concat(entries[i], remainWithoutGlobStar);\n\n      this._process(instead, index, true);\n\n      var below = gspref.concat(entries[i], remain);\n\n      this._process(below, index, true);\n    }\n  };\n\n  GlobSync.prototype._processSimple = function (prefix, index) {\n    // XXX review this.  Shouldn't it be doing the mounting etc\n    // before doing stat?  kinda weird?\n    var exists = this._stat(prefix);\n\n    if (!this.matches[index]) this.matches[index] = Object.create(null); // If it doesn't exist, then just mark the lack of results\n\n    if (!exists) return;\n\n    if (prefix && isAbsolute(prefix) && !this.nomount) {\n      var trail = /[\\/\\\\]$/.test(prefix);\n\n      if (prefix.charAt(0) === '/') {\n        prefix = path.join(this.root, prefix);\n      } else {\n        prefix = path.resolve(this.root, prefix);\n        if (trail) prefix += '/';\n      }\n    }\n\n    if (process.platform === 'win32') prefix = prefix.replace(/\\\\/g, '/'); // Mark this as a match\n\n    this._emitMatch(index, prefix);\n  }; // Returns either 'DIR', 'FILE', or false\n\n\n  GlobSync.prototype._stat = function (f) {\n    var abs = this._makeAbs(f);\n\n    var needDir = f.slice(-1) === '/';\n    if (f.length > this.maxLength) return false;\n\n    if (!this.stat && ownProp(this.cache, abs)) {\n      var c = this.cache[abs];\n      if (Array.isArray(c)) c = 'DIR'; // It exists, but maybe not how we need it\n\n      if (!needDir || c === 'DIR') return c;\n      if (needDir && c === 'FILE') return false; // otherwise we have to stat, because maybe c=true\n      // if we know it exists, but not what it is.\n    }\n\n    var exists;\n    var stat = this.statCache[abs];\n\n    if (!stat) {\n      var lstat;\n\n      try {\n        lstat = fs.lstatSync(abs);\n      } catch (er) {\n        if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {\n          this.statCache[abs] = false;\n          return false;\n        }\n      }\n\n      if (lstat && lstat.isSymbolicLink()) {\n        try {\n          stat = fs.statSync(abs);\n        } catch (er) {\n          stat = lstat;\n        }\n      } else {\n        stat = lstat;\n      }\n    }\n\n    this.statCache[abs] = stat;\n    var c = true;\n    if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';\n    this.cache[abs] = this.cache[abs] || c;\n    if (needDir && c === 'FILE') return false;\n    return c;\n  };\n\n  GlobSync.prototype._mark = function (p) {\n    return common.mark(this, p);\n  };\n\n  GlobSync.prototype._makeAbs = function (f) {\n    return common.makeAbs(this, f);\n  };\n  /***/\n\n},,,\n/* 221 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  module.exports = function (flag, argv) {\n    argv = argv || process.argv;\n    var terminatorPos = argv.indexOf('--');\n    var prefix = /^--/.test(flag) ? '' : '--';\n    var pos = argv.indexOf(prefix + flag);\n    return pos !== -1 && (terminatorPos !== -1 ? pos < terminatorPos : true);\n  };\n  /***/\n\n},,\n/* 223 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  var wrappy = __webpack_require__(123);\n\n  var reqs = Object.create(null);\n\n  var once = __webpack_require__(61);\n\n  module.exports = wrappy(inflight);\n\n  function inflight(key, cb) {\n    if (reqs[key]) {\n      reqs[key].push(cb);\n      return null;\n    } else {\n      reqs[key] = [cb];\n      return makeres(key);\n    }\n  }\n\n  function makeres(key) {\n    return once(function RES() {\n      var cbs = reqs[key];\n      var len = cbs.length;\n      var args = slice(arguments); // XXX It's somewhat ambiguous whether a new callback added in this\n      // pass should be queued for later execution if something in the\n      // list of callbacks throws, or if it should just be discarded.\n      // However, it's such an edge case that it hardly matters, and either\n      // choice is likely as surprising as the other.\n      // As it happens, we do go ahead and schedule it for later execution.\n\n      try {\n        for (var i = 0; i < len; i++) {\n          cbs[i].apply(null, args);\n        }\n      } finally {\n        if (cbs.length > len) {\n          // added more in the interim.\n          // de-zalgo, just in case, but don't call again.\n          cbs.splice(0, len);\n          process.nextTick(function () {\n            RES.apply(null, args);\n          });\n        } else {\n          delete reqs[key];\n        }\n      }\n    });\n  }\n\n  function slice(args) {\n    var length = args.length;\n    var array = [];\n\n    for (var i = 0; i < length; i++) array[i] = args[i];\n\n    return array;\n  }\n  /***/\n\n},\n/* 224 */\n\n/***/\nfunction (module, exports) {\n  if (typeof Object.create === 'function') {\n    // implementation from standard node.js 'util' module\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    };\n  } else {\n    // old school shim for old browsers\n    module.exports = function inherits(ctor, superCtor) {\n      ctor.super_ = superCtor;\n\n      var TempCtor = function () {};\n\n      TempCtor.prototype = superCtor.prototype;\n      ctor.prototype = new TempCtor();\n      ctor.prototype.constructor = ctor;\n    };\n  }\n  /***/\n\n},,,\n/* 227 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  // @flow\n\n  /*::\n  declare var __webpack_require__: mixed;\n  */\n  module.exports = typeof __webpack_require__ !== \"undefined\";\n  /***/\n},,\n/* 229 */\n\n/***/\nfunction (module, exports) {\n  /**\n   * Helpers.\n   */\n  var s = 1000;\n  var m = s * 60;\n  var h = m * 60;\n  var d = h * 24;\n  var y = d * 365.25;\n  /**\n   * Parse or format the given `val`.\n   *\n   * Options:\n   *\n   *  - `long` verbose formatting [false]\n   *\n   * @param {String|Number} val\n   * @param {Object} [options]\n   * @throws {Error} throw an error if val is not a non-empty string or a number\n   * @return {String|Number}\n   * @api public\n   */\n\n  module.exports = function (val, options) {\n    options = options || {};\n    var type = typeof val;\n\n    if (type === 'string' && val.length > 0) {\n      return parse(val);\n    } else if (type === 'number' && isNaN(val) === false) {\n      return options.long ? fmtLong(val) : fmtShort(val);\n    }\n\n    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n  };\n  /**\n   * Parse the given `str` and return milliseconds.\n   *\n   * @param {String} str\n   * @return {Number}\n   * @api private\n   */\n\n\n  function parse(str) {\n    str = String(str);\n\n    if (str.length > 100) {\n      return;\n    }\n\n    var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\n    if (!match) {\n      return;\n    }\n\n    var n = parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n\n    switch (type) {\n      case 'years':\n      case 'year':\n      case 'yrs':\n      case 'yr':\n      case 'y':\n        return n * y;\n\n      case 'days':\n      case 'day':\n      case 'd':\n        return n * d;\n\n      case 'hours':\n      case 'hour':\n      case 'hrs':\n      case 'hr':\n      case 'h':\n        return n * h;\n\n      case 'minutes':\n      case 'minute':\n      case 'mins':\n      case 'min':\n      case 'm':\n        return n * m;\n\n      case 'seconds':\n      case 'second':\n      case 'secs':\n      case 'sec':\n      case 's':\n        return n * s;\n\n      case 'milliseconds':\n      case 'millisecond':\n      case 'msecs':\n      case 'msec':\n      case 'ms':\n        return n;\n\n      default:\n        return undefined;\n    }\n  }\n  /**\n   * Short format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n\n  function fmtShort(ms) {\n    if (ms >= d) {\n      return Math.round(ms / d) + 'd';\n    }\n\n    if (ms >= h) {\n      return Math.round(ms / h) + 'h';\n    }\n\n    if (ms >= m) {\n      return Math.round(ms / m) + 'm';\n    }\n\n    if (ms >= s) {\n      return Math.round(ms / s) + 's';\n    }\n\n    return ms + 'ms';\n  }\n  /**\n   * Long format for `ms`.\n   *\n   * @param {Number} ms\n   * @return {String}\n   * @api private\n   */\n\n\n  function fmtLong(ms) {\n    return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';\n  }\n  /**\n   * Pluralization helper.\n   */\n\n\n  function plural(ms, n, name) {\n    if (ms < n) {\n      return;\n    }\n\n    if (ms < n * 1.5) {\n      return Math.floor(ms / n) + ' ' + name;\n    }\n\n    return Math.ceil(ms / n) + ' ' + name + 's';\n  }\n  /***/\n\n},,,,\n/* 233 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = rimraf;\n  rimraf.sync = rimrafSync;\n\n  var assert = __webpack_require__(22);\n\n  var path = __webpack_require__(0);\n\n  var fs = __webpack_require__(3);\n\n  var glob = __webpack_require__(75);\n\n  var _0666 = parseInt('666', 8);\n\n  var defaultGlobOpts = {\n    nosort: true,\n    silent: true\n  }; // for EMFILE handling\n\n  var timeout = 0;\n  var isWindows = process.platform === \"win32\";\n\n  function defaults(options) {\n    var methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];\n    methods.forEach(function (m) {\n      options[m] = options[m] || fs[m];\n      m = m + 'Sync';\n      options[m] = options[m] || fs[m];\n    });\n    options.maxBusyTries = options.maxBusyTries || 3;\n    options.emfileWait = options.emfileWait || 1000;\n\n    if (options.glob === false) {\n      options.disableGlob = true;\n    }\n\n    options.disableGlob = options.disableGlob || false;\n    options.glob = options.glob || defaultGlobOpts;\n  }\n\n  function rimraf(p, options, cb) {\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    assert(p, 'rimraf: missing path');\n    assert.equal(typeof p, 'string', 'rimraf: path should be a string');\n    assert.equal(typeof cb, 'function', 'rimraf: callback function required');\n    assert(options, 'rimraf: invalid options argument provided');\n    assert.equal(typeof options, 'object', 'rimraf: options should be object');\n    defaults(options);\n    var busyTries = 0;\n    var errState = null;\n    var n = 0;\n    if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p]);\n    options.lstat(p, function (er, stat) {\n      if (!er) return afterGlob(null, [p]);\n      glob(p, options.glob, afterGlob);\n    });\n\n    function next(er) {\n      errState = errState || er;\n      if (--n === 0) cb(errState);\n    }\n\n    function afterGlob(er, results) {\n      if (er) return cb(er);\n      n = results.length;\n      if (n === 0) return cb();\n      results.forEach(function (p) {\n        rimraf_(p, options, function CB(er) {\n          if (er) {\n            if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") && busyTries < options.maxBusyTries) {\n              busyTries++;\n              var time = busyTries * 100; // try again, with the same exact callback as this one.\n\n              return setTimeout(function () {\n                rimraf_(p, options, CB);\n              }, time);\n            } // this one won't happen if graceful-fs is used.\n\n\n            if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n              return setTimeout(function () {\n                rimraf_(p, options, CB);\n              }, timeout++);\n            } // already gone\n\n\n            if (er.code === \"ENOENT\") er = null;\n          }\n\n          timeout = 0;\n          next(er);\n        });\n      });\n    }\n  } // Two possible strategies.\n  // 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n  // 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n  //\n  // Both result in an extra syscall when you guess wrong.  However, there\n  // are likely far more normal files in the world than directories.  This\n  // is based on the assumption that a the average number of files per\n  // directory is >= 1.\n  //\n  // If anyone ever complains about this, then I guess the strategy could\n  // be made configurable somehow.  But until then, YAGNI.\n\n\n  function rimraf_(p, options, cb) {\n    assert(p);\n    assert(options);\n    assert(typeof cb === 'function'); // sunos lets the root user unlink directories, which is... weird.\n    // so we have to lstat here and make sure it's not a dir.\n\n    options.lstat(p, function (er, st) {\n      if (er && er.code === \"ENOENT\") return cb(null); // Windows can EPERM on stat.  Life is suffering.\n\n      if (er && er.code === \"EPERM\" && isWindows) fixWinEPERM(p, options, er, cb);\n      if (st && st.isDirectory()) return rmdir(p, options, er, cb);\n      options.unlink(p, function (er) {\n        if (er) {\n          if (er.code === \"ENOENT\") return cb(null);\n          if (er.code === \"EPERM\") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);\n          if (er.code === \"EISDIR\") return rmdir(p, options, er, cb);\n        }\n\n        return cb(er);\n      });\n    });\n  }\n\n  function fixWinEPERM(p, options, er, cb) {\n    assert(p);\n    assert(options);\n    assert(typeof cb === 'function');\n    if (er) assert(er instanceof Error);\n    options.chmod(p, _0666, function (er2) {\n      if (er2) cb(er2.code === \"ENOENT\" ? null : er);else options.stat(p, function (er3, stats) {\n        if (er3) cb(er3.code === \"ENOENT\" ? null : er);else if (stats.isDirectory()) rmdir(p, options, er, cb);else options.unlink(p, cb);\n      });\n    });\n  }\n\n  function fixWinEPERMSync(p, options, er) {\n    assert(p);\n    assert(options);\n    if (er) assert(er instanceof Error);\n\n    try {\n      options.chmodSync(p, _0666);\n    } catch (er2) {\n      if (er2.code === \"ENOENT\") return;else throw er;\n    }\n\n    try {\n      var stats = options.statSync(p);\n    } catch (er3) {\n      if (er3.code === \"ENOENT\") return;else throw er;\n    }\n\n    if (stats.isDirectory()) rmdirSync(p, options, er);else options.unlinkSync(p);\n  }\n\n  function rmdir(p, options, originalEr, cb) {\n    assert(p);\n    assert(options);\n    if (originalEr) assert(originalEr instanceof Error);\n    assert(typeof cb === 'function'); // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n    // if we guessed wrong, and it's not a directory, then\n    // raise the original error.\n\n    options.rmdir(p, function (er) {\n      if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")) rmkids(p, options, cb);else if (er && er.code === \"ENOTDIR\") cb(originalEr);else cb(er);\n    });\n  }\n\n  function rmkids(p, options, cb) {\n    assert(p);\n    assert(options);\n    assert(typeof cb === 'function');\n    options.readdir(p, function (er, files) {\n      if (er) return cb(er);\n      var n = files.length;\n      if (n === 0) return options.rmdir(p, cb);\n      var errState;\n      files.forEach(function (f) {\n        rimraf(path.join(p, f), options, function (er) {\n          if (errState) return;\n          if (er) return cb(errState = er);\n          if (--n === 0) options.rmdir(p, cb);\n        });\n      });\n    });\n  } // this looks simpler, and is strictly *faster*, but will\n  // tie up the JavaScript thread and fail on excessively\n  // deep directory trees.\n\n\n  function rimrafSync(p, options) {\n    options = options || {};\n    defaults(options);\n    assert(p, 'rimraf: missing path');\n    assert.equal(typeof p, 'string', 'rimraf: path should be a string');\n    assert(options, 'rimraf: missing options');\n    assert.equal(typeof options, 'object', 'rimraf: options should be object');\n    var results;\n\n    if (options.disableGlob || !glob.hasMagic(p)) {\n      results = [p];\n    } else {\n      try {\n        options.lstatSync(p);\n        results = [p];\n      } catch (er) {\n        results = glob.sync(p, options.glob);\n      }\n    }\n\n    if (!results.length) return;\n\n    for (var i = 0; i < results.length; i++) {\n      var p = results[i];\n\n      try {\n        var st = options.lstatSync(p);\n      } catch (er) {\n        if (er.code === \"ENOENT\") return; // Windows can EPERM on stat.  Life is suffering.\n\n        if (er.code === \"EPERM\" && isWindows) fixWinEPERMSync(p, options, er);\n      }\n\n      try {\n        // sunos lets the root user unlink directories, which is... weird.\n        if (st && st.isDirectory()) rmdirSync(p, options, null);else options.unlinkSync(p);\n      } catch (er) {\n        if (er.code === \"ENOENT\") return;\n        if (er.code === \"EPERM\") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n        if (er.code !== \"EISDIR\") throw er;\n        rmdirSync(p, options, er);\n      }\n    }\n  }\n\n  function rmdirSync(p, options, originalEr) {\n    assert(p);\n    assert(options);\n    if (originalEr) assert(originalEr instanceof Error);\n\n    try {\n      options.rmdirSync(p);\n    } catch (er) {\n      if (er.code === \"ENOENT\") return;\n      if (er.code === \"ENOTDIR\") throw originalEr;\n      if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\") rmkidsSync(p, options);\n    }\n  }\n\n  function rmkidsSync(p, options) {\n    assert(p);\n    assert(options);\n    options.readdirSync(p).forEach(function (f) {\n      rimrafSync(path.join(p, f), options);\n    }); // We only end up here once we got ENOTEMPTY at least once, and\n    // at this point, we are guaranteed to have removed all the kids.\n    // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n    // try really hard to delete stuff on windows, because it has a\n    // PROFOUNDLY annoying habit of not closing handles promptly when\n    // files are deleted, resulting in spurious ENOTEMPTY errors.\n\n    var retries = isWindows ? 100 : 1;\n    var i = 0;\n\n    do {\n      var threw = true;\n\n      try {\n        var ret = options.rmdirSync(p, options);\n        threw = false;\n        return ret;\n      } finally {\n        if (++i < retries && threw) continue;\n      }\n    } while (true);\n  }\n  /***/\n\n},,,,,,\n/* 239 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  \"use strict\";\n\n  var hasFlag = __webpack_require__(221);\n\n  var support = function (level) {\n    if (level === 0) {\n      return false;\n    }\n\n    return {\n      level: level,\n      hasBasic: true,\n      has256: level >= 2,\n      has16m: level >= 3\n    };\n  };\n\n  var supportLevel = function () {\n    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {\n      return 0;\n    }\n\n    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {\n      return 3;\n    }\n\n    if (hasFlag('color=256')) {\n      return 2;\n    }\n\n    if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {\n      return 1;\n    }\n\n    if (process.stdout && !process.stdout.isTTY) {\n      return 0;\n    }\n\n    if (process.platform === 'win32') {\n      return 1;\n    }\n\n    if ('CI' in process.env) {\n      if ('TRAVIS' in process.env || process.env.CI === 'Travis') {\n        return 1;\n      }\n\n      return 0;\n    }\n\n    if ('TEAMCITY_VERSION' in process.env) {\n      return process.env.TEAMCITY_VERSION.match(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/) === null ? 0 : 1;\n    }\n\n    if (/^(screen|xterm)-256(?:color)?/.test(process.env.TERM)) {\n      return 2;\n    }\n\n    if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n      return 1;\n    }\n\n    if ('COLORTERM' in process.env) {\n      return 1;\n    }\n\n    if (process.env.TERM === 'dumb') {\n      return 0;\n    }\n\n    return 0;\n  }();\n\n  if (supportLevel === 0 && 'FORCE_COLOR' in process.env) {\n    supportLevel = 1;\n  }\n\n  module.exports = process && support(supportLevel);\n  /***/\n}\n/******/\n]);","map":null,"metadata":{},"sourceType":"script"}