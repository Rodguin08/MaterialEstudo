{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeJsonWorkspace = void 0;\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst metadata_1 = require(\"./metadata\");\n\nfunction writeJsonWorkspace(_x, _x2, _x3) {\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nfunction _writeJsonWorkspace() {\n  _writeJsonWorkspace = _asyncToGenerator(function* (workspace, host, path, options = {}) {\n    const metadata = workspace[metadata_1.JsonWorkspaceSymbol];\n\n    if (metadata) {\n      if (!metadata.hasChanges) {\n        return;\n      } // update existing JSON workspace\n\n\n      const data = updateJsonWorkspace(metadata);\n      return host.writeFile(path !== null && path !== void 0 ? path : metadata.filePath, data);\n    } else {\n      // serialize directly\n      if (!path) {\n        throw new Error('path option is required');\n      }\n\n      const obj = convertJsonWorkspace(workspace, options.schema);\n      const data = JSON.stringify(obj, null, 2);\n      return host.writeFile(path, data);\n    }\n  });\n  return _writeJsonWorkspace.apply(this, arguments);\n}\n\nexports.writeJsonWorkspace = writeJsonWorkspace;\n\nfunction convertJsonWorkspace(workspace, schema) {\n  const obj = {\n    $schema: schema || './node_modules/@angular/cli/lib/config/schema.json',\n    version: 1,\n    ...workspace.extensions,\n    ...(isEmpty(workspace.projects) ? {} : {\n      projects: convertJsonProjectCollection(workspace.projects)\n    })\n  };\n  return obj;\n}\n\nfunction convertJsonProjectCollection(collection) {\n  const projects = Object.create(null);\n\n  for (const [projectName, project] of collection) {\n    projects[projectName] = convertJsonProject(project);\n  }\n\n  return projects;\n}\n\nfunction convertJsonProject(project) {\n  let targets;\n\n  if (project.targets.size > 0) {\n    targets = Object.create(null);\n\n    for (const [targetName, target] of project.targets) {\n      targets[targetName] = convertJsonTarget(target);\n    }\n  }\n\n  const obj = { ...project.extensions,\n    root: project.root,\n    ...(project.sourceRoot === undefined ? {} : {\n      sourceRoot: project.sourceRoot\n    }),\n    ...(project.prefix === undefined ? {} : {\n      prefix: project.prefix\n    }),\n    ...(targets === undefined ? {} : {\n      architect: targets\n    })\n  };\n  return obj;\n}\n\nfunction isEmpty(obj) {\n  return obj === undefined || Object.keys(obj).length === 0;\n}\n\nfunction convertJsonTarget(target) {\n  return {\n    builder: target.builder,\n    ...(isEmpty(target.options) ? {} : {\n      options: target.options\n    }),\n    ...(isEmpty(target.configurations) ? {} : {\n      configurations: target.configurations\n    }),\n    ...(target.defaultConfiguration === undefined ? {} : {\n      defaultConfiguration: target.defaultConfiguration\n    })\n  };\n}\n\nfunction convertJsonTargetCollection(collection) {\n  const targets = Object.create(null);\n\n  for (const [projectName, target] of collection) {\n    targets[projectName] = convertJsonTarget(target);\n  }\n\n  return targets;\n}\n\nfunction normalizeValue(value, type) {\n  if (value === undefined) {\n    return undefined;\n  }\n\n  switch (type) {\n    case 'project':\n      return convertJsonProject(value);\n\n    case 'projectcollection':\n      const projects = convertJsonProjectCollection(value);\n      return isEmpty(projects) ? undefined : projects;\n\n    case 'target':\n      return convertJsonTarget(value);\n\n    case 'targetcollection':\n      const targets = convertJsonTargetCollection(value);\n      return isEmpty(targets) ? undefined : targets;\n\n    default:\n      return value;\n  }\n}\n\nfunction updateJsonWorkspace(metadata) {\n  let {\n    raw: content\n  } = metadata;\n  const {\n    changes,\n    hasLegacyTargetsName\n  } = metadata;\n\n  for (const {\n    jsonPath,\n    value,\n    type\n  } of changes.values()) {\n    // Determine which key to use if (architect or targets)\n    if (hasLegacyTargetsName && jsonPath[2] === 'targets') {\n      jsonPath[2] = 'architect';\n    } // modify\n\n\n    const newJsonPath = jsonPath.map(v => isFinite(+v) ? +v : v); // TODO: `modify` re-parses the content every time.\n    // See: https://github.com/microsoft/node-jsonc-parser/blob/35d94cd71bd48f9784453b2439262c938e21d49b/src/impl/edit.ts#L18\n    // Ideally this should accept a string or an AST to avoid the potentially expensive repeat parsing operation.\n\n    const edits = (0, jsonc_parser_1.modify)(content, newJsonPath, normalizeValue(value, type), {\n      formattingOptions: {\n        insertSpaces: true,\n        tabSize: 2\n      }\n    });\n    content = (0, jsonc_parser_1.applyEdits)(content, edits);\n  }\n\n  return content;\n}","map":null,"metadata":{},"sourceType":"script"}