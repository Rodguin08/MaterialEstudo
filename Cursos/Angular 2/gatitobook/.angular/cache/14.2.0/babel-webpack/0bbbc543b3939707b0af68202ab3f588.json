{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isWarningEnabled = exports.getSchematicDefaults = exports.getConfiguredPackageManager = exports.getProjectByCwd = exports.validateWorkspace = exports.getWorkspaceRaw = exports.getWorkspace = exports.AngularWorkspace = exports.workspaceSchemaPath = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst os = __importStar( /*#__PURE__*/require(\"os\"));\n\nconst path = __importStar( /*#__PURE__*/require(\"path\"));\n\nconst find_up_1 = /*#__PURE__*/require(\"./find-up\");\n\nconst json_file_1 = /*#__PURE__*/require(\"./json-file\");\n\nfunction isJsonObject(value) {\n  return value !== undefined && core_1.json.isJsonObject(value);\n}\n\nfunction createWorkspaceHost() {\n  return {\n    readFile(path) {\n      return fs_1.promises.readFile(path, 'utf-8');\n    },\n\n    writeFile(path, data) {\n      return _asyncToGenerator(function* () {\n        yield fs_1.promises.writeFile(path, data);\n      })();\n    },\n\n    isDirectory(path) {\n      return _asyncToGenerator(function* () {\n        try {\n          const stats = yield fs_1.promises.stat(path);\n          return stats.isDirectory();\n        } catch {\n          return false;\n        }\n      })();\n    },\n\n    isFile(path) {\n      return _asyncToGenerator(function* () {\n        try {\n          const stats = yield fs_1.promises.stat(path);\n          return stats.isFile();\n        } catch {\n          return false;\n        }\n      })();\n    }\n\n  };\n}\n\nexports.workspaceSchemaPath = /*#__PURE__*/path.join(__dirname, '../../lib/config/schema.json');\nconst configNames = ['angular.json', '.angular.json'];\nconst globalFileName = '.angular-config.json';\nconst defaultGlobalFilePath = /*#__PURE__*/path.join( /*#__PURE__*/os.homedir(), globalFileName);\n\nfunction xdgConfigHome(home, configFile) {\n  // https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html\n  const xdgConfigHome = process.env['XDG_CONFIG_HOME'] || path.join(home, '.config');\n  const xdgAngularHome = path.join(xdgConfigHome, 'angular');\n  return configFile ? path.join(xdgAngularHome, configFile) : xdgAngularHome;\n}\n\nfunction xdgConfigHomeOld(home) {\n  // Check the configuration files in the old location that should be:\n  // - $XDG_CONFIG_HOME/.angular-config.json (if XDG_CONFIG_HOME is set)\n  // - $HOME/.config/angular/.angular-config.json (otherwise)\n  const p = process.env['XDG_CONFIG_HOME'] || path.join(home, '.config', 'angular');\n  return path.join(p, '.angular-config.json');\n}\n\nfunction projectFilePath(projectPath) {\n  // Find the configuration, either where specified, in the Angular CLI project\n  // (if it's in node_modules) or from the current process.\n  return projectPath && (0, find_up_1.findUp)(configNames, projectPath) || (0, find_up_1.findUp)(configNames, process.cwd()) || (0, find_up_1.findUp)(configNames, __dirname);\n}\n\nfunction globalFilePath() {\n  const home = os.homedir();\n\n  if (!home) {\n    return null;\n  } // follow XDG Base Directory spec\n  // note that createGlobalSettings() will continue creating\n  // global file in home directory, with this user will have\n  // choice to move change its location to meet XDG convention\n\n\n  const xdgConfig = xdgConfigHome(home, 'config.json');\n\n  if ((0, fs_1.existsSync)(xdgConfig)) {\n    return xdgConfig;\n  } // NOTE: This check is for the old configuration location, for more\n  // information see https://github.com/angular/angular-cli/pull/20556\n\n\n  const xdgConfigOld = xdgConfigHomeOld(home);\n\n  if ((0, fs_1.existsSync)(xdgConfigOld)) {\n    /* eslint-disable no-console */\n    console.warn(`Old configuration location detected: ${xdgConfigOld}\\n` + `Please move the file to the new location ~/.config/angular/config.json`);\n    return xdgConfigOld;\n  }\n\n  if ((0, fs_1.existsSync)(defaultGlobalFilePath)) {\n    return defaultGlobalFilePath;\n  }\n\n  return null;\n}\n\nclass AngularWorkspace {\n  constructor(workspace, filePath) {\n    this.workspace = workspace;\n    this.filePath = filePath;\n    this.basePath = path.dirname(filePath);\n  }\n\n  get extensions() {\n    return this.workspace.extensions;\n  }\n\n  get projects() {\n    return this.workspace.projects;\n  } // Temporary helper functions to support refactoring\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  getCli() {\n    return this.workspace.extensions['cli'];\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  getProjectCli(projectName) {\n    const project = this.workspace.projects.get(projectName);\n    return project === null || project === void 0 ? void 0 : project.extensions['cli'];\n  }\n\n  save() {\n    return core_1.workspaces.writeWorkspace(this.workspace, createWorkspaceHost(), this.filePath, core_1.workspaces.WorkspaceFormat.JSON);\n  }\n\n  static load(workspaceFilePath) {\n    return _asyncToGenerator(function* () {\n      const result = yield core_1.workspaces.readWorkspace(workspaceFilePath, createWorkspaceHost(), core_1.workspaces.WorkspaceFormat.JSON);\n      return new AngularWorkspace(result.workspace, workspaceFilePath);\n    })();\n  }\n\n}\n\nexports.AngularWorkspace = AngularWorkspace;\nconst cachedWorkspaces = /*#__PURE__*/new Map();\n\nfunction getWorkspace(_x) {\n  return _getWorkspace.apply(this, arguments);\n}\n\nfunction _getWorkspace() {\n  _getWorkspace = _asyncToGenerator(function* (level) {\n    if (cachedWorkspaces.has(level)) {\n      return cachedWorkspaces.get(level);\n    }\n\n    const configPath = level === 'local' ? projectFilePath() : globalFilePath();\n\n    if (!configPath) {\n      if (level === 'global') {\n        // Unlike a local config, a global config is not mandatory.\n        // So we create an empty one in memory and keep it as such until it has been modified and saved.\n        const globalWorkspace = new AngularWorkspace({\n          extensions: {},\n          projects: new core_1.workspaces.ProjectDefinitionCollection()\n        }, defaultGlobalFilePath);\n        cachedWorkspaces.set(level, globalWorkspace);\n        return globalWorkspace;\n      }\n\n      cachedWorkspaces.set(level, undefined);\n      return undefined;\n    }\n\n    try {\n      const workspace = yield AngularWorkspace.load(configPath);\n      cachedWorkspaces.set(level, workspace);\n      return workspace;\n    } catch (error) {\n      throw new Error(`Workspace config file cannot be loaded: ${configPath}` + `\\n${error instanceof Error ? error.message : error}`);\n    }\n  });\n  return _getWorkspace.apply(this, arguments);\n}\n\nexports.getWorkspace = getWorkspace;\n/**\n * This method will load the workspace configuration in raw JSON format.\n * When `level` is `global` and file doesn't exists, it will be created.\n *\n * NB: This method is intended to be used only for `ng config`.\n */\n\nfunction getWorkspaceRaw() {\n  return _getWorkspaceRaw.apply(this, arguments);\n}\n\nfunction _getWorkspaceRaw() {\n  _getWorkspaceRaw = _asyncToGenerator(function* (level = 'local') {\n    let configPath = level === 'local' ? projectFilePath() : globalFilePath();\n\n    if (!configPath) {\n      if (level === 'global') {\n        configPath = defaultGlobalFilePath; // Config doesn't exist, force create it.\n\n        const globalWorkspace = yield getWorkspace('global');\n        yield globalWorkspace.save();\n      } else {\n        return [null, null];\n      }\n    }\n\n    return [new json_file_1.JSONFile(configPath), configPath];\n  });\n  return _getWorkspaceRaw.apply(this, arguments);\n}\n\nexports.getWorkspaceRaw = getWorkspaceRaw;\n\nfunction validateWorkspace(_x2, _x3) {\n  return _validateWorkspace.apply(this, arguments);\n}\n\nfunction _validateWorkspace() {\n  _validateWorkspace = _asyncToGenerator(function* (data, isGlobal) {\n    const schema = (0, json_file_1.readAndParseJson)(exports.workspaceSchemaPath); // We should eventually have a dedicated global config schema and use that to validate.\n\n    const schemaToValidate = isGlobal ? {\n      '$ref': '#/definitions/global',\n      definitions: schema['definitions']\n    } : schema;\n    const {\n      formats\n    } = yield Promise.resolve().then(() => __importStar(require('@angular-devkit/schematics')));\n    const registry = new core_1.json.schema.CoreSchemaRegistry(formats.standardFormats);\n    const validator = yield registry.compile(schemaToValidate).toPromise();\n    const {\n      success,\n      errors\n    } = yield validator(data).toPromise();\n\n    if (!success) {\n      throw new core_1.json.schema.SchemaValidationException(errors);\n    }\n  });\n  return _validateWorkspace.apply(this, arguments);\n}\n\nexports.validateWorkspace = validateWorkspace;\n\nfunction findProjectByPath(workspace, location) {\n  const isInside = (base, potential) => {\n    const absoluteBase = path.resolve(workspace.basePath, base);\n    const absolutePotential = path.resolve(workspace.basePath, potential);\n    const relativePotential = path.relative(absoluteBase, absolutePotential);\n\n    if (!relativePotential.startsWith('..') && !path.isAbsolute(relativePotential)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  const projects = Array.from(workspace.projects).map(([name, project]) => [project.root, name]).filter(tuple => isInside(tuple[0], location)) // Sort tuples by depth, with the deeper ones first. Since the first member is a path and\n  // we filtered all invalid paths, the longest will be the deepest (and in case of equality\n  // the sort is stable and the first declared project will win).\n  .sort((a, b) => b[0].length - a[0].length);\n\n  if (projects.length === 0) {\n    return null;\n  } else if (projects.length > 1) {\n    const found = new Set();\n    const sameRoots = projects.filter(v => {\n      if (!found.has(v[0])) {\n        found.add(v[0]);\n        return false;\n      }\n\n      return true;\n    });\n\n    if (sameRoots.length > 0) {\n      // Ambiguous location - cannot determine a project\n      return null;\n    }\n  }\n\n  return projects[0][1];\n}\n\nlet defaultProjectDeprecationWarningShown = false;\n\nfunction getProjectByCwd(workspace) {\n  if (workspace.projects.size === 1) {\n    // If there is only one project, return that one.\n    return Array.from(workspace.projects.keys())[0];\n  }\n\n  const project = findProjectByPath(workspace, process.cwd());\n\n  if (project) {\n    return project;\n  }\n\n  const defaultProject = workspace.extensions['defaultProject'];\n\n  if (defaultProject && typeof defaultProject === 'string') {\n    // If there is a default project name, return it.\n    if (!defaultProjectDeprecationWarningShown) {\n      console.warn(`DEPRECATED: The 'defaultProject' workspace option has been deprecated. ` + `The project to use will be determined from the current working directory.`);\n      defaultProjectDeprecationWarningShown = true;\n    }\n\n    return defaultProject;\n  }\n\n  return null;\n}\n\nexports.getProjectByCwd = getProjectByCwd;\n\nfunction getConfiguredPackageManager() {\n  return _getConfiguredPackageManager.apply(this, arguments);\n}\n\nfunction _getConfiguredPackageManager() {\n  _getConfiguredPackageManager = _asyncToGenerator(function* () {\n    var _a;\n\n    const getPackageManager = source => {\n      if (isJsonObject(source)) {\n        const value = source['packageManager'];\n\n        if (value && typeof value === 'string') {\n          return value;\n        }\n      }\n\n      return null;\n    };\n\n    let result = null;\n    const workspace = yield getWorkspace('local');\n\n    if (workspace) {\n      const project = getProjectByCwd(workspace);\n\n      if (project) {\n        result = getPackageManager((_a = workspace.projects.get(project)) === null || _a === void 0 ? void 0 : _a.extensions['cli']);\n      }\n\n      result !== null && result !== void 0 ? result : result = getPackageManager(workspace.extensions['cli']);\n    }\n\n    if (!result) {\n      const globalOptions = yield getWorkspace('global');\n      result = getPackageManager(globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.extensions['cli']);\n    }\n\n    return result;\n  });\n  return _getConfiguredPackageManager.apply(this, arguments);\n}\n\nexports.getConfiguredPackageManager = getConfiguredPackageManager;\n\nfunction getSchematicDefaults(_x4, _x5, _x6) {\n  return _getSchematicDefaults.apply(this, arguments);\n}\n\nfunction _getSchematicDefaults() {\n  _getSchematicDefaults = _asyncToGenerator(function* (collection, schematic, project) {\n    var _a;\n\n    const result = {};\n\n    const mergeOptions = source => {\n      if (isJsonObject(source)) {\n        // Merge options from the qualified name\n        Object.assign(result, source[`${collection}:${schematic}`]); // Merge options from nested collection schematics\n\n        const collectionOptions = source[collection];\n\n        if (isJsonObject(collectionOptions)) {\n          Object.assign(result, collectionOptions[schematic]);\n        }\n      }\n    }; // Global level schematic options\n\n\n    const globalOptions = yield getWorkspace('global');\n    mergeOptions(globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.extensions['schematics']);\n    const workspace = yield getWorkspace('local');\n\n    if (workspace) {\n      // Workspace level schematic options\n      mergeOptions(workspace.extensions['schematics']);\n      project = project || getProjectByCwd(workspace);\n\n      if (project) {\n        // Project level schematic options\n        mergeOptions((_a = workspace.projects.get(project)) === null || _a === void 0 ? void 0 : _a.extensions['schematics']);\n      }\n    }\n\n    return result;\n  });\n  return _getSchematicDefaults.apply(this, arguments);\n}\n\nexports.getSchematicDefaults = getSchematicDefaults;\n\nfunction isWarningEnabled(_x7) {\n  return _isWarningEnabled.apply(this, arguments);\n}\n\nfunction _isWarningEnabled() {\n  _isWarningEnabled = _asyncToGenerator(function* (warning) {\n    var _a;\n\n    const getWarning = source => {\n      if (isJsonObject(source)) {\n        const warnings = source['warnings'];\n\n        if (isJsonObject(warnings)) {\n          const value = warnings[warning];\n\n          if (typeof value == 'boolean') {\n            return value;\n          }\n        }\n      }\n    };\n\n    let result;\n    const workspace = yield getWorkspace('local');\n\n    if (workspace) {\n      const project = getProjectByCwd(workspace);\n\n      if (project) {\n        result = getWarning((_a = workspace.projects.get(project)) === null || _a === void 0 ? void 0 : _a.extensions['cli']);\n      }\n\n      result = result !== null && result !== void 0 ? result : getWarning(workspace.extensions['cli']);\n    }\n\n    if (result === undefined) {\n      const globalOptions = yield getWorkspace('global');\n      result = getWarning(globalOptions === null || globalOptions === void 0 ? void 0 : globalOptions.extensions['cli']);\n    } // All warnings are enabled by default\n\n\n    return result !== null && result !== void 0 ? result : true;\n  });\n  return _isWarningEnabled.apply(this, arguments);\n}\n\nexports.isWarningEnabled = isWarningEnabled;","map":null,"metadata":{},"sourceType":"script"}