{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Architect = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst api_1 = require(\"./api\");\n\nconst schedule_by_name_1 = require(\"./schedule-by-name\");\n\nconst inputSchema = require('./input-schema.json');\n\nconst outputSchema = require('./output-schema.json');\n\nfunction _createJobHandlerFromBuilderInfo(info, target, host, registry, baseOptions) {\n  const jobDescription = {\n    name: target ? `{${(0, api_1.targetStringFromTarget)(target)}}` : info.builderName,\n    argument: {\n      type: 'object'\n    },\n    input: inputSchema,\n    output: outputSchema,\n    info\n  };\n\n  function handler(argument, context) {\n    // Add input validation to the inbound bus.\n    const inboundBusWithInputValidation = context.inboundBus.pipe((0, operators_1.concatMap)(message => {\n      if (message.kind === core_1.experimental.jobs.JobInboundMessageKind.Input) {\n        const v = message.value;\n        const options = { ...baseOptions,\n          ...v.options\n        }; // Validate v against the options schema.\n\n        return registry.compile(info.optionSchema).pipe((0, operators_1.concatMap)(validation => validation(options)), (0, operators_1.map)(validationResult => {\n          const {\n            data,\n            success,\n            errors\n          } = validationResult;\n\n          if (success) {\n            return { ...v,\n              options: data\n            };\n          }\n\n          throw new core_1.json.schema.SchemaValidationException(errors);\n        }), (0, operators_1.map)(value => ({ ...message,\n          value\n        })));\n      } else {\n        return (0, rxjs_1.of)(message);\n      }\n    }), // Using a share replay because the job might be synchronously sending input, but\n    // asynchronously listening to it.\n    (0, operators_1.shareReplay)(1)); // Make an inboundBus that completes instead of erroring out.\n    // We'll merge the errors into the output instead.\n\n    const inboundBus = (0, rxjs_1.onErrorResumeNext)(inboundBusWithInputValidation);\n    const output = (0, rxjs_1.from)(host.loadBuilder(info)).pipe((0, operators_1.concatMap)(builder => {\n      if (builder === null) {\n        throw new Error(`Cannot load builder for builderInfo ${JSON.stringify(info, null, 2)}`);\n      }\n\n      return builder.handler(argument, { ...context,\n        inboundBus\n      }).pipe((0, operators_1.map)(output => {\n        if (output.kind === core_1.experimental.jobs.JobOutboundMessageKind.Output) {\n          // Add target to it.\n          return { ...output,\n            value: { ...output.value,\n              ...(target ? {\n                target\n              } : 0)\n            }\n          };\n        } else {\n          return output;\n        }\n      }));\n    }), // Share subscriptions to the output, otherwise the the handler will be re-run.\n    (0, operators_1.shareReplay)()); // Separate the errors from the inbound bus into their own observable that completes when the\n    // builder output does.\n\n    const inboundBusErrors = inboundBusWithInputValidation.pipe((0, operators_1.ignoreElements)(), (0, operators_1.takeUntil)((0, rxjs_1.onErrorResumeNext)(output.pipe((0, operators_1.last)())))); // Return the builder output plus any input errors.\n\n    return (0, rxjs_1.merge)(inboundBusErrors, output);\n  }\n\n  return (0, rxjs_1.of)(Object.assign(handler, {\n    jobDescription\n  }));\n}\n/**\n * A JobRegistry that resolves builder targets from the host.\n */\n\n\nclass ArchitectBuilderJobRegistry {\n  constructor(_host, _registry, _jobCache, _infoCache) {\n    this._host = _host;\n    this._registry = _registry;\n    this._jobCache = _jobCache;\n    this._infoCache = _infoCache;\n  }\n\n  _resolveBuilder(name) {\n    const cache = this._infoCache;\n\n    if (cache) {\n      const maybeCache = cache.get(name);\n\n      if (maybeCache !== undefined) {\n        return maybeCache;\n      }\n\n      const info = (0, rxjs_1.from)(this._host.resolveBuilder(name)).pipe((0, operators_1.shareReplay)(1));\n      cache.set(name, info);\n      return info;\n    }\n\n    return (0, rxjs_1.from)(this._host.resolveBuilder(name));\n  }\n\n  _createBuilder(info, target, options) {\n    const cache = this._jobCache;\n\n    if (target) {\n      const maybeHit = cache && cache.get((0, api_1.targetStringFromTarget)(target));\n\n      if (maybeHit) {\n        return maybeHit;\n      }\n    } else {\n      const maybeHit = cache && cache.get(info.builderName);\n\n      if (maybeHit) {\n        return maybeHit;\n      }\n    }\n\n    const result = _createJobHandlerFromBuilderInfo(info, target, this._host, this._registry, options || {});\n\n    if (cache) {\n      if (target) {\n        cache.set((0, api_1.targetStringFromTarget)(target), result.pipe((0, operators_1.shareReplay)(1)));\n      } else {\n        cache.set(info.builderName, result.pipe((0, operators_1.shareReplay)(1)));\n      }\n    }\n\n    return result;\n  }\n\n  get(name) {\n    const m = name.match(/^([^:]+):([^:]+)$/i);\n\n    if (!m) {\n      return (0, rxjs_1.of)(null);\n    }\n\n    return (0, rxjs_1.from)(this._resolveBuilder(name)).pipe((0, operators_1.concatMap)(builderInfo => builderInfo ? this._createBuilder(builderInfo) : (0, rxjs_1.of)(null)), (0, operators_1.first)(null, null));\n  }\n\n}\n/**\n * A JobRegistry that resolves targets from the host.\n */\n\n\nclass ArchitectTargetJobRegistry extends ArchitectBuilderJobRegistry {\n  get(name) {\n    const m = name.match(/^{([^:]+):([^:]+)(?::([^:]*))?}$/i);\n\n    if (!m) {\n      return (0, rxjs_1.of)(null);\n    }\n\n    const target = {\n      project: m[1],\n      target: m[2],\n      configuration: m[3]\n    };\n    return (0, rxjs_1.from)(Promise.all([this._host.getBuilderNameForTarget(target), this._host.getOptionsForTarget(target)])).pipe((0, operators_1.concatMap)(([builderStr, options]) => {\n      if (builderStr === null || options === null) {\n        return (0, rxjs_1.of)(null);\n      }\n\n      return this._resolveBuilder(builderStr).pipe((0, operators_1.concatMap)(builderInfo => {\n        if (builderInfo === null) {\n          return (0, rxjs_1.of)(null);\n        }\n\n        return this._createBuilder(builderInfo, target, options);\n      }));\n    }), (0, operators_1.first)(null, null));\n  }\n\n}\n\nfunction _getTargetOptionsFactory(host) {\n  return core_1.experimental.jobs.createJobHandler(target => {\n    return host.getOptionsForTarget(target).then(options => {\n      if (options === null) {\n        throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n      }\n\n      return options;\n    });\n  }, {\n    name: '..getTargetOptions',\n    output: {\n      type: 'object'\n    },\n    argument: inputSchema.properties.target\n  });\n}\n\nfunction _getProjectMetadataFactory(host) {\n  return core_1.experimental.jobs.createJobHandler(target => {\n    return host.getProjectMetadata(target).then(options => {\n      if (options === null) {\n        throw new Error(`Invalid target: ${JSON.stringify(target)}.`);\n      }\n\n      return options;\n    });\n  }, {\n    name: '..getProjectMetadata',\n    output: {\n      type: 'object'\n    },\n    argument: {\n      oneOf: [{\n        type: 'string'\n      }, inputSchema.properties.target]\n    }\n  });\n}\n\nfunction _getBuilderNameForTargetFactory(host) {\n  return core_1.experimental.jobs.createJobHandler( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (target) {\n      const builderName = yield host.getBuilderNameForTarget(target);\n\n      if (!builderName) {\n        throw new Error(`No builder were found for target ${(0, api_1.targetStringFromTarget)(target)}.`);\n      }\n\n      return builderName;\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }(), {\n    name: '..getBuilderNameForTarget',\n    output: {\n      type: 'string'\n    },\n    argument: inputSchema.properties.target\n  });\n}\n\nfunction _validateOptionsFactory(host, registry) {\n  return core_1.experimental.jobs.createJobHandler( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator(function* ([builderName, options]) {\n      // Get option schema from the host.\n      const builderInfo = yield host.resolveBuilder(builderName);\n\n      if (!builderInfo) {\n        throw new Error(`No builder info were found for builder ${JSON.stringify(builderName)}.`);\n      }\n\n      return registry.compile(builderInfo.optionSchema).pipe((0, operators_1.concatMap)(validation => validation(options)), (0, operators_1.switchMap)(({\n        data,\n        success,\n        errors\n      }) => {\n        if (success) {\n          return (0, rxjs_1.of)(data);\n        }\n\n        throw new core_1.json.schema.SchemaValidationException(errors);\n      })).toPromise();\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), {\n    name: '..validateOptions',\n    output: {\n      type: 'object'\n    },\n    argument: {\n      type: 'array',\n      items: [{\n        type: 'string'\n      }, {\n        type: 'object'\n      }]\n    }\n  });\n}\n\nclass Architect {\n  constructor(_host, registry = new core_1.json.schema.CoreSchemaRegistry(), additionalJobRegistry) {\n    this._host = _host;\n    this._jobCache = new Map();\n    this._infoCache = new Map();\n    const privateArchitectJobRegistry = new core_1.experimental.jobs.SimpleJobRegistry(); // Create private jobs.\n\n    privateArchitectJobRegistry.register(_getTargetOptionsFactory(_host));\n    privateArchitectJobRegistry.register(_getBuilderNameForTargetFactory(_host));\n    privateArchitectJobRegistry.register(_validateOptionsFactory(_host, registry));\n    privateArchitectJobRegistry.register(_getProjectMetadataFactory(_host));\n    const jobRegistry = new core_1.experimental.jobs.FallbackRegistry([new ArchitectTargetJobRegistry(_host, registry, this._jobCache, this._infoCache), new ArchitectBuilderJobRegistry(_host, registry, this._jobCache, this._infoCache), privateArchitectJobRegistry, ...(additionalJobRegistry ? [additionalJobRegistry] : [])]);\n    this._scheduler = new core_1.experimental.jobs.SimpleScheduler(jobRegistry, registry);\n  }\n\n  has(name) {\n    return this._scheduler.has(name);\n  }\n\n  scheduleBuilder(name, options, scheduleOptions = {}) {\n    // The below will match 'project:target:configuration'\n    if (!/^[^:]+:[^:]+(:[^:]+)?$/.test(name)) {\n      throw new Error('Invalid builder name: ' + JSON.stringify(name));\n    }\n\n    return (0, schedule_by_name_1.scheduleByName)(name, options, {\n      scheduler: this._scheduler,\n      logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n      currentDirectory: this._host.getCurrentDirectory(),\n      workspaceRoot: this._host.getWorkspaceRoot(),\n      analytics: scheduleOptions.analytics\n    });\n  }\n\n  scheduleTarget(target, overrides = {}, scheduleOptions = {}) {\n    return (0, schedule_by_name_1.scheduleByTarget)(target, overrides, {\n      scheduler: this._scheduler,\n      logger: scheduleOptions.logger || new core_1.logging.NullLogger(),\n      currentDirectory: this._host.getCurrentDirectory(),\n      workspaceRoot: this._host.getWorkspaceRoot(),\n      analytics: scheduleOptions.analytics\n    });\n  }\n\n}\n\nexports.Architect = Architect;","map":null,"metadata":{},"sourceType":"script"}