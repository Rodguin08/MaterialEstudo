{"ast":null,"code":"const Fetcher = require('./fetcher.js');\n\nconst fsm = require('fs-minipass');\n\nconst cacache = require('cacache');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _exeBins = Symbol('_exeBins');\n\nconst {\n  resolve\n} = require('path');\n\nconst fs = require('fs');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson');\n\nclass FileFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // just the fully resolved filename\n\n    this.resolved = this.spec.fetchSpec;\n  }\n\n  get types() {\n    return ['file'];\n  }\n\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    } // have to unpack the tarball for this.\n\n\n    return cacache.tmp.withTmp(this.cache, this.opts, dir => this.extract(dir).then(() => this[_readPackageJson](dir + '/package.json')).then(mani => this.package = { ...mani,\n      _integrity: this.integrity && String(this.integrity),\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  [_exeBins](pkg, dest) {\n    if (!pkg.bin) {\n      return Promise.resolve();\n    }\n\n    return Promise.all(Object.keys(pkg.bin).map(k => new Promise(res => {\n      const script = resolve(dest, pkg.bin[k]); // Best effort.  Ignore errors here, the only result is that\n      // a bin script is not executable.  But if it's missing or\n      // something, we just leave it for a later stage to trip over\n      // when we can provide a more useful contextual error.\n\n      fs.stat(script, (er, st) => {\n        if (er) {\n          return res();\n        }\n\n        const mode = st.mode | 0o111;\n\n        if (mode === st.mode) {\n          return res();\n        }\n\n        fs.chmod(script, mode, res);\n      });\n    })));\n  }\n\n  extract(dest) {\n    // if we've already loaded the manifest, then the super got it.\n    // but if not, read the unpacked manifest and chmod properly.\n    return super.extract(dest).then(result => this.package ? result : this[_readPackageJson](dest + '/package.json').then(pkg => this[_exeBins](pkg, dest)).then(() => result));\n  }\n\n  [_tarballFromResolved]() {\n    // create a read stream and return it\n    return new fsm.ReadStream(this.resolved);\n  }\n\n  packument() {\n    // simulate based on manifest\n    return this.manifest().then(mani => ({\n      name: mani.name,\n      'dist-tags': {\n        [this.defaultTag]: mani.version\n      },\n      versions: {\n        [mani.version]: { ...mani,\n          dist: {\n            tarball: `file:${this.resolved}`,\n            integrity: this.integrity && String(this.integrity)\n          }\n        }\n      }\n    }));\n  }\n\n}\n\nmodule.exports = FileFetcher;","map":null,"metadata":{},"sourceType":"script"}