{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.scheduleByTarget = exports.scheduleByName = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst api_1 = require(\"./api\");\n\nconst progressSchema = require('./progress-schema.json');\n\nlet _uniqueId = 0;\n\nfunction scheduleByName(_x, _x2, _x3) {\n  return _scheduleByName.apply(this, arguments);\n}\n\nfunction _scheduleByName() {\n  _scheduleByName = _asyncToGenerator(function* (name, buildOptions, options) {\n    const childLoggerName = options.target ? `{${(0, api_1.targetStringFromTarget)(options.target)}}` : name;\n    const logger = options.logger.createChild(childLoggerName);\n    const job = options.scheduler.schedule(name, {});\n    let stateSubscription;\n    const workspaceRoot = yield options.workspaceRoot;\n    const currentDirectory = yield options.currentDirectory;\n    const description = yield job.description.toPromise();\n    const info = description.info;\n    const id = ++_uniqueId;\n    const message = {\n      id,\n      currentDirectory,\n      workspaceRoot,\n      info: info,\n      options: buildOptions,\n      ...(options.target ? {\n        target: options.target\n      } : {})\n    }; // Wait for the job to be ready.\n\n    if (job.state !== core_1.experimental.jobs.JobState.Started) {\n      stateSubscription = job.outboundBus.subscribe(event => {\n        if (event.kind === core_1.experimental.jobs.JobOutboundMessageKind.Start) {\n          job.input.next(message);\n        }\n      }, () => {});\n    } else {\n      job.input.next(message);\n    }\n\n    const logChannelSub = job.getChannel('log').subscribe(entry => {\n      logger.next(entry);\n    }, () => {});\n    const s = job.outboundBus.subscribe({\n      error() {},\n\n      complete() {\n        s.unsubscribe();\n        logChannelSub.unsubscribe();\n\n        if (stateSubscription) {\n          stateSubscription.unsubscribe();\n        }\n      }\n\n    });\n    const output = job.output.pipe((0, operators_1.map)(output => ({ ...output,\n      ...(options.target ? {\n        target: options.target\n      } : 0),\n      info\n    })), (0, operators_1.shareReplay)()); // If there's an analytics object, take the job channel and report it to the analytics.\n\n    if (options.analytics) {\n      const reporter = new core_1.analytics.AnalyticsReporter(options.analytics);\n      job.getChannel('analytics').subscribe(report => reporter.report(report));\n    } // Start the builder.\n\n\n    output.pipe((0, operators_1.first)()).subscribe({\n      error() {}\n\n    });\n    return {\n      id,\n      info,\n\n      // This is a getter so that it always returns the next output, and not the same one.\n      get result() {\n        return output.pipe((0, operators_1.first)()).toPromise();\n      },\n\n      output,\n      progress: job.getChannel('progress', progressSchema).pipe((0, operators_1.shareReplay)(1)),\n\n      stop() {\n        job.stop();\n        return job.outboundBus.pipe((0, operators_1.ignoreElements)(), (0, operators_1.catchError)(() => rxjs_1.EMPTY)).toPromise();\n      }\n\n    };\n  });\n  return _scheduleByName.apply(this, arguments);\n}\n\nexports.scheduleByName = scheduleByName;\n\nfunction scheduleByTarget(_x4, _x5, _x6) {\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nfunction _scheduleByTarget() {\n  _scheduleByTarget = _asyncToGenerator(function* (target, overrides, options) {\n    return scheduleByName(`{${(0, api_1.targetStringFromTarget)(target)}}`, overrides, { ...options,\n      target,\n      logger: options.logger\n    });\n  });\n  return _scheduleByTarget.apply(this, arguments);\n}\n\nexports.scheduleByTarget = scheduleByTarget;","map":null,"metadata":{},"sourceType":"script"}