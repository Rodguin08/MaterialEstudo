{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readJsonWorkspace = void 0;\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst utils_1 = require(\"../../json/utils\");\n\nconst definitions_1 = require(\"../definitions\");\n\nconst metadata_1 = require(\"./metadata\");\n\nconst utilities_1 = require(\"./utilities\");\n\nconst ANGULAR_WORKSPACE_EXTENSIONS = Object.freeze(['cli', 'defaultProject', 'newProjectRoot', 'schematics']);\nconst ANGULAR_PROJECT_EXTENSIONS = Object.freeze(['cli', 'schematics', 'projectType', 'i18n']);\n\nfunction readJsonWorkspace(_x, _x2) {\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nfunction _readJsonWorkspace() {\n  _readJsonWorkspace = _asyncToGenerator(function* (path, host, options = {}) {\n    var _a, _b;\n\n    const raw = yield host.readFile(path);\n\n    if (raw === undefined) {\n      throw new Error('Unable to read workspace file.');\n    }\n\n    const ast = (0, jsonc_parser_1.parseTree)(raw, undefined, {\n      allowTrailingComma: true,\n      disallowComments: false\n    });\n\n    if ((ast === null || ast === void 0 ? void 0 : ast.type) !== 'object' || !ast.children) {\n      throw new Error('Invalid workspace file - expected JSON object.');\n    } // Version check\n\n\n    const versionNode = (0, jsonc_parser_1.findNodeAtLocation)(ast, ['version']);\n\n    if (!versionNode) {\n      throw new Error('Unknown format - version specifier not found.');\n    }\n\n    const version = versionNode.value;\n\n    if (version !== 1) {\n      throw new Error(`Invalid format version detected - Expected:[ 1 ] Found: [ ${version} ]`);\n    }\n\n    const context = {\n      host,\n      metadata: new metadata_1.JsonWorkspaceMetadata(path, ast, raw),\n      trackChanges: true,\n      unprefixedWorkspaceExtensions: new Set([...ANGULAR_WORKSPACE_EXTENSIONS, ...((_a = options.allowedWorkspaceExtensions) !== null && _a !== void 0 ? _a : [])]),\n      unprefixedProjectExtensions: new Set([...ANGULAR_PROJECT_EXTENSIONS, ...((_b = options.allowedProjectExtensions) !== null && _b !== void 0 ? _b : [])]),\n\n      error(message, _node) {\n        // TODO: Diagnostic reporting support\n        throw new Error(message);\n      },\n\n      warn(message, _node) {\n        // TODO: Diagnostic reporting support\n        // eslint-disable-next-line no-console\n        console.warn(message);\n      }\n\n    };\n    const workspace = parseWorkspace(ast, context);\n    return workspace;\n  });\n  return _readJsonWorkspace.apply(this, arguments);\n}\n\nexports.readJsonWorkspace = readJsonWorkspace;\n\nfunction parseWorkspace(workspaceNode, context) {\n  const jsonMetadata = context.metadata;\n  let projects;\n  let extensions;\n\n  if (!context.trackChanges) {\n    extensions = Object.create(null);\n  } // TODO: `getNodeValue` - looks potentially expensive since it walks the whole tree and instantiates the full object structure each time.\n  // Might be something to look at moving forward to optimize.\n\n\n  const workspaceNodeValue = (0, jsonc_parser_1.getNodeValue)(workspaceNode);\n\n  for (const [name, value] of Object.entries(workspaceNodeValue)) {\n    if (name === '$schema' || name === 'version') {// skip\n    } else if (name === 'projects') {\n      const nodes = (0, jsonc_parser_1.findNodeAtLocation)(workspaceNode, ['projects']);\n\n      if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n        context.error('Invalid \"projects\" field found; expected an object.', value);\n        continue;\n      }\n\n      projects = parseProjectsObject(nodes, context);\n    } else {\n      if (!context.unprefixedWorkspaceExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n        context.warn(`Workspace extension with invalid name (${name}) found.`, name);\n      }\n\n      if (extensions) {\n        extensions[name] = value;\n      }\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges) {\n    collectionListener = (name, newValue) => {\n      jsonMetadata.addChange(['projects', name], newValue, 'project');\n    };\n  }\n\n  const projectCollection = new definitions_1.ProjectDefinitionCollection(projects, collectionListener);\n  return {\n    [metadata_1.JsonWorkspaceSymbol]: jsonMetadata,\n    projects: projectCollection,\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(workspaceNodeValue, {\n      exclude: ['$schema', 'version', 'projects'],\n\n      listener(path, value) {\n        jsonMetadata.addChange(path, value);\n      }\n\n    })\n  };\n}\n\nfunction parseProjectsObject(projectsNode, context) {\n  const projects = Object.create(null);\n\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(projectsNode))) {\n    const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectsNode, [name]);\n\n    if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n      context.warn('Skipping invalid project value; expected an object.', value);\n      continue;\n    }\n\n    projects[name] = parseProject(name, nodes, context);\n  }\n\n  return projects;\n}\n\nfunction parseProject(projectName, projectNode, context) {\n  const jsonMetadata = context.metadata;\n  let targets;\n  let hasTargets = false;\n  let extensions;\n  let properties;\n\n  if (!context.trackChanges) {\n    // If not tracking changes, the parser will store the values directly in standard objects\n    extensions = Object.create(null);\n    properties = Object.create(null);\n  }\n\n  const projectNodeValue = (0, jsonc_parser_1.getNodeValue)(projectNode);\n\n  if (!('root' in projectNodeValue)) {\n    // TODO(alan-agius4): change this to error in v15.\n    context.warn(`Project \"${projectName}\" is missing a required property \"root\". This will become an error in the next major version.`, projectNodeValue);\n  }\n\n  for (const [name, value] of Object.entries(projectNodeValue)) {\n    switch (name) {\n      case 'targets':\n      case 'architect':\n        const nodes = (0, jsonc_parser_1.findNodeAtLocation)(projectNode, [name]);\n\n        if (!(0, utils_1.isJsonObject)(value) || !nodes) {\n          context.error(`Invalid \"${name}\" field found; expected an object.`, value);\n          break;\n        }\n\n        hasTargets = true;\n        targets = parseTargetsObject(projectName, nodes, context);\n        jsonMetadata.hasLegacyTargetsName = name === 'architect';\n        break;\n\n      case 'prefix':\n      case 'root':\n      case 'sourceRoot':\n        if (typeof value !== 'string') {\n          context.warn(`Project property \"${name}\" should be a string.`, value);\n        }\n\n        if (properties) {\n          properties[name] = value;\n        }\n\n        break;\n\n      default:\n        if (!context.unprefixedProjectExtensions.has(name) && !/^[a-z]{1,3}-.*/.test(name)) {\n          context.warn(`Project extension with invalid name (${name}) found.`, name);\n        }\n\n        if (extensions) {\n          extensions[name] = value;\n        }\n\n        break;\n    }\n  }\n\n  let collectionListener;\n\n  if (context.trackChanges) {\n    collectionListener = (name, newValue, collection) => {\n      if (hasTargets) {\n        jsonMetadata.addChange(['projects', projectName, 'targets', name], newValue, 'target');\n      } else {\n        jsonMetadata.addChange(['projects', projectName, 'targets'], collection, 'targetcollection');\n      }\n    };\n  }\n\n  const base = {\n    targets: new definitions_1.TargetDefinitionCollection(targets, collectionListener),\n    // If not tracking changes the `extensions` variable will contain the parsed\n    // values.  Otherwise the extensions are tracked via a virtual AST object.\n    extensions: extensions !== null && extensions !== void 0 ? extensions : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n      exclude: ['architect', 'prefix', 'root', 'sourceRoot', 'targets'],\n\n      listener(path, value) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n\n    })\n  };\n  const baseKeys = new Set(Object.keys(base));\n  const project = properties !== null && properties !== void 0 ? properties : (0, utilities_1.createVirtualAstObject)(projectNodeValue, {\n    include: ['prefix', 'root', 'sourceRoot', ...baseKeys],\n\n    listener(path, value) {\n      if (!baseKeys.has(path[0])) {\n        jsonMetadata.addChange(['projects', projectName, ...path], value);\n      }\n    }\n\n  });\n  return Object.assign(project, base);\n}\n\nfunction parseTargetsObject(projectName, targetsNode, context) {\n  const jsonMetadata = context.metadata;\n  const targets = Object.create(null);\n\n  for (const [name, value] of Object.entries((0, jsonc_parser_1.getNodeValue)(targetsNode))) {\n    if (!(0, utils_1.isJsonObject)(value)) {\n      context.warn('Skipping invalid target value; expected an object.', value);\n      continue;\n    }\n\n    if (context.trackChanges) {\n      targets[name] = (0, utilities_1.createVirtualAstObject)(value, {\n        include: ['builder', 'options', 'configurations', 'defaultConfiguration'],\n\n        listener(path, value) {\n          jsonMetadata.addChange(['projects', projectName, 'targets', name, ...path], value);\n        }\n\n      });\n    } else {\n      targets[name] = value;\n    }\n  }\n\n  return targets;\n}","map":null,"metadata":{},"sourceType":"script"}