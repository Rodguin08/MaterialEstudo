{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchematicEngine = exports.TaskScheduler = exports.CollectionImpl = exports.UnknownTaskDependencyException = exports.UnregisteredTaskException = exports.SchematicEngineConflictingException = exports.PrivateSchematicException = exports.UnknownSchematicException = exports.CircularCollectionException = exports.UnknownCollectionException = exports.UnknownUrlSourceProtocol = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nconst null_1 = require(\"../tree/null\");\n\nconst static_1 = require(\"../tree/static\");\n\nconst schematic_1 = require(\"./schematic\");\n\nclass UnknownUrlSourceProtocol extends core_1.BaseException {\n  constructor(url) {\n    super(`Unknown Protocol on url \"${url}\".`);\n  }\n\n}\n\nexports.UnknownUrlSourceProtocol = UnknownUrlSourceProtocol;\n\nclass UnknownCollectionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Unknown collection \"${name}\".`);\n  }\n\n}\n\nexports.UnknownCollectionException = UnknownCollectionException;\n\nclass CircularCollectionException extends core_1.BaseException {\n  constructor(name) {\n    super(`Circular collection reference \"${name}\".`);\n  }\n\n}\n\nexports.CircularCollectionException = CircularCollectionException;\n\nclass UnknownSchematicException extends core_1.BaseException {\n  constructor(name, collection) {\n    super(`Schematic \"${name}\" not found in collection \"${collection.name}\".`);\n  }\n\n}\n\nexports.UnknownSchematicException = UnknownSchematicException;\n\nclass PrivateSchematicException extends core_1.BaseException {\n  constructor(name, collection) {\n    super(`Schematic \"${name}\" not found in collection \"${collection.name}\".`);\n  }\n\n}\n\nexports.PrivateSchematicException = PrivateSchematicException;\n\nclass SchematicEngineConflictingException extends core_1.BaseException {\n  constructor() {\n    super(`A schematic was called from a different engine as its parent.`);\n  }\n\n}\n\nexports.SchematicEngineConflictingException = SchematicEngineConflictingException;\n\nclass UnregisteredTaskException extends core_1.BaseException {\n  constructor(name, schematic) {\n    const addendum = schematic ? ` in schematic \"${schematic.name}\"` : '';\n    super(`Unregistered task \"${name}\"${addendum}.`);\n  }\n\n}\n\nexports.UnregisteredTaskException = UnregisteredTaskException;\n\nclass UnknownTaskDependencyException extends core_1.BaseException {\n  constructor(id) {\n    super(`Unknown task dependency [ID: ${id.id}].`);\n  }\n\n}\n\nexports.UnknownTaskDependencyException = UnknownTaskDependencyException;\n\nclass CollectionImpl {\n  constructor(_description, _engine, baseDescriptions) {\n    this._description = _description;\n    this._engine = _engine;\n    this.baseDescriptions = baseDescriptions;\n  }\n\n  get description() {\n    return this._description;\n  }\n\n  get name() {\n    return this.description.name || '<unknown>';\n  }\n\n  createSchematic(name, allowPrivate = false) {\n    return this._engine.createSchematic(name, this, allowPrivate);\n  }\n\n  listSchematicNames(includeHidden) {\n    return this._engine.listSchematicNames(this, includeHidden);\n  }\n\n}\n\nexports.CollectionImpl = CollectionImpl;\n\nclass TaskScheduler {\n  constructor(_context) {\n    this._context = _context;\n    this._queue = new core_1.PriorityQueue((x, y) => x.priority - y.priority);\n    this._taskIds = new Map();\n  }\n\n  _calculatePriority(dependencies) {\n    if (dependencies.size === 0) {\n      return 0;\n    }\n\n    const prio = [...dependencies].reduce((prio, task) => prio + task.priority, 1);\n    return prio;\n  }\n\n  _mapDependencies(dependencies) {\n    if (!dependencies) {\n      return new Set();\n    }\n\n    const tasks = dependencies.map(dep => {\n      const task = this._taskIds.get(dep);\n\n      if (!task) {\n        throw new UnknownTaskDependencyException(dep);\n      }\n\n      return task;\n    });\n    return new Set(tasks);\n  }\n\n  schedule(taskConfiguration) {\n    const dependencies = this._mapDependencies(taskConfiguration.dependencies);\n\n    const priority = this._calculatePriority(dependencies);\n\n    const task = {\n      id: TaskScheduler._taskIdCounter++,\n      priority,\n      configuration: taskConfiguration,\n      context: this._context\n    };\n\n    this._queue.push(task);\n\n    const id = {\n      id: task.id\n    };\n\n    this._taskIds.set(id, task);\n\n    return id;\n  }\n\n  finalize() {\n    const tasks = this._queue.toArray();\n\n    this._queue.clear();\n\n    this._taskIds.clear();\n\n    return tasks;\n  }\n\n}\n\nexports.TaskScheduler = TaskScheduler;\nTaskScheduler._taskIdCounter = 1;\n\nclass SchematicEngine {\n  constructor(_host, _workflow) {\n    this._host = _host;\n    this._workflow = _workflow;\n    this._collectionCache = new Map();\n    this._schematicCache = new WeakMap();\n    this._taskSchedulers = new Array();\n  }\n\n  get workflow() {\n    return this._workflow || null;\n  }\n\n  get defaultMergeStrategy() {\n    return this._host.defaultMergeStrategy || interface_1.MergeStrategy.Default;\n  }\n\n  createCollection(name, requester) {\n    let collection = this._collectionCache.get(name);\n\n    if (collection) {\n      return collection;\n    }\n\n    const [description, bases] = this._createCollectionDescription(name, requester === null || requester === void 0 ? void 0 : requester.description);\n\n    collection = new CollectionImpl(description, this, bases);\n\n    this._collectionCache.set(name, collection);\n\n    this._schematicCache.set(collection, new Map());\n\n    return collection;\n  }\n\n  _createCollectionDescription(name, requester, parentNames) {\n    const description = this._host.createCollectionDescription(name, requester);\n\n    if (!description) {\n      throw new UnknownCollectionException(name);\n    }\n\n    if (parentNames && parentNames.has(description.name)) {\n      throw new CircularCollectionException(name);\n    }\n\n    const bases = new Array();\n\n    if (description.extends) {\n      parentNames = (parentNames || new Set()).add(description.name);\n\n      for (const baseName of description.extends) {\n        const [base, baseBases] = this._createCollectionDescription(baseName, description, new Set(parentNames));\n\n        bases.unshift(base, ...baseBases);\n      }\n    }\n\n    return [description, bases];\n  }\n\n  createContext(schematic, parent, executionOptions) {\n    // Check for inconsistencies.\n    if (parent && parent.engine && parent.engine !== this) {\n      throw new SchematicEngineConflictingException();\n    }\n\n    let interactive = true;\n\n    if (executionOptions && executionOptions.interactive != undefined) {\n      interactive = executionOptions.interactive;\n    } else if (parent && parent.interactive != undefined) {\n      interactive = parent.interactive;\n    }\n\n    let context = {\n      debug: parent && parent.debug || false,\n      engine: this,\n      logger: parent && parent.logger && parent.logger.createChild(schematic.description.name) || new core_1.logging.NullLogger(),\n      schematic,\n      strategy: parent && parent.strategy !== undefined ? parent.strategy : this.defaultMergeStrategy,\n      interactive,\n      addTask\n    };\n\n    const maybeNewContext = this._host.transformContext(context);\n\n    if (maybeNewContext) {\n      context = maybeNewContext;\n    }\n\n    const taskScheduler = new TaskScheduler(context);\n    const host = this._host;\n\n    this._taskSchedulers.push(taskScheduler);\n\n    function addTask(task, dependencies) {\n      const config = task.toConfiguration();\n\n      if (!host.hasTaskExecutor(config.name)) {\n        throw new UnregisteredTaskException(config.name, schematic.description);\n      }\n\n      config.dependencies = config.dependencies || [];\n\n      if (dependencies) {\n        config.dependencies.unshift(...dependencies);\n      }\n\n      return taskScheduler.schedule(config);\n    }\n\n    return context;\n  }\n\n  createSchematic(name, collection, allowPrivate = false) {\n    const schematicMap = this._schematicCache.get(collection);\n\n    let schematic = schematicMap === null || schematicMap === void 0 ? void 0 : schematicMap.get(name);\n\n    if (schematic) {\n      return schematic;\n    }\n\n    let collectionDescription = collection.description;\n\n    let description = this._host.createSchematicDescription(name, collection.description);\n\n    if (!description) {\n      if (collection.baseDescriptions) {\n        for (const base of collection.baseDescriptions) {\n          description = this._host.createSchematicDescription(name, base);\n\n          if (description) {\n            collectionDescription = base;\n            break;\n          }\n        }\n      }\n\n      if (!description) {\n        // Report the error for the top level schematic collection\n        throw new UnknownSchematicException(name, collection.description);\n      }\n    }\n\n    if (description.private && !allowPrivate) {\n      throw new PrivateSchematicException(name, collection.description);\n    }\n\n    const factory = this._host.getSchematicRuleFactory(description, collectionDescription);\n\n    schematic = new schematic_1.SchematicImpl(description, factory, collection, this);\n    schematicMap === null || schematicMap === void 0 ? void 0 : schematicMap.set(name, schematic);\n    return schematic;\n  }\n\n  listSchematicNames(collection, includeHidden) {\n    const names = this._host.listSchematicNames(collection.description, includeHidden);\n\n    if (collection.baseDescriptions) {\n      for (const base of collection.baseDescriptions) {\n        names.push(...this._host.listSchematicNames(base, includeHidden));\n      }\n    } // remove duplicates\n\n\n    return [...new Set(names)].sort();\n  }\n\n  transformOptions(schematic, options, context) {\n    return this._host.transformOptions(schematic.description, options, context);\n  }\n\n  createSourceFromUrl(url, context) {\n    switch (url.protocol) {\n      case 'null:':\n        return () => new null_1.NullTree();\n\n      case 'empty:':\n        return () => (0, static_1.empty)();\n\n      default:\n        const hostSource = this._host.createSourceFromUrl(url, context);\n\n        if (!hostSource) {\n          throw new UnknownUrlSourceProtocol(url.toString());\n        }\n\n        return hostSource;\n    }\n  }\n\n  executePostTasks() {\n    const executors = new Map();\n    const taskObservable = (0, rxjs_1.from)(this._taskSchedulers).pipe((0, operators_1.concatMap)(scheduler => scheduler.finalize()), (0, operators_1.concatMap)(task => {\n      const {\n        name,\n        options\n      } = task.configuration;\n      const executor = executors.get(name);\n\n      if (executor) {\n        return executor(options, task.context);\n      }\n\n      return this._host.createTaskExecutor(name).pipe((0, operators_1.concatMap)(executor => {\n        executors.set(name, executor);\n        return executor(options, task.context);\n      }));\n    }));\n    return taskObservable;\n  }\n\n}\n\nexports.SchematicEngine = SchematicEngine;","map":null,"metadata":{},"sourceType":"script"}