{"ast":null,"code":"const readWasm = require(\"../lib/read-wasm\");\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\n\n\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n  cachedWasm = readWasm().then(buffer => {\n    return WebAssembly.instantiate(buffer, {\n      env: {\n        mapping_callback(generatedLine, generatedColumn, hasLastGeneratedColumn, lastGeneratedColumn, hasOriginal, source, originalLine, originalColumn, hasName, name) {\n          const mapping = new Mapping(); // JS uses 1-based line numbers, wasm uses 0-based.\n\n          mapping.generatedLine = generatedLine + 1;\n          mapping.generatedColumn = generatedColumn;\n\n          if (hasLastGeneratedColumn) {\n            // JS uses inclusive last generated column, wasm uses exclusive.\n            mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n          }\n\n          if (hasOriginal) {\n            mapping.source = source; // JS uses 1-based line numbers, wasm uses 0-based.\n\n            mapping.originalLine = originalLine + 1;\n            mapping.originalColumn = originalColumn;\n\n            if (hasName) {\n              mapping.name = name;\n            }\n          }\n\n          callbackStack[callbackStack.length - 1](mapping);\n        },\n\n        start_all_generated_locations_for() {\n          console.time(\"all_generated_locations_for\");\n        },\n\n        end_all_generated_locations_for() {\n          console.timeEnd(\"all_generated_locations_for\");\n        },\n\n        start_compute_column_spans() {\n          console.time(\"compute_column_spans\");\n        },\n\n        end_compute_column_spans() {\n          console.timeEnd(\"compute_column_spans\");\n        },\n\n        start_generated_location_for() {\n          console.time(\"generated_location_for\");\n        },\n\n        end_generated_location_for() {\n          console.timeEnd(\"generated_location_for\");\n        },\n\n        start_original_location_for() {\n          console.time(\"original_location_for\");\n        },\n\n        end_original_location_for() {\n          console.timeEnd(\"original_location_for\");\n        },\n\n        start_parse_mappings() {\n          console.time(\"parse_mappings\");\n        },\n\n        end_parse_mappings() {\n          console.timeEnd(\"parse_mappings\");\n        },\n\n        start_sort_by_generated_location() {\n          console.time(\"sort_by_generated_location\");\n        },\n\n        end_sort_by_generated_location() {\n          console.timeEnd(\"sort_by_generated_location\");\n        },\n\n        start_sort_by_original_location() {\n          console.time(\"sort_by_original_location\");\n        },\n\n        end_sort_by_original_location() {\n          console.timeEnd(\"sort_by_original_location\");\n        }\n\n      }\n    });\n  }).then(Wasm => {\n    return {\n      exports: Wasm.instance.exports,\n      withMappingCallback: (mappingCallback, f) => {\n        callbackStack.push(mappingCallback);\n\n        try {\n          f();\n        } finally {\n          callbackStack.pop();\n        }\n      }\n    };\n  }).then(null, e => {\n    cachedWasm = null;\n    throw e;\n  });\n  return cachedWasm;\n};","map":null,"metadata":{},"sourceType":"script"}