{"ast":null,"code":"const Minipass = require('minipass');\n\nconst EE = require('events');\n\nconst isStream = s => s && s instanceof EE && (typeof s.pipe === 'function' || // readable\ntypeof s.write === 'function' && typeof s.end === 'function' // writable\n);\n\nconst _head = Symbol('_head');\n\nconst _tail = Symbol('_tail');\n\nconst _linkStreams = Symbol('_linkStreams');\n\nconst _setHead = Symbol('_setHead');\n\nconst _setTail = Symbol('_setTail');\n\nconst _onError = Symbol('_onError');\n\nconst _onData = Symbol('_onData');\n\nconst _onEnd = Symbol('_onEnd');\n\nconst _onDrain = Symbol('_onDrain');\n\nconst _streams = Symbol('_streams');\n\nclass Pipeline extends Minipass {\n  constructor(opts, ...streams) {\n    if (isStream(opts)) {\n      streams.unshift(opts);\n      opts = {};\n    }\n\n    super(opts);\n    this[_streams] = [];\n    if (streams.length) this.push(...streams);\n  }\n\n  [_linkStreams](streams) {\n    // reduce takes (left,right), and we return right to make it the\n    // new left value.\n    return streams.reduce((src, dest) => {\n      src.on('error', er => dest.emit('error', er));\n      src.pipe(dest);\n      return dest;\n    });\n  }\n\n  push(...streams) {\n    this[_streams].push(...streams);\n\n    if (this[_tail]) streams.unshift(this[_tail]);\n\n    const linkRet = this[_linkStreams](streams);\n\n    this[_setTail](linkRet);\n\n    if (!this[_head]) this[_setHead](streams[0]);\n  }\n\n  unshift(...streams) {\n    this[_streams].unshift(...streams);\n\n    if (this[_head]) streams.push(this[_head]);\n\n    const linkRet = this[_linkStreams](streams);\n\n    this[_setHead](streams[0]);\n\n    if (!this[_tail]) this[_setTail](linkRet);\n  }\n\n  destroy(er) {\n    // set fire to the whole thing.\n    this[_streams].forEach(s => typeof s.destroy === 'function' && s.destroy());\n\n    return super.destroy(er);\n  } // readable interface -> tail\n\n\n  [_setTail](stream) {\n    this[_tail] = stream;\n    stream.on('error', er => this[_onError](stream, er));\n    stream.on('data', chunk => this[_onData](stream, chunk));\n    stream.on('end', () => this[_onEnd](stream));\n    stream.on('finish', () => this[_onEnd](stream));\n  } // errors proxied down the pipeline\n  // they're considered part of the \"read\" interface\n\n\n  [_onError](stream, er) {\n    if (stream === this[_tail]) this.emit('error', er);\n  }\n\n  [_onData](stream, chunk) {\n    if (stream === this[_tail]) super.write(chunk);\n  }\n\n  [_onEnd](stream) {\n    if (stream === this[_tail]) super.end();\n  }\n\n  pause() {\n    super.pause();\n    return this[_tail] && this[_tail].pause && this[_tail].pause();\n  } // NB: Minipass calls its internal private [RESUME] method during\n  // pipe drains, to avoid hazards where stream.resume() is overridden.\n  // Thus, we need to listen to the resume *event*, not override the\n  // resume() method, and proxy *that* to the tail.\n\n\n  emit(ev, ...args) {\n    if (ev === 'resume' && this[_tail] && this[_tail].resume) this[_tail].resume();\n    return super.emit(ev, ...args);\n  } // writable interface -> head\n\n\n  [_setHead](stream) {\n    this[_head] = stream;\n    stream.on('drain', () => this[_onDrain](stream));\n  }\n\n  [_onDrain](stream) {\n    if (stream === this[_head]) this.emit('drain');\n  }\n\n  write(chunk, enc, cb) {\n    return this[_head].write(chunk, enc, cb) && (this.flowing || this.buffer.length === 0);\n  }\n\n  end(chunk, enc, cb) {\n    this[_head].end(chunk, enc, cb);\n\n    return this;\n  }\n\n}\n\nmodule.exports = Pipeline;","map":null,"metadata":{},"sourceType":"script"}