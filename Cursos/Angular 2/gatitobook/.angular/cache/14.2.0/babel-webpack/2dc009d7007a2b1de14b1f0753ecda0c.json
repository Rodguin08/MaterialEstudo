{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  Request,\n  Response\n} = require('minipass-fetch');\n\nconst Minipass = require('minipass');\n\nconst MinipassFlush = require('minipass-flush');\n\nconst cacache = require('cacache');\n\nconst url = require('url');\n\nconst CachingMinipassPipeline = require('../pipeline.js');\n\nconst CachePolicy = require('./policy.js');\n\nconst cacheKey = require('./key.js');\n\nconst remote = require('../remote.js');\n\nconst hasOwnProperty = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop); // allow list for request headers that will be written to the cache index\n// note: we will also store any request headers\n// that are named in a response's vary header\n\n\nconst KEEP_REQUEST_HEADERS = ['accept-charset', 'accept-encoding', 'accept-language', 'accept', 'cache-control']; // allow list for response headers that will be written to the cache index\n// note: we must not store the real response's age header, or when we load\n// a cache policy based on the metadata it will think the cached response\n// is always stale\n\nconst KEEP_RESPONSE_HEADERS = ['cache-control', 'content-encoding', 'content-language', 'content-type', 'date', 'etag', 'expires', 'last-modified', 'link', 'location', 'pragma', 'vary']; // return an object containing all metadata to be written to the index\n\nconst getMetadata = (request, response, options) => {\n  const metadata = {\n    time: Date.now(),\n    url: request.url,\n    reqHeaders: {},\n    resHeaders: {},\n    // options on which we must match the request and vary the response\n    options: {\n      compress: options.compress != null ? options.compress : request.compress\n    }\n  }; // only save the status if it's not a 200 or 304\n\n  if (response.status !== 200 && response.status !== 304) {\n    metadata.status = response.status;\n  }\n\n  for (const name of KEEP_REQUEST_HEADERS) {\n    if (request.headers.has(name)) {\n      metadata.reqHeaders[name] = request.headers.get(name);\n    }\n  } // if the request's host header differs from the host in the url\n  // we need to keep it, otherwise it's just noise and we ignore it\n\n\n  const host = request.headers.get('host');\n  const parsedUrl = new url.URL(request.url);\n\n  if (host && parsedUrl.host !== host) {\n    metadata.reqHeaders.host = host;\n  } // if the response has a vary header, make sure\n  // we store the relevant request headers too\n\n\n  if (response.headers.has('vary')) {\n    const vary = response.headers.get('vary'); // a vary of \"*\" means every header causes a different response.\n    // in that scenario, we do not include any additional headers\n    // as the freshness check will always fail anyway and we don't\n    // want to bloat the cache indexes\n\n    if (vary !== '*') {\n      // copy any other request headers that will vary the response\n      const varyHeaders = vary.trim().toLowerCase().split(/\\s*,\\s*/);\n\n      for (const name of varyHeaders) {\n        if (request.headers.has(name)) {\n          metadata.reqHeaders[name] = request.headers.get(name);\n        }\n      }\n    }\n  }\n\n  for (const name of KEEP_RESPONSE_HEADERS) {\n    if (response.headers.has(name)) {\n      metadata.resHeaders[name] = response.headers.get(name);\n    }\n  }\n\n  return metadata;\n}; // symbols used to hide objects that may be lazily evaluated in a getter\n\n\nconst _request = Symbol('request');\n\nconst _response = Symbol('response');\n\nconst _policy = Symbol('policy');\n\nclass CacheEntry {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    if (entry) {\n      this.key = entry.key;\n      this.entry = entry; // previous versions of this module didn't write an explicit timestamp in\n      // the metadata, so fall back to the entry's timestamp. we can't use the\n      // entry timestamp to determine staleness because cacache will update it\n      // when it verifies its data\n\n      this.entry.metadata.time = this.entry.metadata.time || this.entry.time;\n    } else {\n      this.key = cacheKey(request);\n    }\n\n    this.options = options; // these properties are behind getters that lazily evaluate\n\n    this[_request] = request;\n    this[_response] = response;\n    this[_policy] = null;\n  } // returns a CacheEntry instance that satisfies the given request\n  // or undefined if no existing entry satisfies\n\n\n  static find(request, options) {\n    return _asyncToGenerator(function* () {\n      try {\n        // compacts the index and returns an array of unique entries\n        var matches = yield cacache.index.compact(options.cachePath, cacheKey(request), (A, B) => {\n          const entryA = new CacheEntry({\n            entry: A,\n            options\n          });\n          const entryB = new CacheEntry({\n            entry: B,\n            options\n          });\n          return entryA.policy.satisfies(entryB.request);\n        }, {\n          validateEntry: entry => {\n            // clean out entries with a buggy content-encoding value\n            if (entry.metadata && entry.metadata.resHeaders && entry.metadata.resHeaders['content-encoding'] === null) {\n              return false;\n            } // if an integrity is null, it needs to have a status specified\n\n\n            if (entry.integrity === null) {\n              return !!(entry.metadata && entry.metadata.status);\n            }\n\n            return true;\n          }\n        });\n      } catch (err) {\n        // if the compact request fails, ignore the error and return\n        return;\n      } // a cache mode of 'reload' means to behave as though we have no cache\n      // on the way to the network. return undefined to allow cacheFetch to\n      // create a brand new request no matter what.\n\n\n      if (options.cache === 'reload') {\n        return;\n      } // find the specific entry that satisfies the request\n\n\n      let match;\n\n      for (const entry of matches) {\n        const _entry = new CacheEntry({\n          entry,\n          options\n        });\n\n        if (_entry.policy.satisfies(request)) {\n          match = _entry;\n          break;\n        }\n      }\n\n      return match;\n    })();\n  } // if the user made a PUT/POST/PATCH then we invalidate our\n  // cache for the same url by deleting the index entirely\n\n\n  static invalidate(request, options) {\n    return _asyncToGenerator(function* () {\n      const key = cacheKey(request);\n\n      try {\n        yield cacache.rm.entry(options.cachePath, key, {\n          removeFully: true\n        });\n      } catch (err) {// ignore errors\n      }\n    })();\n  }\n\n  get request() {\n    if (!this[_request]) {\n      this[_request] = new Request(this.entry.metadata.url, {\n        method: 'GET',\n        headers: this.entry.metadata.reqHeaders,\n        ...this.entry.metadata.options\n      });\n    }\n\n    return this[_request];\n  }\n\n  get response() {\n    if (!this[_response]) {\n      this[_response] = new Response(null, {\n        url: this.entry.metadata.url,\n        counter: this.options.counter,\n        status: this.entry.metadata.status || 200,\n        headers: { ...this.entry.metadata.resHeaders,\n          'content-length': this.entry.size\n        }\n      });\n    }\n\n    return this[_response];\n  }\n\n  get policy() {\n    if (!this[_policy]) {\n      this[_policy] = new CachePolicy({\n        entry: this.entry,\n        request: this.request,\n        response: this.response,\n        options: this.options\n      });\n    }\n\n    return this[_policy];\n  } // wraps the response in a pipeline that stores the data\n  // in the cache while the user consumes it\n\n\n  store(status) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      // if we got a status other than 200, 301, or 308,\n      // or the CachePolicy forbid storage, append the\n      // cache status header and return it untouched\n      if (_this.request.method !== 'GET' || ![200, 301, 308].includes(_this.response.status) || !_this.policy.storable()) {\n        _this.response.headers.set('x-local-cache-status', 'skip');\n\n        return _this.response;\n      }\n\n      const size = _this.response.headers.get('content-length');\n\n      const cacheOpts = {\n        algorithms: _this.options.algorithms,\n        metadata: getMetadata(_this.request, _this.response, _this.options),\n        size,\n        integrity: _this.options.integrity,\n        integrityEmitter: _this.response.body.hasIntegrityEmitter && _this.response.body\n      };\n      let body = null; // we only set a body if the status is a 200, redirects are\n      // stored as metadata only\n\n      if (_this.response.status === 200) {\n        let cacheWriteResolve, cacheWriteReject;\n        const cacheWritePromise = new Promise((resolve, reject) => {\n          cacheWriteResolve = resolve;\n          cacheWriteReject = reject;\n        });\n        body = new CachingMinipassPipeline({\n          events: ['integrity', 'size']\n        }, new MinipassFlush({\n          flush() {\n            return cacheWritePromise;\n          }\n\n        })); // this is always true since if we aren't reusing the one from the remote fetch, we\n        // are using the one from cacache\n\n        body.hasIntegrityEmitter = true;\n\n        const onResume = () => {\n          const tee = new Minipass();\n          const cacheStream = cacache.put.stream(_this.options.cachePath, _this.key, cacheOpts); // re-emit the integrity and size events on our new response body so they can be reused\n\n          cacheStream.on('integrity', i => body.emit('integrity', i));\n          cacheStream.on('size', s => body.emit('size', s)); // stick a flag on here so downstream users will know if they can expect integrity events\n\n          tee.pipe(cacheStream); // TODO if the cache write fails, log a warning but return the response anyway\n          // eslint-disable-next-line promise/catch-or-return\n\n          cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n          body.unshift(tee);\n          body.unshift(_this.response.body);\n        };\n\n        body.once('resume', onResume);\n        body.once('end', () => body.removeListener('resume', onResume));\n      } else {\n        yield cacache.index.insert(_this.options.cachePath, _this.key, null, cacheOpts);\n      } // note: we do not set the x-local-cache-hash header because we do not know\n      // the hash value until after the write to the cache completes, which doesn't\n      // happen until after the response has been sent and it's too late to write\n      // the header anyway\n\n\n      _this.response.headers.set('x-local-cache', encodeURIComponent(_this.options.cachePath));\n\n      _this.response.headers.set('x-local-cache-key', encodeURIComponent(_this.key));\n\n      _this.response.headers.set('x-local-cache-mode', 'stream');\n\n      _this.response.headers.set('x-local-cache-status', status);\n\n      _this.response.headers.set('x-local-cache-time', new Date().toISOString());\n\n      const newResponse = new Response(body, {\n        url: _this.response.url,\n        status: _this.response.status,\n        headers: _this.response.headers,\n        counter: _this.options.counter\n      });\n      return newResponse;\n    })();\n  } // use the cached data to create a response and return it\n\n\n  respond(method, options, status) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let response;\n\n      if (method === 'HEAD' || [301, 308].includes(_this2.response.status)) {\n        // if the request is a HEAD, or the response is a redirect,\n        // then the metadata in the entry already includes everything\n        // we need to build a response\n        response = _this2.response;\n      } else {\n        // we're responding with a full cached response, so create a body\n        // that reads from cacache and attach it to a new Response\n        const body = new Minipass();\n        const headers = { ..._this2.policy.responseHeaders()\n        };\n\n        const onResume = () => {\n          const cacheStream = cacache.get.stream.byDigest(_this2.options.cachePath, _this2.entry.integrity, {\n            memoize: _this2.options.memoize\n          });\n          cacheStream.on('error', /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (err) {\n              cacheStream.pause();\n\n              if (err.code === 'EINTEGRITY') {\n                yield cacache.rm.content(_this2.options.cachePath, _this2.entry.integrity, {\n                  memoize: _this2.options.memoize\n                });\n              }\n\n              if (err.code === 'ENOENT' || err.code === 'EINTEGRITY') {\n                yield CacheEntry.invalidate(_this2.request, _this2.options);\n              }\n\n              body.emit('error', err);\n              cacheStream.resume();\n            });\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()); // emit the integrity and size events based on our metadata so we're consistent\n\n          body.emit('integrity', _this2.entry.integrity);\n          body.emit('size', Number(headers['content-length']));\n          cacheStream.pipe(body);\n        };\n\n        body.once('resume', onResume);\n        body.once('end', () => body.removeListener('resume', onResume));\n        response = new Response(body, {\n          url: _this2.entry.metadata.url,\n          counter: options.counter,\n          status: 200,\n          headers\n        });\n      }\n\n      response.headers.set('x-local-cache', encodeURIComponent(_this2.options.cachePath));\n      response.headers.set('x-local-cache-hash', encodeURIComponent(_this2.entry.integrity));\n      response.headers.set('x-local-cache-key', encodeURIComponent(_this2.key));\n      response.headers.set('x-local-cache-mode', 'stream');\n      response.headers.set('x-local-cache-status', status);\n      response.headers.set('x-local-cache-time', new Date(_this2.entry.metadata.time).toUTCString());\n      return response;\n    })();\n  } // use the provided request along with this cache entry to\n  // revalidate the stored response. returns a response, either\n  // from the cache or from the update\n\n\n  revalidate(request, options) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const revalidateRequest = new Request(request, {\n        headers: _this3.policy.revalidationHeaders(request)\n      });\n\n      try {\n        // NOTE: be sure to remove the headers property from the\n        // user supplied options, since we have already defined\n        // them on the new request object. if they're still in the\n        // options then those will overwrite the ones from the policy\n        var response = yield remote(revalidateRequest, { ...options,\n          headers: undefined\n        });\n      } catch (err) {\n        // if the network fetch fails, return the stale\n        // cached response unless it has a cache-control\n        // of 'must-revalidate'\n        if (!_this3.policy.mustRevalidate) {\n          return _this3.respond(request.method, options, 'stale');\n        }\n\n        throw err;\n      }\n\n      if (_this3.policy.revalidated(revalidateRequest, response)) {\n        // we got a 304, write a new index to the cache and respond from cache\n        const metadata = getMetadata(request, response, options); // 304 responses do not include headers that are specific to the response data\n        // since they do not include a body, so we copy values for headers that were\n        // in the old cache entry to the new one, if the new metadata does not already\n        // include that header\n\n        for (const name of KEEP_RESPONSE_HEADERS) {\n          if (!hasOwnProperty(metadata.resHeaders, name) && hasOwnProperty(_this3.entry.metadata.resHeaders, name)) {\n            metadata.resHeaders[name] = _this3.entry.metadata.resHeaders[name];\n          }\n        }\n\n        try {\n          yield cacache.index.insert(options.cachePath, _this3.key, _this3.entry.integrity, {\n            size: _this3.entry.size,\n            metadata\n          });\n        } catch (err) {// if updating the cache index fails, we ignore it and\n          // respond anyway\n        }\n\n        return _this3.respond(request.method, options, 'revalidated');\n      } // if we got a modified response, create a new entry based on it\n\n\n      const newEntry = new CacheEntry({\n        request,\n        response,\n        options\n      }); // respond with the new entry while writing it to the cache\n\n      return newEntry.store('updated');\n    })();\n  }\n\n}\n\nmodule.exports = CacheEntry;","map":null,"metadata":{},"sourceType":"script"}