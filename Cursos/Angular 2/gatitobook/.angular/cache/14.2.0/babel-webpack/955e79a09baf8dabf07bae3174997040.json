{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Minipass = require('minipass');\n\nconst fetch = require('minipass-fetch');\n\nconst promiseRetry = require('promise-retry');\n\nconst ssri = require('ssri');\n\nconst CachingMinipassPipeline = require('./pipeline.js');\n\nconst getAgent = require('./agent.js');\n\nconst pkg = require('../package.json');\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\n\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  }\n\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT);\n  } // keep our own options since we're overriding the agent\n  // and the redirect mode\n\n\n  const _opts = { ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (retryHandler, attemptNum) {\n      const req = new fetch.Request(request, _opts);\n\n      try {\n        let res = yield fetch(req, _opts);\n\n        if (_opts.integrity && res.status === 200) {\n          // we got a 200 response and the user has specified an expected\n          // integrity value, so wrap the response in an ssri stream to verify it\n          const integrityStream = ssri.integrityStream({\n            algorithms: _opts.algorithms,\n            integrity: _opts.integrity,\n            size: _opts.size\n          });\n          const pipeline = new CachingMinipassPipeline({\n            events: ['integrity', 'size']\n          }, res.body, integrityStream); // we also propagate the integrity and size events out to the pipeline so we can use\n          // this new response body as an integrityEmitter for cacache\n\n          integrityStream.on('integrity', i => pipeline.emit('integrity', i));\n          integrityStream.on('size', s => pipeline.emit('size', s));\n          res = new fetch.Response(pipeline, res); // set an explicit flag so we know if our response body will emit integrity and size\n\n          res.body.hasIntegrityEmitter = true;\n        }\n\n        res.headers.set('x-fetch-attempts', attemptNum); // do not retry POST requests, or requests with a streaming body\n        // do retry requests with a 408, 420, 429 or 500+ status in the response\n\n        const isStream = Minipass.isStream(req.body);\n        const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n\n        if (isRetriable) {\n          if (typeof options.onRetry === 'function') {\n            options.onRetry(res);\n          }\n\n          return retryHandler(res);\n        }\n\n        return res;\n      } catch (err) {\n        const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code; // err.retried will be the thing that was thrown from above\n        // if it's a response, we just got a bad status code and we\n        // can re-throw to allow the retry\n\n        const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n\n        if (req.method === 'POST' || isRetryError) {\n          throw err;\n        }\n\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(err);\n        }\n\n        return retryHandler(err);\n      }\n    });\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err;\n    }\n\n    throw err;\n  });\n};\n\nmodule.exports = remoteFetch;","map":null,"metadata":{},"sourceType":"script"}