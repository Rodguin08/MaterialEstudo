{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Collect = require('minipass-collect');\n\nconst Minipass = require('minipass');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst index = require('./entry-index');\n\nconst memo = require('./memoization');\n\nconst read = require('./content/read');\n\nfunction getData(_x, _x2) {\n  return _getData.apply(this, arguments);\n}\n\nfunction _getData() {\n  _getData = _asyncToGenerator(function* (cache, key, opts = {}) {\n    const {\n      integrity,\n      memoize,\n      size\n    } = opts;\n    const memoized = memo.get(cache, key, opts);\n\n    if (memoized && memoize !== false) {\n      return {\n        metadata: memoized.entry.metadata,\n        data: memoized.data,\n        integrity: memoized.entry.integrity,\n        size: memoized.entry.size\n      };\n    }\n\n    const entry = yield index.find(cache, key, opts);\n\n    if (!entry) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    const data = yield read(cache, entry.integrity, {\n      integrity,\n      size\n    });\n\n    if (memoize) {\n      memo.put(cache, entry, data, opts);\n    }\n\n    return {\n      data,\n      metadata: entry.metadata,\n      size: entry.size,\n      integrity: entry.integrity\n    };\n  });\n  return _getData.apply(this, arguments);\n}\n\nmodule.exports = getData;\n\nfunction getDataByDigest(_x3, _x4) {\n  return _getDataByDigest.apply(this, arguments);\n}\n\nfunction _getDataByDigest() {\n  _getDataByDigest = _asyncToGenerator(function* (cache, key, opts = {}) {\n    const {\n      integrity,\n      memoize,\n      size\n    } = opts;\n    const memoized = memo.get.byDigest(cache, key, opts);\n\n    if (memoized && memoize !== false) {\n      return memoized;\n    }\n\n    const res = yield read(cache, key, {\n      integrity,\n      size\n    });\n\n    if (memoize) {\n      memo.put.byDigest(cache, key, res, opts);\n    }\n\n    return res;\n  });\n  return _getDataByDigest.apply(this, arguments);\n}\n\nmodule.exports.byDigest = getDataByDigest;\n\nfunction getDataSync(cache, key, opts = {}) {\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return {\n      metadata: memoized.entry.metadata,\n      data: memoized.data,\n      integrity: memoized.entry.integrity,\n      size: memoized.entry.size\n    };\n  }\n\n  const entry = index.find.sync(cache, key, opts);\n\n  if (!entry) {\n    throw new index.NotFoundError(cache, key);\n  }\n\n  const data = read.sync(cache, entry.integrity, {\n    integrity: integrity,\n    size: size\n  });\n  const res = {\n    metadata: entry.metadata,\n    data: data,\n    size: entry.size,\n    integrity: entry.integrity\n  };\n\n  if (memoize) {\n    memo.put(cache, entry, res.data, opts);\n  }\n\n  return res;\n}\n\nmodule.exports.sync = getDataSync;\n\nfunction getDataByDigestSync(cache, digest, opts = {}) {\n  const {\n    integrity,\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get.byDigest(cache, digest, opts);\n\n  if (memoized && memoize !== false) {\n    return memoized;\n  }\n\n  const res = read.sync(cache, digest, {\n    integrity: integrity,\n    size: size\n  });\n\n  if (memoize) {\n    memo.put.byDigest(cache, digest, res, opts);\n  }\n\n  return res;\n}\n\nmodule.exports.sync.byDigest = getDataByDigestSync;\n\nconst getMemoizedStream = memoized => {\n  const stream = new Minipass();\n  stream.on('newListener', function (ev, cb) {\n    ev === 'metadata' && cb(memoized.entry.metadata);\n    ev === 'integrity' && cb(memoized.entry.integrity);\n    ev === 'size' && cb(memoized.entry.size);\n  });\n  stream.end(memoized.data);\n  return stream;\n};\n\nfunction getStream(cache, key, opts = {}) {\n  const {\n    memoize,\n    size\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return getMemoizedStream(memoized);\n  }\n\n  const stream = new Pipeline(); // Set all this up to run on the stream and then just return the stream\n\n  Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n    const entry = yield index.find(cache, key);\n\n    if (!entry) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    stream.emit('metadata', entry.metadata);\n    stream.emit('integrity', entry.integrity);\n    stream.emit('size', entry.size);\n    stream.on('newListener', function (ev, cb) {\n      ev === 'metadata' && cb(entry.metadata);\n      ev === 'integrity' && cb(entry.integrity);\n      ev === 'size' && cb(entry.size);\n    });\n    const src = read.readStream(cache, entry.integrity, { ...opts,\n      size: typeof size !== 'number' ? entry.size : size\n    });\n\n    if (memoize) {\n      const memoStream = new Collect.PassThrough();\n      memoStream.on('collect', data => memo.put(cache, entry, data, opts));\n      stream.unshift(memoStream);\n    }\n\n    stream.unshift(src);\n    return stream;\n  })).catch(err => stream.emit('error', err));\n  return stream;\n}\n\nmodule.exports.stream = getStream;\n\nfunction getStreamDigest(cache, integrity, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get.byDigest(cache, integrity, opts);\n\n  if (memoized && memoize !== false) {\n    const stream = new Minipass();\n    stream.end(memoized);\n    return stream;\n  } else {\n    const stream = read.readStream(cache, integrity, opts);\n\n    if (!memoize) {\n      return stream;\n    }\n\n    const memoStream = new Collect.PassThrough();\n    memoStream.on('collect', data => memo.put.byDigest(cache, integrity, data, opts));\n    return new Pipeline(stream, memoStream);\n  }\n}\n\nmodule.exports.stream.byDigest = getStreamDigest;\n\nfunction info(cache, key, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  const memoized = memo.get(cache, key, opts);\n\n  if (memoized && memoize !== false) {\n    return Promise.resolve(memoized.entry);\n  } else {\n    return index.find(cache, key);\n  }\n}\n\nmodule.exports.info = info;\n\nfunction copy(_x5, _x6, _x7) {\n  return _copy.apply(this, arguments);\n}\n\nfunction _copy() {\n  _copy = _asyncToGenerator(function* (cache, key, dest, opts = {}) {\n    const entry = yield index.find(cache, key, opts);\n\n    if (!entry) {\n      throw new index.NotFoundError(cache, key);\n    }\n\n    yield read.copy(cache, entry.integrity, dest, opts);\n    return {\n      metadata: entry.metadata,\n      size: entry.size,\n      integrity: entry.integrity\n    };\n  });\n  return _copy.apply(this, arguments);\n}\n\nmodule.exports.copy = copy;\n\nfunction copyByDigest(_x8, _x9, _x10) {\n  return _copyByDigest.apply(this, arguments);\n}\n\nfunction _copyByDigest() {\n  _copyByDigest = _asyncToGenerator(function* (cache, key, dest, opts = {}) {\n    yield read.copy(cache, key, dest, opts);\n    return key;\n  });\n  return _copyByDigest.apply(this, arguments);\n}\n\nmodule.exports.copy.byDigest = copyByDigest;\nmodule.exports.hasContent = read.hasContent;","map":null,"metadata":{},"sourceType":"script"}