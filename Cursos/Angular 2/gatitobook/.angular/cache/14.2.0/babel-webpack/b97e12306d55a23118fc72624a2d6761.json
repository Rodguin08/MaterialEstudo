{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleMemoryHost = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst exception_1 = require(\"../../exception\");\n\nconst path_1 = require(\"../path\");\n\nclass SimpleMemoryHost {\n  constructor() {\n    this._cache = new Map();\n    this._watchers = new Map();\n\n    this._cache.set((0, path_1.normalize)('/'), this._newDirStats());\n  }\n\n  _newDirStats() {\n    return {\n      inspect() {\n        return '<Directory>';\n      },\n\n      isFile() {\n        return false;\n      },\n\n      isDirectory() {\n        return true;\n      },\n\n      size: 0,\n      atime: new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: new Date(),\n      content: null\n    };\n  }\n\n  _newFileStats(content, oldStats) {\n    return {\n      inspect() {\n        return `<File size(${content.byteLength})>`;\n      },\n\n      isFile() {\n        return true;\n      },\n\n      isDirectory() {\n        return false;\n      },\n\n      size: content.byteLength,\n      atime: oldStats ? oldStats.atime : new Date(),\n      ctime: new Date(),\n      mtime: new Date(),\n      birthtime: oldStats ? oldStats.birthtime : new Date(),\n      content\n    };\n  }\n\n  _toAbsolute(path) {\n    return (0, path_1.isAbsolute)(path) ? path : (0, path_1.normalize)('/' + path);\n  }\n\n  _updateWatchers(path, type) {\n    const time = new Date();\n    let currentPath = path;\n    let parent = null;\n\n    if (this._watchers.size == 0) {\n      // Nothing to do if there's no watchers.\n      return;\n    }\n\n    const maybeWatcher = this._watchers.get(currentPath);\n\n    if (maybeWatcher) {\n      maybeWatcher.forEach(watcher => {\n        const [options, subject] = watcher;\n        subject.next({\n          path,\n          time,\n          type\n        });\n\n        if (!options.persistent && type == 2\n        /* HostWatchEventType.Deleted */\n        ) {\n          subject.complete();\n\n          this._watchers.delete(currentPath);\n        }\n      });\n    }\n\n    do {\n      currentPath = parent !== null ? parent : currentPath;\n      parent = (0, path_1.dirname)(currentPath);\n\n      const maybeWatcher = this._watchers.get(currentPath);\n\n      if (maybeWatcher) {\n        maybeWatcher.forEach(watcher => {\n          const [options, subject] = watcher;\n\n          if (!options.recursive) {\n            return;\n          }\n\n          subject.next({\n            path,\n            time,\n            type\n          });\n\n          if (!options.persistent && type == 2\n          /* HostWatchEventType.Deleted */\n          ) {\n            subject.complete();\n\n            this._watchers.delete(currentPath);\n          }\n        });\n      }\n    } while (parent != currentPath);\n  }\n\n  get capabilities() {\n    return {\n      synchronous: true\n    };\n  }\n  /**\n   * List of protected methods that give direct access outside the observables to the cache\n   * and internal states.\n   */\n\n\n  _write(path, content) {\n    path = this._toAbsolute(path);\n\n    const old = this._cache.get(path);\n\n    if (old && old.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } // Update all directories. If we find a file we know it's an invalid write.\n\n\n    const fragments = (0, path_1.split)(path);\n    let curr = (0, path_1.normalize)('/');\n\n    for (const fr of fragments) {\n      curr = (0, path_1.join)(curr, fr);\n\n      const maybeStats = this._cache.get(fr);\n\n      if (maybeStats) {\n        if (maybeStats.isFile()) {\n          throw new exception_1.PathIsFileException(curr);\n        }\n      } else {\n        this._cache.set(curr, this._newDirStats());\n      }\n    } // Create the stats.\n\n\n    const stats = this._newFileStats(content, old);\n\n    this._cache.set(path, stats);\n\n    this._updateWatchers(path, old ? 0\n    /* HostWatchEventType.Changed */\n    : 1\n    /* HostWatchEventType.Created */\n    );\n  }\n\n  _read(path) {\n    path = this._toAbsolute(path);\n\n    const maybeStats = this._cache.get(path);\n\n    if (!maybeStats) {\n      throw new exception_1.FileDoesNotExistException(path);\n    } else if (maybeStats.isDirectory()) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else if (!maybeStats.content) {\n      throw new exception_1.PathIsDirectoryException(path);\n    } else {\n      return maybeStats.content;\n    }\n  }\n\n  _delete(path) {\n    path = this._toAbsolute(path);\n\n    if (this._isDirectory(path)) {\n      for (const [cachePath] of this._cache.entries()) {\n        if (cachePath.startsWith(path + path_1.NormalizedSep) || cachePath === path) {\n          this._cache.delete(cachePath);\n        }\n      }\n    } else {\n      this._cache.delete(path);\n    }\n\n    this._updateWatchers(path, 2\n    /* HostWatchEventType.Deleted */\n    );\n  }\n\n  _rename(from, to) {\n    from = this._toAbsolute(from);\n    to = this._toAbsolute(to);\n\n    if (!this._cache.has(from)) {\n      throw new exception_1.FileDoesNotExistException(from);\n    } else if (this._cache.has(to)) {\n      throw new exception_1.FileAlreadyExistException(to);\n    }\n\n    if (this._isDirectory(from)) {\n      for (const path of this._cache.keys()) {\n        if (path.startsWith(from + path_1.NormalizedSep)) {\n          const content = this._cache.get(path);\n\n          if (content) {\n            // We don't need to clone or extract the content, since we're moving files.\n            this._cache.set((0, path_1.join)(to, path_1.NormalizedSep, path.slice(from.length)), content);\n          }\n        }\n      }\n    } else {\n      const content = this._cache.get(from);\n\n      if (content) {\n        const fragments = (0, path_1.split)(to);\n        const newDirectories = [];\n        let curr = (0, path_1.normalize)('/');\n\n        for (const fr of fragments) {\n          curr = (0, path_1.join)(curr, fr);\n\n          const maybeStats = this._cache.get(fr);\n\n          if (maybeStats) {\n            if (maybeStats.isFile()) {\n              throw new exception_1.PathIsFileException(curr);\n            }\n          } else {\n            newDirectories.push(curr);\n          }\n        }\n\n        for (const newDirectory of newDirectories) {\n          this._cache.set(newDirectory, this._newDirStats());\n        }\n\n        this._cache.delete(from);\n\n        this._cache.set(to, content);\n      }\n    }\n\n    this._updateWatchers(from, 3\n    /* HostWatchEventType.Renamed */\n    );\n  }\n\n  _list(path) {\n    path = this._toAbsolute(path);\n\n    if (this._isFile(path)) {\n      throw new exception_1.PathIsFileException(path);\n    }\n\n    const fragments = (0, path_1.split)(path);\n    const result = new Set();\n\n    if (path !== path_1.NormalizedRoot) {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path + path_1.NormalizedSep)) {\n          result.add((0, path_1.split)(p)[fragments.length]);\n        }\n      }\n    } else {\n      for (const p of this._cache.keys()) {\n        if (p.startsWith(path_1.NormalizedSep) && p !== path_1.NormalizedRoot) {\n          result.add((0, path_1.split)(p)[1]);\n        }\n      }\n    }\n\n    return [...result];\n  }\n\n  _exists(path) {\n    return !!this._cache.get(this._toAbsolute(path));\n  }\n\n  _isDirectory(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    return maybeStats ? maybeStats.isDirectory() : false;\n  }\n\n  _isFile(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    return maybeStats ? maybeStats.isFile() : false;\n  }\n\n  _stat(path) {\n    const maybeStats = this._cache.get(this._toAbsolute(path));\n\n    if (!maybeStats) {\n      return null;\n    } else {\n      return maybeStats;\n    }\n  }\n\n  _watch(path, options) {\n    path = this._toAbsolute(path);\n    const subject = new rxjs_1.Subject();\n\n    let maybeWatcherArray = this._watchers.get(path);\n\n    if (!maybeWatcherArray) {\n      maybeWatcherArray = [];\n\n      this._watchers.set(path, maybeWatcherArray);\n    }\n\n    maybeWatcherArray.push([options || {}, subject]);\n    return subject.asObservable();\n  }\n\n  write(path, content) {\n    return new rxjs_1.Observable(obs => {\n      this._write(path, content);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  read(path) {\n    return new rxjs_1.Observable(obs => {\n      const content = this._read(path);\n\n      obs.next(content);\n      obs.complete();\n    });\n  }\n\n  delete(path) {\n    return new rxjs_1.Observable(obs => {\n      this._delete(path);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  rename(from, to) {\n    return new rxjs_1.Observable(obs => {\n      this._rename(from, to);\n\n      obs.next();\n      obs.complete();\n    });\n  }\n\n  list(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._list(path));\n      obs.complete();\n    });\n  }\n\n  exists(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._exists(path));\n      obs.complete();\n    });\n  }\n\n  isDirectory(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isDirectory(path));\n      obs.complete();\n    });\n  }\n\n  isFile(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._isFile(path));\n      obs.complete();\n    });\n  } // Some hosts may not support stat.\n\n\n  stat(path) {\n    return new rxjs_1.Observable(obs => {\n      obs.next(this._stat(path));\n      obs.complete();\n    });\n  }\n\n  watch(path, options) {\n    return this._watch(path, options);\n  }\n\n  reset() {\n    this._cache.clear();\n\n    this._watchers.clear();\n  }\n\n}\n\nexports.SimpleMemoryHost = SimpleMemoryHost;","map":null,"metadata":{},"sourceType":"script"}