{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nconst normPath = require('./normalize-windows-path.js');\n\nclass SymlinkError extends Error {\n  constructor(symlink, path) {\n    super('Cannot extract through symbolic link');\n    this.path = path;\n    this.symlink = symlink;\n  }\n\n  get name() {\n    return 'SylinkError';\n  }\n\n}\n\nclass CwdError extends Error {\n  constructor(path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'');\n    this.path = path;\n    this.code = code;\n  }\n\n  get name() {\n    return 'CwdError';\n  }\n\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key));\n\nconst cSet = (cache, key, val) => cache.set(normPath(key), val);\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n    cb(er);\n  });\n};\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = normPath(opt.cwd);\n\n  const done = (er, created) => {\n    if (er) cb(er);else {\n      cSet(cache, dir, true);\n      if (created && doChown) chownr(created, uid, gid, er => done(er));else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n  if (dir === cwd) return checkCwd(dir, done);\n  if (preserve) return mkdirp(dir, {\n    mode\n  }).then(made => done(null, made), done);\n  const sub = normPath(path.relative(cwd, dir));\n  const parts = sub.split('/');\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) return cb(null, created);\n  const p = parts.shift();\n  const part = normPath(path.resolve(base + '/' + p));\n  if (cGet(cache, part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path);\n        cb(statEr);\n      } else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) return cb(er);\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n        });\n      } else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n    });\n  } else {\n    created = created || part;\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  }\n};\n\nconst checkCwdSync = dir => {\n  let ok = false;\n  let code = 'ENOTDIR';\n\n  try {\n    ok = fs.statSync(dir).isDirectory();\n  } catch (er) {\n    code = er.code;\n  } finally {\n    if (!ok) throw new CwdError(dir, code);\n  }\n};\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir); // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n\n  const umask = opt.umask;\n  const mode = opt.mode | 0o0700;\n  const needChmod = (mode & umask) !== 0;\n  const uid = opt.uid;\n  const gid = opt.gid;\n  const doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  const preserve = opt.preserve;\n  const unlink = opt.unlink;\n  const cache = opt.cache;\n  const cwd = normPath(opt.cwd);\n\n  const done = created => {\n    cSet(cache, dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cGet(cache, dir) === true) return done();\n\n  if (dir === cwd) {\n    checkCwdSync(cwd);\n    return done();\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  const sub = normPath(path.relative(cwd, dir));\n  const parts = sub.split('/');\n  let created = null;\n\n  for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    part = normPath(path.resolve(part));\n    if (cGet(cache, part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cSet(cache, part, true);\n    } catch (er) {\n      const st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cSet(cache, part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cSet(cache, part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":null,"metadata":{},"sourceType":"script"}