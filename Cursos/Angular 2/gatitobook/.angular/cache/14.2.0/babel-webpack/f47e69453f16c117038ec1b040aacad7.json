{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AddCommandModule = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst tools_1 = /*#__PURE__*/require(\"@angular-devkit/schematics/tools\");\n\nconst npm_package_arg_1 = __importDefault( /*#__PURE__*/require(\"npm-package-arg\"));\n\nconst path_1 = /*#__PURE__*/require(\"path\");\n\nconst semver_1 = /*#__PURE__*/require(\"semver\");\n\nconst workspace_schema_1 = /*#__PURE__*/require(\"../../../lib/config/workspace-schema\");\n\nconst analytics_1 = /*#__PURE__*/require(\"../../analytics/analytics\");\n\nconst schematics_command_module_1 = /*#__PURE__*/require(\"../../command-builder/schematics-command-module\");\n\nconst color_1 = /*#__PURE__*/require(\"../../utilities/color\");\n\nconst error_1 = /*#__PURE__*/require(\"../../utilities/error\");\n\nconst package_metadata_1 = /*#__PURE__*/require(\"../../utilities/package-metadata\");\n\nconst prompt_1 = /*#__PURE__*/require(\"../../utilities/prompt\");\n\nconst spinner_1 = /*#__PURE__*/require(\"../../utilities/spinner\");\n\nconst tty_1 = /*#__PURE__*/require(\"../../utilities/tty\");\n/**\n * The set of packages that should have certain versions excluded from consideration\n * when attempting to find a compatible version for a package.\n * The key is a package name and the value is a SemVer range of versions to exclude.\n */\n\n\nconst packageVersionExclusions = {\n  // @angular/localize@9.x versions do not have peer dependencies setup\n  '@angular/localize': '9.x'\n};\n\nclass AddCommandModule extends schematics_command_module_1.SchematicsCommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'add <collection>';\n    this.describe = 'Adds support for an external library to your project.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n    this.allowPrivateSchematics = true;\n    this.schematicName = 'ng-add';\n  }\n\n  builder(argv) {\n    var _superprop_getBuilder = () => super.builder,\n        _this = this;\n\n    return _asyncToGenerator(function* () {\n      const localYargs = (yield _superprop_getBuilder().call(_this, argv)).positional('collection', {\n        description: 'The package to be added.',\n        type: 'string',\n        demandOption: true\n      }).option('registry', {\n        description: 'The NPM registry to use.',\n        type: 'string'\n      }).option('verbose', {\n        description: 'Display additional details about internal operations during execution.',\n        type: 'boolean',\n        default: false\n      }).option('skip-confirmation', {\n        description: 'Skip asking a confirmation prompt before installing and executing the package. ' + 'Ensure package name is correct prior to using this option.',\n        type: 'boolean',\n        default: false\n      }) // Prior to downloading we don't know the full schema and therefore we cannot be strict on the options.\n      // Possibly in the future update the logic to use the following syntax:\n      // `ng add @angular/localize -- --package-options`.\n      .strict(false);\n      const collectionName = yield _this.getCollectionName();\n      const workflow = yield _this.getOrCreateWorkflowForBuilder(collectionName);\n\n      try {\n        const collection = workflow.engine.createCollection(collectionName);\n        const options = yield _this.getSchematicOptions(collection, _this.schematicName, workflow);\n        return _this.addSchemaOptionsToCommand(localYargs, options);\n      } catch (error) {// During `ng add` prior to the downloading of the package\n        // we are not able to resolve and create a collection.\n        // Or when the the collection value is a path to a tarball.\n      }\n\n      return localYargs;\n    })();\n  } // eslint-disable-next-line max-lines-per-function\n\n\n  run(options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        logger,\n        packageManager\n      } = _this2.context;\n      const {\n        verbose,\n        registry,\n        collection,\n        skipConfirmation\n      } = options;\n      packageManager.ensureCompatibility();\n      let packageIdentifier;\n\n      try {\n        packageIdentifier = (0, npm_package_arg_1.default)(collection);\n      } catch (e) {\n        (0, error_1.assertIsError)(e);\n        logger.error(e.message);\n        return 1;\n      }\n\n      if (packageIdentifier.name && packageIdentifier.registry && _this2.isPackageInstalled(packageIdentifier.name)) {\n        const validVersion = yield _this2.isProjectVersionValid(packageIdentifier);\n\n        if (validVersion) {\n          // Already installed so just run schematic\n          logger.info('Skipping installation: Package already installed');\n          return _this2.executeSchematic({ ...options,\n            collection: packageIdentifier.name\n          });\n        }\n      }\n\n      const spinner = new spinner_1.Spinner();\n      spinner.start('Determining package manager...');\n      const usingYarn = packageManager.name === workspace_schema_1.PackageManager.Yarn;\n      spinner.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n\n      if (packageIdentifier.name && packageIdentifier.type === 'tag' && !packageIdentifier.rawSpec) {\n        // only package name provided; search for viable version\n        // plus special cases for packages that did not have peer deps setup\n        spinner.start('Searching for compatible package version...');\n        let packageMetadata;\n\n        try {\n          packageMetadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageIdentifier.name, logger, {\n            registry,\n            usingYarn,\n            verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          spinner.fail(`Unable to load package information from registry: ${e.message}`);\n          return 1;\n        } // Start with the version tagged as `latest` if it exists\n\n\n        const latestManifest = packageMetadata.tags['latest'];\n\n        if (latestManifest) {\n          packageIdentifier = npm_package_arg_1.default.resolve(latestManifest.name, latestManifest.version);\n        } // Adjust the version based on name and peer dependencies\n\n\n        if ((latestManifest === null || latestManifest === void 0 ? void 0 : latestManifest.peerDependencies) && Object.keys(latestManifest.peerDependencies).length === 0) {\n          spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n        } else if (!latestManifest || (yield _this2.hasMismatchedPeer(latestManifest))) {\n          // 'latest' is invalid so search for most recent matching package\n          const versionExclusions = packageVersionExclusions[packageMetadata.name];\n          const versionManifests = Object.values(packageMetadata.versions).filter(value => {\n            // Prerelease versions are not stable and should not be considered by default\n            if ((0, semver_1.prerelease)(value.version)) {\n              return false;\n            } // Deprecated versions should not be used or considered\n\n\n            if (value.deprecated) {\n              return false;\n            } // Excluded package versions should not be considered\n\n\n            if (versionExclusions && (0, semver_1.satisfies)(value.version, versionExclusions)) {\n              return false;\n            }\n\n            return true;\n          });\n          versionManifests.sort((a, b) => (0, semver_1.compare)(a.version, b.version, true));\n          let newIdentifier;\n\n          for (const versionManifest of versionManifests) {\n            if (!(yield _this2.hasMismatchedPeer(versionManifest))) {\n              newIdentifier = npm_package_arg_1.default.resolve(versionManifest.name, versionManifest.version);\n              break;\n            }\n          }\n\n          if (!newIdentifier) {\n            spinner.warn(\"Unable to find compatible package. Using 'latest' tag.\");\n          } else {\n            packageIdentifier = newIdentifier;\n            spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n          }\n        } else {\n          spinner.succeed(`Found compatible package version: ${color_1.colors.grey(packageIdentifier.toString())}.`);\n        }\n      }\n\n      let collectionName = packageIdentifier.name;\n      let savePackage;\n\n      try {\n        spinner.start('Loading package information from registry...');\n        const manifest = yield (0, package_metadata_1.fetchPackageManifest)(packageIdentifier.toString(), logger, {\n          registry,\n          verbose,\n          usingYarn\n        });\n        savePackage = (_a = manifest['ng-add']) === null || _a === void 0 ? void 0 : _a.save;\n        collectionName = manifest.name;\n\n        if (yield _this2.hasMismatchedPeer(manifest)) {\n          spinner.warn('Package has unmet peer dependencies. Adding the package may not succeed.');\n        } else {\n          spinner.succeed(`Package information loaded.`);\n        }\n      } catch (e) {\n        (0, error_1.assertIsError)(e);\n        spinner.fail(`Unable to fetch package information for '${packageIdentifier}': ${e.message}`);\n        return 1;\n      }\n\n      if (!skipConfirmation) {\n        const confirmationResponse = yield (0, prompt_1.askConfirmation)(`\\nThe package ${color_1.colors.blue(packageIdentifier.raw)} will be installed and executed.\\n` + 'Would you like to proceed?', true, false);\n\n        if (!confirmationResponse) {\n          if (!(0, tty_1.isTTY)()) {\n            logger.error('No terminal detected. ' + `'--skip-confirmation' can be used to bypass installation confirmation. ` + `Ensure package name is correct prior to '--skip-confirmation' option usage.`);\n          }\n\n          logger.error('Command aborted.');\n          return 1;\n        }\n      }\n\n      if (savePackage === false) {\n        // Temporary packages are located in a different directory\n        // Hence we need to resolve them using the temp path\n        const {\n          success,\n          tempNodeModules\n        } = yield packageManager.installTemp(packageIdentifier.raw, registry ? [`--registry=\"${registry}\"`] : undefined);\n\n        const resolvedCollectionPath = require.resolve((0, path_1.join)(collectionName, 'package.json'), {\n          paths: [tempNodeModules]\n        });\n\n        if (!success) {\n          return 1;\n        }\n\n        collectionName = (0, path_1.dirname)(resolvedCollectionPath);\n      } else {\n        const success = yield packageManager.install(packageIdentifier.raw, savePackage, registry ? [`--registry=\"${registry}\"`] : undefined);\n\n        if (!success) {\n          return 1;\n        }\n      }\n\n      return _this2.executeSchematic({ ...options,\n        collection: collectionName\n      });\n    })();\n  }\n\n  isProjectVersionValid(packageIdentifier) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      if (!packageIdentifier.name) {\n        return false;\n      }\n\n      let validVersion = false;\n      const installedVersion = yield _this3.findProjectVersion(packageIdentifier.name);\n\n      if (installedVersion) {\n        if (packageIdentifier.type === 'range' && packageIdentifier.fetchSpec) {\n          validVersion = (0, semver_1.satisfies)(installedVersion, packageIdentifier.fetchSpec);\n        } else if (packageIdentifier.type === 'version') {\n          const v1 = (0, semver_1.valid)(packageIdentifier.fetchSpec);\n          const v2 = (0, semver_1.valid)(installedVersion);\n          validVersion = v1 !== null && v1 === v2;\n        } else if (!packageIdentifier.rawSpec) {\n          validVersion = true;\n        }\n      }\n\n      return validVersion;\n    })();\n  }\n\n  reportAnalytics(options, paths) {\n    var _superprop_getReportAnalytics = () => super.reportAnalytics,\n        _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const collection = yield _this4.getCollectionName();\n      const dimensions = []; // Add the collection if it's safe listed.\n\n      if (collection && (0, analytics_1.isPackageNameSafeForAnalytics)(collection)) {\n        dimensions[core_1.analytics.NgCliAnalyticsDimensions.NgAddCollection] = collection;\n      }\n\n      return _superprop_getReportAnalytics().call(_this4, options, paths, dimensions);\n    })();\n  }\n\n  getCollectionName() {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const [, collectionName] = _this5.context.args.positional;\n      return collectionName;\n    })();\n  }\n\n  isPackageInstalled(name) {\n    try {\n      require.resolve((0, path_1.join)(name, 'package.json'), {\n        paths: [this.context.root]\n      });\n\n      return true;\n    } catch (e) {\n      (0, error_1.assertIsError)(e);\n\n      if (e.code !== 'MODULE_NOT_FOUND') {\n        throw e;\n      }\n    }\n\n    return false;\n  }\n\n  executeSchematic(options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const {\n          verbose,\n          skipConfirmation,\n          interactive,\n          force,\n          dryRun,\n          registry,\n          defaults,\n          collection: collectionName,\n          ...schematicOptions\n        } = options;\n        return yield _this6.runSchematic({\n          schematicOptions,\n          schematicName: _this6.schematicName,\n          collectionName,\n          executionOptions: {\n            interactive,\n            force,\n            dryRun,\n            defaults,\n            packageRegistry: registry\n          }\n        });\n      } catch (e) {\n        if (e instanceof tools_1.NodePackageDoesNotSupportSchematics) {\n          _this6.context.logger.error(core_1.tags.oneLine`\n          The package that you are trying to add does not support schematics. You can try using\n          a different version of the package or contact the package author to add ng-add support.\n        `);\n\n          return 1;\n        }\n\n        throw e;\n      }\n    })();\n  }\n\n  findProjectVersion(name) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        logger,\n        root\n      } = _this7.context;\n      let installedPackage;\n\n      try {\n        installedPackage = require.resolve((0, path_1.join)(name, 'package.json'), {\n          paths: [root]\n        });\n      } catch {}\n\n      if (installedPackage) {\n        try {\n          const installed = yield (0, package_metadata_1.fetchPackageManifest)((0, path_1.dirname)(installedPackage), logger);\n          return installed.version;\n        } catch {}\n      }\n\n      let projectManifest;\n\n      try {\n        projectManifest = yield (0, package_metadata_1.fetchPackageManifest)(root, logger);\n      } catch {}\n\n      if (projectManifest) {\n        const version = ((_a = projectManifest.dependencies) === null || _a === void 0 ? void 0 : _a[name]) || ((_b = projectManifest.devDependencies) === null || _b === void 0 ? void 0 : _b[name]);\n\n        if (version) {\n          return version;\n        }\n      }\n\n      return null;\n    })();\n  }\n\n  hasMismatchedPeer(manifest) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      for (const peer in manifest.peerDependencies) {\n        let peerIdentifier;\n\n        try {\n          peerIdentifier = npm_package_arg_1.default.resolve(peer, manifest.peerDependencies[peer]);\n        } catch {\n          _this8.context.logger.warn(`Invalid peer dependency ${peer} found in package.`);\n\n          continue;\n        }\n\n        if (peerIdentifier.type === 'version' || peerIdentifier.type === 'range') {\n          try {\n            const version = yield _this8.findProjectVersion(peer);\n\n            if (!version) {\n              continue;\n            }\n\n            const options = {\n              includePrerelease: true\n            };\n\n            if (!(0, semver_1.intersects)(version, peerIdentifier.rawSpec, options) && !(0, semver_1.satisfies)(version, peerIdentifier.rawSpec, options)) {\n              return true;\n            }\n          } catch {\n            // Not found or invalid so ignore\n            continue;\n          }\n        } else {// type === 'tag' | 'file' | 'directory' | 'remote' | 'git'\n          // Cannot accurately compare these as the tag/location may have changed since install\n        }\n      }\n\n      return false;\n    })();\n  }\n\n}\n\nexports.AddCommandModule = AddCommandModule;","map":null,"metadata":{},"sourceType":"script"}