{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PartiallyOrderedSet = exports.CircularDependencyFoundException = exports.DependencyNotFoundException = void 0;\n\nconst exception_1 = require(\"../exception\");\n\nclass DependencyNotFoundException extends exception_1.BaseException {\n  constructor() {\n    super('One of the dependencies is not part of the set.');\n  }\n\n}\n\nexports.DependencyNotFoundException = DependencyNotFoundException;\n\nclass CircularDependencyFoundException extends exception_1.BaseException {\n  constructor() {\n    super('Circular dependencies found.');\n  }\n\n}\n\nexports.CircularDependencyFoundException = CircularDependencyFoundException;\n\nclass PartiallyOrderedSet {\n  constructor() {\n    this._items = new Map();\n  }\n\n  _checkCircularDependencies(item, deps) {\n    if (deps.has(item)) {\n      throw new CircularDependencyFoundException();\n    }\n\n    deps.forEach(dep => this._checkCircularDependencies(item, this._items.get(dep) || new Set()));\n  }\n\n  clear() {\n    this._items.clear();\n  }\n\n  has(item) {\n    return this._items.has(item);\n  }\n\n  get size() {\n    return this._items.size;\n  }\n\n  forEach(callbackfn, thisArg) {\n    for (const x of this) {\n      callbackfn.call(thisArg, x, x, this);\n    }\n  }\n  /**\n   * Returns an iterable of [v,v] pairs for every value `v` in the set.\n   */\n\n\n  *entries() {\n    for (const item of this) {\n      yield [item, item];\n    }\n  }\n  /**\n   * Despite its name, returns an iterable of the values in the set,\n   */\n\n\n  keys() {\n    return this.values();\n  }\n  /**\n   * Returns an iterable of values in the set.\n   */\n\n\n  values() {\n    return this[Symbol.iterator]();\n  }\n\n  add(item, deps = new Set()) {\n    if (Array.isArray(deps)) {\n      deps = new Set(deps);\n    } // Verify item is not already in the set.\n\n\n    if (this._items.has(item)) {\n      const itemDeps = this._items.get(item) || new Set(); // If the dependency list is equal, just return, otherwise remove and keep going.\n\n      let equal = true;\n\n      for (const dep of deps) {\n        if (!itemDeps.has(dep)) {\n          equal = false;\n          break;\n        }\n      }\n\n      if (equal) {\n        for (const dep of itemDeps) {\n          if (!deps.has(dep)) {\n            equal = false;\n            break;\n          }\n        }\n      }\n\n      if (equal) {\n        return this;\n      } else {\n        this._items.delete(item);\n      }\n    } // Verify all dependencies are part of the Set.\n\n\n    for (const dep of deps) {\n      if (!this._items.has(dep)) {\n        throw new DependencyNotFoundException();\n      }\n    } // Verify there's no dependency cycle.\n\n\n    this._checkCircularDependencies(item, deps);\n\n    this._items.set(item, new Set(deps));\n\n    return this;\n  }\n\n  delete(item) {\n    if (!this._items.has(item)) {\n      return false;\n    } // Remove it from all dependencies if force == true.\n\n\n    this._items.forEach(value => value.delete(item));\n\n    return this._items.delete(item);\n  }\n\n  *[Symbol.iterator]() {\n    const copy = new Map(this._items);\n\n    for (const [key, value] of copy.entries()) {\n      copy.set(key, new Set(value));\n    }\n\n    while (copy.size > 0) {\n      const run = []; // Take the first item without dependencies.\n\n      for (const [item, deps] of copy.entries()) {\n        if (deps.size == 0) {\n          run.push(item);\n        }\n      }\n\n      for (const item of run) {\n        copy.forEach(s => s.delete(item));\n        copy.delete(item);\n        yield item;\n      }\n\n      if (run.length == 0) {\n        // uh oh...\n        throw new CircularDependencyFoundException();\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Set';\n  }\n\n}\n\nexports.PartiallyOrderedSet = PartiallyOrderedSet;","map":null,"metadata":{},"sourceType":"script"}