{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('fs');\n\nconst {\n  Readable\n} = require('stream');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst picomatch = require('picomatch');\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst [maj, min] = process.versions.node.split('.').slice(0, 2).map(n => Number.parseInt(n, 10));\nconst wantBigintFsStats = process.platform === 'win32' && (maj > 10 || maj === 10 && min >= 5);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (wantBigintFsStats) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath.resolve(root);\n    this._isDirent = 'Dirent' in fs && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  _read(batch) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this.reading) return;\n      _this.reading = true;\n\n      try {\n        while (!_this.destroyed && batch > 0) {\n          const {\n            path,\n            depth,\n            files = []\n          } = _this.parent || {};\n\n          if (files.length > 0) {\n            const slice = files.splice(0, batch).map(dirent => _this._formatEntry(dirent, path));\n\n            for (const entry of yield Promise.all(slice)) {\n              if (_this.destroyed) return;\n              const entryType = yield _this._getEntryType(entry);\n\n              if (entryType === 'directory' && _this._directoryFilter(entry)) {\n                if (depth <= _this._maxDepth) {\n                  _this.parents.push(_this._exploreDir(entry.fullPath, depth + 1));\n                }\n\n                if (_this._wantsDir) {\n                  _this.push(entry);\n\n                  batch--;\n                }\n              } else if ((entryType === 'file' || _this._includeAsFile(entry)) && _this._fileFilter(entry)) {\n                if (_this._wantsFile) {\n                  _this.push(entry);\n\n                  batch--;\n                }\n              }\n            }\n          } else {\n            const parent = _this.parents.pop();\n\n            if (!parent) {\n              _this.push(null);\n\n              break;\n            }\n\n            _this.parent = yield parent;\n            if (_this.destroyed) return;\n          }\n        }\n      } catch (error) {\n        _this.destroy(error);\n      } finally {\n        _this.reading = false;\n      }\n    })();\n  }\n\n  _exploreDir(path, depth) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      let files;\n\n      try {\n        files = yield readdir(path, _this2._rdOptions);\n      } catch (error) {\n        _this2._onError(error);\n      }\n\n      return {\n        files,\n        depth,\n        path\n      };\n    })();\n  }\n\n  _formatEntry(dirent, path) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      let entry;\n\n      try {\n        const basename = _this3._isDirent ? dirent.name : dirent;\n        const fullPath = sysPath.resolve(sysPath.join(path, basename));\n        entry = {\n          path: sysPath.relative(_this3._root, fullPath),\n          fullPath,\n          basename\n        };\n        entry[_this3._statsProp] = _this3._isDirent ? dirent : yield _this3._stat(fullPath);\n      } catch (err) {\n        _this3._onError(err);\n      }\n\n      return entry;\n    })();\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  _getEntryType(entry) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      // entry may be undefined, because a warning or an error were emitted\n      // and the statsProp is undefined\n      const stats = entry && entry[_this4._statsProp];\n\n      if (!stats) {\n        return;\n      }\n\n      if (stats.isFile()) {\n        return 'file';\n      }\n\n      if (stats.isDirectory()) {\n        return 'directory';\n      }\n\n      if (stats && stats.isSymbolicLink()) {\n        const full = entry.fullPath;\n\n        try {\n          const entryRealPath = yield realpath(full);\n          const entryRealPathStats = yield lstat(entryRealPath);\n\n          if (entryRealPathStats.isFile()) {\n            return 'file';\n          }\n\n          if (entryRealPathStats.isDirectory()) {\n            const len = entryRealPath.length;\n\n            if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {\n              const recursiveError = new Error(`Circular symlink detected: \"${full}\" points to \"${entryRealPath}\"`);\n              recursiveError.code = RECURSIVE_ERROR_CODE;\n              return _this4._onError(recursiveError);\n            }\n\n            return 'directory';\n          }\n        } catch (error) {\n          _this4._onError(error);\n        }\n      }\n    })();\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":null,"metadata":{},"sourceType":"script"}