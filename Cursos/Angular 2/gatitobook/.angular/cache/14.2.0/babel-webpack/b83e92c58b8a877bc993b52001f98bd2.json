{"ast":null,"code":"'use strict';\n\nvar util = require('util');\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nfunction camelCase(str) {\n  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();\n\n  if (!isCamelCase) {\n    str = str.toLowerCase();\n  }\n\n  if (str.indexOf('-') === -1 && str.indexOf('_') === -1) {\n    return str;\n  } else {\n    let camelcase = '';\n    let nextChrUpper = false;\n    const leadingHyphens = str.match(/^-+/);\n\n    for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {\n      let chr = str.charAt(i);\n\n      if (nextChrUpper) {\n        nextChrUpper = false;\n        chr = chr.toUpperCase();\n      }\n\n      if (i !== 0 && (chr === '-' || chr === '_')) {\n        nextChrUpper = true;\n      } else if (chr !== '-' && chr !== '_') {\n        camelcase += chr;\n      }\n    }\n\n    return camelcase;\n  }\n}\n\nfunction decamelize(str, joinString) {\n  const lowercase = str.toLowerCase();\n  joinString = joinString || '-';\n  let notCamelcase = '';\n\n  for (let i = 0; i < str.length; i++) {\n    const chrLower = lowercase.charAt(i);\n    const chrString = str.charAt(i);\n\n    if (chrLower !== chrString && i > 0) {\n      notCamelcase += `${joinString}${lowercase.charAt(i)}`;\n    } else {\n      notCamelcase += chrString;\n    }\n  }\n\n  return notCamelcase;\n}\n\nfunction looksLikeNumber(x) {\n  if (x === null || x === undefined) return false;\n  if (typeof x === 'number') return true;\n  if (/^0x[0-9a-f]+$/i.test(x)) return true;\n  if (/^0[^.]/.test(x)) return false;\n  return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x);\n}\n\nfunction tokenizeArgString(argString) {\n  if (Array.isArray(argString)) {\n    return argString.map(e => typeof e !== 'string' ? e + '' : e);\n  }\n\n  argString = argString.trim();\n  let i = 0;\n  let prevC = null;\n  let c = null;\n  let opening = null;\n  const args = [];\n\n  for (let ii = 0; ii < argString.length; ii++) {\n    prevC = c;\n    c = argString.charAt(ii);\n\n    if (c === ' ' && !opening) {\n      if (!(prevC === ' ')) {\n        i++;\n      }\n\n      continue;\n    }\n\n    if (c === opening) {\n      opening = null;\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c;\n    }\n\n    if (!args[i]) args[i] = '';\n    args[i] += c;\n  }\n\n  return args;\n}\n\nvar DefaultValuesForTypeKey = /*#__PURE__*/(() => {\n  (function (DefaultValuesForTypeKey) {\n    DefaultValuesForTypeKey[\"BOOLEAN\"] = \"boolean\";\n    DefaultValuesForTypeKey[\"STRING\"] = \"string\";\n    DefaultValuesForTypeKey[\"NUMBER\"] = \"number\";\n    DefaultValuesForTypeKey[\"ARRAY\"] = \"array\";\n  })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));\n\n  return DefaultValuesForTypeKey;\n})();\nlet mixin;\n\nclass YargsParser {\n  constructor(_mixin) {\n    mixin = _mixin;\n  }\n\n  parse(argsInput, options) {\n    const opts = Object.assign({\n      alias: undefined,\n      array: undefined,\n      boolean: undefined,\n      config: undefined,\n      configObjects: undefined,\n      configuration: undefined,\n      coerce: undefined,\n      count: undefined,\n      default: undefined,\n      envPrefix: undefined,\n      narg: undefined,\n      normalize: undefined,\n      string: undefined,\n      number: undefined,\n      __: undefined,\n      key: undefined\n    }, options);\n    const args = tokenizeArgString(argsInput);\n    const inputIsString = typeof argsInput === 'string';\n    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n    const configuration = Object.assign({\n      'boolean-negation': true,\n      'camel-case-expansion': true,\n      'combine-arrays': false,\n      'dot-notation': true,\n      'duplicate-arguments-array': true,\n      'flatten-duplicate-arrays': true,\n      'greedy-arrays': true,\n      'halt-at-non-option': false,\n      'nargs-eats-options': false,\n      'negation-prefix': 'no-',\n      'parse-numbers': true,\n      'parse-positional-numbers': true,\n      'populate--': false,\n      'set-placeholder-key': false,\n      'short-option-groups': true,\n      'strip-aliased': false,\n      'strip-dashed': false,\n      'unknown-options-as-args': false\n    }, opts.configuration);\n    const defaults = Object.assign(Object.create(null), opts.default);\n    const configObjects = opts.configObjects || [];\n    const envPrefix = opts.envPrefix;\n    const notFlagsOption = configuration['populate--'];\n    const notFlagsArgv = notFlagsOption ? '--' : '_';\n    const newAliases = Object.create(null);\n    const defaulted = Object.create(null);\n\n    const __ = opts.__ || mixin.format;\n\n    const flags = {\n      aliases: Object.create(null),\n      arrays: Object.create(null),\n      bools: Object.create(null),\n      strings: Object.create(null),\n      numbers: Object.create(null),\n      counts: Object.create(null),\n      normalize: Object.create(null),\n      configs: Object.create(null),\n      nargs: Object.create(null),\n      coercions: Object.create(null),\n      keys: []\n    };\n    const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n    const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n    [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n      const key = typeof opt === 'object' ? opt.key : opt;\n      const assignment = Object.keys(opt).map(function (key) {\n        const arrayFlagKeys = {\n          boolean: 'bools',\n          string: 'strings',\n          number: 'numbers'\n        };\n        return arrayFlagKeys[key];\n      }).filter(Boolean).pop();\n\n      if (assignment) {\n        flags[assignment][key] = true;\n      }\n\n      flags.arrays[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n      flags.bools[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n      flags.strings[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n      flags.numbers[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n      flags.counts[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n      flags.normalize[key] = true;\n      flags.keys.push(key);\n    });\n\n    if (typeof opts.narg === 'object') {\n      Object.entries(opts.narg).forEach(([key, value]) => {\n        if (typeof value === 'number') {\n          flags.nargs[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n\n    if (typeof opts.coerce === 'object') {\n      Object.entries(opts.coerce).forEach(([key, value]) => {\n        if (typeof value === 'function') {\n          flags.coercions[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n\n    if (typeof opts.config !== 'undefined') {\n      if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n        [].concat(opts.config).filter(Boolean).forEach(function (key) {\n          flags.configs[key] = true;\n        });\n      } else if (typeof opts.config === 'object') {\n        Object.entries(opts.config).forEach(([key, value]) => {\n          if (typeof value === 'boolean' || typeof value === 'function') {\n            flags.configs[key] = value;\n          }\n        });\n      }\n    }\n\n    extendAliases(opts.key, aliases, opts.default, flags.arrays);\n    Object.keys(defaults).forEach(function (key) {\n      (flags.aliases[key] || []).forEach(function (alias) {\n        defaults[alias] = defaults[key];\n      });\n    });\n    let error = null;\n    checkConfiguration();\n    let notFlags = [];\n    const argv = Object.assign(Object.create(null), {\n      _: []\n    });\n    const argvReturn = {};\n\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      const truncatedArg = arg.replace(/^-{3,}/, '---');\n      let broken;\n      let key;\n      let letters;\n      let m;\n      let next;\n      let value;\n\n      if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n        pushPositional(arg);\n      } else if (truncatedArg.match(/^---+(=|$)/)) {\n        pushPositional(arg);\n        continue;\n      } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n        m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          if (checkAllAliases(m[1], flags.arrays)) {\n            i = eatArray(i, m[1], args, m[2]);\n          } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n            i = eatNargs(i, m[1], args, m[2]);\n          } else {\n            setArg(m[1], m[2], true);\n          }\n        }\n      } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n        m = arg.match(negatedBoolean);\n\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n        }\n      } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n        m = arg.match(/^--?(.+)/);\n\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n\n          if (checkAllAliases(key, flags.arrays)) {\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n\n            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n      } else if (arg.match(/^-.\\..+=/)) {\n        m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          setArg(m[1], m[2]);\n        }\n      } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n        next = args[i + 1];\n        m = arg.match(/^-(.\\..+)/);\n\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n\n          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n        letters = arg.slice(1, -1).split('');\n        broken = false;\n\n        for (let j = 0; j < letters.length; j++) {\n          next = arg.slice(j + 2);\n\n          if (letters[j + 1] && letters[j + 1] === '=') {\n            value = arg.slice(j + 3);\n            key = letters[j];\n\n            if (checkAllAliases(key, flags.arrays)) {\n              i = eatArray(i, key, args, value);\n            } else if (checkAllAliases(key, flags.nargs) !== false) {\n              i = eatNargs(i, key, args, value);\n            } else {\n              setArg(key, value);\n            }\n\n            broken = true;\n            break;\n          }\n\n          if (next === '-') {\n            setArg(letters[j], next);\n            continue;\n          }\n\n          if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          }\n\n          if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          } else {\n            setArg(letters[j], defaultValue(letters[j]));\n          }\n        }\n\n        key = arg.slice(-1)[0];\n\n        if (!broken && key !== '-') {\n          if (checkAllAliases(key, flags.arrays)) {\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n\n            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n        key = arg.slice(1);\n        setArg(key, defaultValue(key));\n      } else if (arg === '--') {\n        notFlags = args.slice(i + 1);\n        break;\n      } else if (configuration['halt-at-non-option']) {\n        notFlags = args.slice(i);\n        break;\n      } else {\n        pushPositional(arg);\n      }\n    }\n\n    applyEnvVars(argv, true);\n    applyEnvVars(argv, false);\n    setConfig(argv);\n    setConfigObjects();\n    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n    applyCoercions(argv);\n    if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);\n    Object.keys(flags.counts).forEach(function (key) {\n      if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n    });\n    if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n    notFlags.forEach(function (key) {\n      argv[notFlagsArgv].push(key);\n    });\n\n    if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n      Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n        delete argv[key];\n      });\n    }\n\n    if (configuration['strip-aliased']) {\n      [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n        if (configuration['camel-case-expansion'] && alias.includes('-')) {\n          delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n        }\n\n        delete argv[alias];\n      });\n    }\n\n    function pushPositional(arg) {\n      const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n\n      if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n        argv._.push(maybeCoercedNumber);\n      }\n    }\n\n    function eatNargs(i, key, args, argAfterEqualSign) {\n      let ii;\n      let toEat = checkAllAliases(key, flags.nargs);\n      toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n\n      if (toEat === 0) {\n        if (!isUndefined(argAfterEqualSign)) {\n          error = Error(__('Argument unexpected for: %s', key));\n        }\n\n        setArg(key, defaultValue(key));\n        return i;\n      }\n\n      let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n\n      if (configuration['nargs-eats-options']) {\n        if (args.length - (i + 1) + available < toEat) {\n          error = Error(__('Not enough arguments following: %s', key));\n        }\n\n        available = toEat;\n      } else {\n        for (ii = i + 1; ii < args.length; ii++) {\n          if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n        }\n\n        if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n      }\n\n      let consumed = Math.min(available, toEat);\n\n      if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n        setArg(key, argAfterEqualSign);\n        consumed--;\n      }\n\n      for (ii = i + 1; ii < consumed + i + 1; ii++) {\n        setArg(key, args[ii]);\n      }\n\n      return i + consumed;\n    }\n\n    function eatArray(i, key, args, argAfterEqualSign) {\n      let argsToSet = [];\n      let next = argAfterEqualSign || args[i + 1];\n      const nargsCount = checkAllAliases(key, flags.nargs);\n\n      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n        argsToSet.push(true);\n      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n        if (defaults[key] !== undefined) {\n          const defVal = defaults[key];\n          argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n        }\n      } else {\n        if (!isUndefined(argAfterEqualSign)) {\n          argsToSet.push(processValue(key, argAfterEqualSign, true));\n        }\n\n        for (let ii = i + 1; ii < args.length; ii++) {\n          if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;\n          next = args[ii];\n          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n          i = ii;\n          argsToSet.push(processValue(key, next, inputIsString));\n        }\n      }\n\n      if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {\n        error = Error(__('Not enough arguments following: %s', key));\n      }\n\n      setArg(key, argsToSet);\n      return i;\n    }\n\n    function setArg(key, val, shouldStripQuotes = inputIsString) {\n      if (/-/.test(key) && configuration['camel-case-expansion']) {\n        const alias = key.split('.').map(function (prop) {\n          return camelCase(prop);\n        }).join('.');\n        addNewAlias(key, alias);\n      }\n\n      const value = processValue(key, val, shouldStripQuotes);\n      const splitKey = key.split('.');\n      setKey(argv, splitKey, value);\n\n      if (flags.aliases[key]) {\n        flags.aliases[key].forEach(function (x) {\n          const keyProperties = x.split('.');\n          setKey(argv, keyProperties, value);\n        });\n      }\n\n      if (splitKey.length > 1 && configuration['dot-notation']) {\n        (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n          let keyProperties = x.split('.');\n          const a = [].concat(splitKey);\n          a.shift();\n          keyProperties = keyProperties.concat(a);\n\n          if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n            setKey(argv, keyProperties, value);\n          }\n        });\n      }\n\n      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n        const keys = [key].concat(flags.aliases[key] || []);\n        keys.forEach(function (key) {\n          Object.defineProperty(argvReturn, key, {\n            enumerable: true,\n\n            get() {\n              return val;\n            },\n\n            set(value) {\n              val = typeof value === 'string' ? mixin.normalize(value) : value;\n            }\n\n          });\n        });\n      }\n    }\n\n    function addNewAlias(key, alias) {\n      if (!(flags.aliases[key] && flags.aliases[key].length)) {\n        flags.aliases[key] = [alias];\n        newAliases[alias] = true;\n      }\n\n      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n        addNewAlias(alias, key);\n      }\n    }\n\n    function processValue(key, val, shouldStripQuotes) {\n      if (shouldStripQuotes) {\n        val = stripQuotes(val);\n      }\n\n      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n        if (typeof val === 'string') val = val === 'true';\n      }\n\n      let value = Array.isArray(val) ? val.map(function (v) {\n        return maybeCoerceNumber(key, v);\n      }) : maybeCoerceNumber(key, val);\n\n      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n        value = increment();\n      }\n\n      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n        if (Array.isArray(val)) value = val.map(val => {\n          return mixin.normalize(val);\n        });else value = mixin.normalize(val);\n      }\n\n      return value;\n    }\n\n    function maybeCoerceNumber(key, value) {\n      if (!configuration['parse-positional-numbers'] && key === '_') return value;\n\n      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n        const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));\n\n        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {\n          value = Number(value);\n        }\n      }\n\n      return value;\n    }\n\n    function setConfig(argv) {\n      const configLookup = Object.create(null);\n      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n      Object.keys(flags.configs).forEach(function (configKey) {\n        const configPath = argv[configKey] || configLookup[configKey];\n\n        if (configPath) {\n          try {\n            let config = null;\n            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n            const resolveConfig = flags.configs[configKey];\n\n            if (typeof resolveConfig === 'function') {\n              try {\n                config = resolveConfig(resolvedConfigPath);\n              } catch (e) {\n                config = e;\n              }\n\n              if (config instanceof Error) {\n                error = config;\n                return;\n              }\n            } else {\n              config = mixin.require(resolvedConfigPath);\n            }\n\n            setConfigObject(config);\n          } catch (ex) {\n            if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n          }\n        }\n      });\n    }\n\n    function setConfigObject(config, prev) {\n      Object.keys(config).forEach(function (key) {\n        const value = config[key];\n        const fullKey = prev ? prev + '.' + key : key;\n\n        if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n          setConfigObject(value, fullKey);\n        } else {\n          if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n            setArg(fullKey, value);\n          }\n        }\n      });\n    }\n\n    function setConfigObjects() {\n      if (typeof configObjects !== 'undefined') {\n        configObjects.forEach(function (configObject) {\n          setConfigObject(configObject);\n        });\n      }\n    }\n\n    function applyEnvVars(argv, configOnly) {\n      if (typeof envPrefix === 'undefined') return;\n      const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n      const env = mixin.env();\n      Object.keys(env).forEach(function (envVar) {\n        if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n          const keys = envVar.split('__').map(function (key, i) {\n            if (i === 0) {\n              key = key.substring(prefix.length);\n            }\n\n            return camelCase(key);\n          });\n\n          if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n            setArg(keys.join('.'), env[envVar]);\n          }\n        }\n      });\n    }\n\n    function applyCoercions(argv) {\n      let coerce;\n      const applied = new Set();\n      Object.keys(argv).forEach(function (key) {\n        if (!applied.has(key)) {\n          coerce = checkAllAliases(key, flags.coercions);\n\n          if (typeof coerce === 'function') {\n            try {\n              const value = maybeCoerceNumber(key, coerce(argv[key]));\n              [].concat(flags.aliases[key] || [], key).forEach(ali => {\n                applied.add(ali);\n                argv[ali] = value;\n              });\n            } catch (err) {\n              error = err;\n            }\n          }\n        }\n      });\n    }\n\n    function setPlaceholderKeys(argv) {\n      flags.keys.forEach(key => {\n        if (~key.indexOf('.')) return;\n        if (typeof argv[key] === 'undefined') argv[key] = undefined;\n      });\n      return argv;\n    }\n\n    function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n      Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(obj, key.split('.'))) {\n          setKey(obj, key.split('.'), defaults[key]);\n          if (canLog) defaulted[key] = true;\n          (aliases[key] || []).forEach(function (x) {\n            if (hasKey(obj, x.split('.'))) return;\n            setKey(obj, x.split('.'), defaults[key]);\n          });\n        }\n      });\n    }\n\n    function hasKey(obj, keys) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        o = o[key] || {};\n      });\n      const key = keys[keys.length - 1];\n      if (typeof o !== 'object') return false;else return key in o;\n    }\n\n    function setKey(obj, keys, value) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        key = sanitizeKey(key);\n\n        if (typeof o === 'object' && o[key] === undefined) {\n          o[key] = {};\n        }\n\n        if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n          if (Array.isArray(o[key])) {\n            o[key].push({});\n          } else {\n            o[key] = [o[key], {}];\n          }\n\n          o = o[key][o[key].length - 1];\n        } else {\n          o = o[key];\n        }\n      });\n      const key = sanitizeKey(keys[keys.length - 1]);\n      const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n      const isValueArray = Array.isArray(value);\n      let duplicate = configuration['duplicate-arguments-array'];\n\n      if (!duplicate && checkAllAliases(key, flags.nargs)) {\n        duplicate = true;\n\n        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n          o[key] = undefined;\n        }\n      }\n\n      if (value === increment()) {\n        o[key] = increment(o[key]);\n      } else if (Array.isArray(o[key])) {\n        if (duplicate && isTypeArray && isValueArray) {\n          o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n          o[key] = value;\n        } else {\n          o[key] = o[key].concat([value]);\n        }\n      } else if (o[key] === undefined && isTypeArray) {\n        o[key] = isValueArray ? value : [value];\n      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n        o[key] = [o[key], value];\n      } else {\n        o[key] = value;\n      }\n    }\n\n    function extendAliases(...args) {\n      args.forEach(function (obj) {\n        Object.keys(obj || {}).forEach(function (key) {\n          if (flags.aliases[key]) return;\n          flags.aliases[key] = [].concat(aliases[key] || []);\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (/-/.test(x) && configuration['camel-case-expansion']) {\n              const c = camelCase(x);\n\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n              const c = decamelize(x, '-');\n\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          flags.aliases[key].forEach(function (x) {\n            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n              return x !== y;\n            }));\n          });\n        });\n      });\n    }\n\n    function checkAllAliases(key, flag) {\n      const toCheck = [].concat(flags.aliases[key] || [], key);\n      const keys = Object.keys(flag);\n      const setAlias = toCheck.find(key => keys.includes(key));\n      return setAlias ? flag[setAlias] : false;\n    }\n\n    function hasAnyFlag(key) {\n      const flagsKeys = Object.keys(flags);\n      const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n      return toCheck.some(function (flag) {\n        return Array.isArray(flag) ? flag.includes(key) : flag[key];\n      });\n    }\n\n    function hasFlagsMatching(arg, ...patterns) {\n      const toCheck = [].concat(...patterns);\n      return toCheck.some(function (pattern) {\n        const match = arg.match(pattern);\n        return match && hasAnyFlag(match[1]);\n      });\n    }\n\n    function hasAllShortFlags(arg) {\n      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n        return false;\n      }\n\n      let hasAllFlags = true;\n      let next;\n      const letters = arg.slice(1).split('');\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n\n        if (!hasAnyFlag(letters[j])) {\n          hasAllFlags = false;\n          break;\n        }\n\n        if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          break;\n        }\n      }\n\n      return hasAllFlags;\n    }\n\n    function isUnknownOptionAsArg(arg) {\n      return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n    }\n\n    function isUnknownOption(arg) {\n      arg = arg.replace(/^-{3,}/, '--');\n\n      if (arg.match(negative)) {\n        return false;\n      }\n\n      if (hasAllShortFlags(arg)) {\n        return false;\n      }\n\n      const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n      const normalFlag = /^-+([^=]+?)$/;\n      const flagEndingInHyphen = /^-+([^=]+?)-$/;\n      const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n      const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n    }\n\n    function defaultValue(key) {\n      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n        return defaults[key];\n      } else {\n        return defaultForType(guessType(key));\n      }\n    }\n\n    function defaultForType(type) {\n      const def = {\n        [DefaultValuesForTypeKey.BOOLEAN]: true,\n        [DefaultValuesForTypeKey.STRING]: '',\n        [DefaultValuesForTypeKey.NUMBER]: undefined,\n        [DefaultValuesForTypeKey.ARRAY]: []\n      };\n      return def[type];\n    }\n\n    function guessType(key) {\n      let type = DefaultValuesForTypeKey.BOOLEAN;\n      if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;\n      return type;\n    }\n\n    function isUndefined(num) {\n      return num === undefined;\n    }\n\n    function checkConfiguration() {\n      Object.keys(flags.counts).find(key => {\n        if (checkAllAliases(key, flags.arrays)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n          return true;\n        } else if (checkAllAliases(key, flags.nargs)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n          return true;\n        }\n\n        return false;\n      });\n    }\n\n    return {\n      aliases: Object.assign({}, flags.aliases),\n      argv: Object.assign(argvReturn, argv),\n      configuration: configuration,\n      defaulted: Object.assign({}, defaulted),\n      error: error,\n      newAliases: Object.assign({}, newAliases)\n    };\n  }\n\n}\n\nfunction combineAliases(aliases) {\n  const aliasArrays = [];\n  const combined = Object.create(null);\n  let change = true;\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  });\n\n  while (change) {\n    change = false;\n\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  }\n\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    const lastAlias = aliasArray.pop();\n\n    if (lastAlias !== undefined && typeof lastAlias === 'string') {\n      combined[lastAlias] = aliasArray;\n    }\n  });\n  return combined;\n}\n\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\n\nfunction stripQuotes(val) {\n  return typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;\n}\n\nvar _a, _b, _c;\n\nconst minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;\nconst nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);\n\nif (nodeVersion) {\n  const major = Number(nodeVersion.match(/^([^.]+)/)[1]);\n\n  if (major < minNodeVersion) {\n    throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);\n  }\n}\n\nconst env = process ? process.env : {};\nconst parser = new YargsParser({\n  cwd: process.cwd,\n  env: () => {\n    return env;\n  },\n  format: util.format,\n  normalize: path.normalize,\n  resolve: path.resolve,\n  require: path => {\n    if (typeof require !== 'undefined') {\n      return require(path);\n    } else if (path.match(/\\.json$/)) {\n      return JSON.parse(fs.readFileSync(path, 'utf8'));\n    } else {\n      throw Error('only .json config files are supported in ESM');\n    }\n  }\n});\n\nconst yargsParser = function Parser(args, opts) {\n  const result = parser.parse(args.slice(), opts);\n  return result.argv;\n};\n\nyargsParser.detailed = function (args, opts) {\n  return parser.parse(args.slice(), opts);\n};\n\nyargsParser.camelCase = camelCase;\nyargsParser.decamelize = decamelize;\nyargsParser.looksLikeNumber = looksLikeNumber;\nmodule.exports = yargsParser;","map":null,"metadata":{},"sourceType":"script"}