{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnalyticsCollector = void 0;\n\nconst core_1 = /*#__PURE__*/require(\"@angular-devkit/core\");\n\nconst child_process_1 = /*#__PURE__*/require(\"child_process\");\n\nconst debug_1 = __importDefault( /*#__PURE__*/require(\"debug\"));\n\nconst https = __importStar( /*#__PURE__*/require(\"https\"));\n\nconst os = __importStar( /*#__PURE__*/require(\"os\"));\n\nconst querystring = __importStar( /*#__PURE__*/require(\"querystring\"));\n\nconst version_1 = /*#__PURE__*/require(\"../utilities/version\");\n/**\n * See: https://developers.google.com/analytics/devguides/collection/protocol/v1/devguide\n */\n\n\nclass AnalyticsCollector {\n  constructor(trackingId, userId) {\n    this.trackingEventsQueue = [];\n    this.parameters = {};\n    this.analyticsLogDebug = (0, debug_1.default)('ng:analytics:log'); // API Version\n\n    this.parameters['v'] = '1'; // User ID\n\n    this.parameters['cid'] = userId; // Tracking\n\n    this.parameters['tid'] = trackingId;\n    this.parameters['ds'] = 'cli';\n    this.parameters['ua'] = _buildUserAgentString();\n    this.parameters['ul'] = _getLanguage(); // @angular/cli with version.\n\n    this.parameters['an'] = '@angular/cli';\n    this.parameters['av'] = version_1.VERSION.full; // We use the application ID for the Node version. This should be \"node v12.10.0\".\n\n    const nodeVersion = `node ${process.version}`;\n    this.parameters['aid'] = nodeVersion; // Custom dimentions\n    // We set custom metrics for values we care about.\n\n    this.parameters['cd' + core_1.analytics.NgCliAnalyticsDimensions.CpuCount] = os.cpus().length; // Get the first CPU's speed. It's very rare to have multiple CPUs of different speed (in most\n    // non-ARM configurations anyway), so that's all we care about.\n\n    this.parameters['cd' + core_1.analytics.NgCliAnalyticsDimensions.CpuSpeed] = Math.floor(os.cpus()[0].speed);\n    this.parameters['cd' + core_1.analytics.NgCliAnalyticsDimensions.RamInGigabytes] = Math.round(os.totalmem() / (1024 * 1024 * 1024));\n    this.parameters['cd' + core_1.analytics.NgCliAnalyticsDimensions.NodeVersion] = nodeVersion;\n    this.parameters['cd' + core_1.analytics.NgCliAnalyticsDimensions.AngularCLIMajorVersion] = version_1.VERSION.major;\n  }\n\n  event(ec, ea, options = {}) {\n    const {\n      label: el,\n      value: ev,\n      metrics,\n      dimensions\n    } = options;\n    this.addToQueue('event', {\n      ec,\n      ea,\n      el,\n      ev,\n      metrics,\n      dimensions\n    });\n  }\n\n  pageview(dp, options = {}) {\n    const {\n      hostname: dh,\n      title: dt,\n      metrics,\n      dimensions\n    } = options;\n    this.addToQueue('pageview', {\n      dp,\n      dh,\n      dt,\n      metrics,\n      dimensions\n    });\n  }\n\n  timing(utc, utv, utt, options = {}) {\n    const {\n      label: utl,\n      metrics,\n      dimensions\n    } = options;\n    this.addToQueue('timing', {\n      utc,\n      utv,\n      utt,\n      utl,\n      metrics,\n      dimensions\n    });\n  }\n\n  screenview(cd, an, options = {}) {\n    const {\n      appVersion: av,\n      appId: aid,\n      appInstallerId: aiid,\n      metrics,\n      dimensions\n    } = options;\n    this.addToQueue('screenview', {\n      cd,\n      an,\n      av,\n      aid,\n      aiid,\n      metrics,\n      dimensions\n    });\n  }\n\n  flush() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const pending = _this.trackingEventsQueue.length;\n\n      _this.analyticsLogDebug(`flush queue size: ${pending}`);\n\n      if (!pending) {\n        return;\n      } // The below is needed so that if flush is called multiple times,\n      // we don't report the same event multiple times.\n\n\n      const pendingTrackingEvents = _this.trackingEventsQueue;\n      _this.trackingEventsQueue = [];\n\n      try {\n        yield _this.send(pendingTrackingEvents);\n      } catch (error) {\n        // Failure to report analytics shouldn't crash the CLI.\n        _this.analyticsLogDebug('send error: %j', error);\n      }\n    })();\n  }\n\n  addToQueue(eventType, parameters) {\n    const {\n      metrics,\n      dimensions,\n      ...restParameters\n    } = parameters;\n    const data = { ...this.parameters,\n      ...restParameters,\n      ...this.customVariables({\n        metrics,\n        dimensions\n      }),\n      t: eventType\n    };\n    this.analyticsLogDebug('add event to queue: %j', data);\n    this.trackingEventsQueue.push(data);\n  }\n\n  send(data) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.analyticsLogDebug('send event: %j', data);\n\n      return new Promise((resolve, reject) => {\n        const request = https.request({\n          host: 'www.google-analytics.com',\n          method: 'POST',\n          path: data.length > 1 ? '/batch' : '/collect'\n        }, response => {\n          if (response.statusCode !== 200) {\n            reject(new Error(`Analytics reporting failed with status code: ${response.statusCode}.`));\n            return;\n          }\n        });\n        request.on('error', reject);\n        const queryParameters = data.map(p => querystring.stringify(p)).join('\\n');\n        request.write(queryParameters);\n        request.end(resolve);\n      });\n    })();\n  }\n  /**\n   * Creates the dimension and metrics variables to add to the queue.\n   * @private\n   */\n\n\n  customVariables(options) {\n    const additionals = {};\n    const {\n      dimensions,\n      metrics\n    } = options;\n    dimensions === null || dimensions === void 0 ? void 0 : dimensions.forEach((v, i) => additionals[`cd${i}`] = v);\n    metrics === null || metrics === void 0 ? void 0 : metrics.forEach((v, i) => additionals[`cm${i}`] = v);\n    return additionals;\n  }\n\n}\n\nexports.AnalyticsCollector = AnalyticsCollector; // These are just approximations of UA strings. We just try to fool Google Analytics to give us the\n// data we want.\n// See https://developers.whatismybrowser.com/useragents/\n\nconst osVersionMap = {\n  darwin: {\n    '1.3.1': '10_0_4',\n    '1.4.1': '10_1_0',\n    '5.1': '10_1_1',\n    '5.2': '10_1_5',\n    '6.0.1': '10_2',\n    '6.8': '10_2_8',\n    '7.0': '10_3_0',\n    '7.9': '10_3_9',\n    '8.0': '10_4_0',\n    '8.11': '10_4_11',\n    '9.0': '10_5_0',\n    '9.8': '10_5_8',\n    '10.0': '10_6_0',\n    '10.8': '10_6_8' // We stop here because we try to math out the version for anything greater than 10, and it\n    // works. Those versions are standardized using a calculation now.\n\n  },\n  win32: {\n    '6.3.9600': 'Windows 8.1',\n    '6.2.9200': 'Windows 8',\n    '6.1.7601': 'Windows 7 SP1',\n    '6.1.7600': 'Windows 7',\n    '6.0.6002': 'Windows Vista SP2',\n    '6.0.6000': 'Windows Vista',\n    '5.1.2600': 'Windows XP'\n  }\n};\n/**\n * Build a fake User Agent string. This gets sent to Analytics so it shows the proper OS version.\n * @private\n */\n\nfunction _buildUserAgentString() {\n  switch (os.platform()) {\n    case 'darwin':\n      {\n        let v = osVersionMap.darwin[os.release()];\n\n        if (!v) {\n          // Remove 4 to tie Darwin version to OSX version, add other info.\n          const x = parseFloat(os.release());\n\n          if (x > 10) {\n            v = `10_` + (x - 4).toString().replace('.', '_');\n          }\n        }\n\n        const cpuModel = os.cpus()[0].model.match(/^[a-z]+/i);\n        const cpu = cpuModel ? cpuModel[0] : os.cpus()[0].model;\n        return `(Macintosh; ${cpu} Mac OS X ${v || os.release()})`;\n      }\n\n    case 'win32':\n      return `(Windows NT ${os.release()})`;\n\n    case 'linux':\n      return `(X11; Linux i686; ${os.release()}; ${os.cpus()[0].model})`;\n\n    default:\n      return os.platform() + ' ' + os.release();\n  }\n}\n/**\n * Get a language code.\n * @private\n */\n\n\nfunction _getLanguage() {\n  // Note: Windows does not expose the configured language by default.\n  return process.env.LANG || // Default Unix env variable.\n  process.env.LC_CTYPE || // For C libraries. Sometimes the above isn't set.\n  process.env.LANGSPEC || // For Windows, sometimes this will be set (not always).\n  _getWindowsLanguageCode() || '??'; // ¯\\_(ツ)_/¯\n}\n/**\n * Attempt to get the Windows Language Code string.\n * @private\n */\n\n\nfunction _getWindowsLanguageCode() {\n  if (!os.platform().startsWith('win')) {\n    return undefined;\n  }\n\n  try {\n    // This is true on Windows XP, 7, 8 and 10 AFAIK. Would return empty string or fail if it\n    // doesn't work.\n    return (0, child_process_1.execSync)('wmic.exe os get locale').toString().trim();\n  } catch {}\n\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}