{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst nopt = require('nopt');\n\nconst log = require('npmlog');\n\nconst childProcess = require('child_process');\n\nconst EE = require('events').EventEmitter;\n\nconst inherits = require('util').inherits;\n\nconst commands = [// Module build commands\n'build', 'clean', 'configure', 'rebuild', // Development Header File management commands\n'install', 'list', 'remove'];\nconst aliases = {\n  ls: 'list',\n  rm: 'remove'\n}; // differentiate node-gyp's logs from npm's\n\nlog.heading = 'gyp';\n\nfunction gyp() {\n  return new Gyp();\n}\n\nfunction Gyp() {\n  var self = this;\n  this.devDir = '';\n  this.commands = {};\n  commands.forEach(function (command) {\n    self.commands[command] = function (argv, callback) {\n      log.verbose('command', command, argv);\n      return require('./' + command)(self, argv, callback);\n    };\n  });\n}\n\ninherits(Gyp, EE);\nexports.Gyp = Gyp;\nvar proto = Gyp.prototype;\n/**\n * Export the contents of the package.json.\n */\n\nproto.package = require('../package.json');\n/**\n * nopt configuration definitions\n */\n\nproto.configDefs = {\n  help: Boolean,\n  // everywhere\n  arch: String,\n  // 'configure'\n  cafile: String,\n  // 'install'\n  debug: Boolean,\n  // 'build'\n  directory: String,\n  // bin\n  make: String,\n  // 'build'\n  msvs_version: String,\n  // 'configure'\n  ensure: Boolean,\n  // 'install'\n  solution: String,\n  // 'build' (windows only)\n  proxy: String,\n  // 'install'\n  noproxy: String,\n  // 'install'\n  devdir: String,\n  // everywhere\n  nodedir: String,\n  // 'configure'\n  loglevel: String,\n  // everywhere\n  python: String,\n  // 'configure'\n  'dist-url': String,\n  // 'install'\n  tarball: String,\n  // 'install'\n  jobs: String,\n  // 'build'\n  thin: String,\n  // 'configure'\n  'force-process-config': Boolean // 'configure'\n\n};\n/**\n * nopt shorthands\n */\n\nproto.shorthands = {\n  release: '--no-debug',\n  C: '--directory',\n  debug: '--debug',\n  j: '--jobs',\n  silly: '--loglevel=silly',\n  verbose: '--loglevel=verbose',\n  silent: '--loglevel=silent'\n};\n/**\n * expose the command aliases for the bin file to use.\n */\n\nproto.aliases = aliases;\n/**\n * Parses the given argv array and sets the 'opts',\n * 'argv' and 'command' properties.\n */\n\nproto.parseArgv = function parseOpts(argv) {\n  this.opts = nopt(this.configDefs, this.shorthands, argv);\n  this.argv = this.opts.argv.remain.slice();\n  var commands = this.todo = []; // create a copy of the argv array with aliases mapped\n\n  argv = this.argv.map(function (arg) {\n    // is this an alias?\n    if (arg in this.aliases) {\n      arg = this.aliases[arg];\n    }\n\n    return arg;\n  }, this); // process the mapped args into \"command\" objects (\"name\" and \"args\" props)\n\n  argv.slice().forEach(function (arg) {\n    if (arg in this.commands) {\n      var args = argv.splice(0, argv.indexOf(arg));\n      argv.shift();\n\n      if (commands.length > 0) {\n        commands[commands.length - 1].args = args;\n      }\n\n      commands.push({\n        name: arg,\n        args: []\n      });\n    }\n  }, this);\n\n  if (commands.length > 0) {\n    commands[commands.length - 1].args = argv.splice(0);\n  } // support for inheriting config env variables from npm\n\n\n  var npmConfigPrefix = 'npm_config_';\n  Object.keys(process.env).forEach(function (name) {\n    if (name.indexOf(npmConfigPrefix) !== 0) {\n      return;\n    }\n\n    var val = process.env[name];\n\n    if (name === npmConfigPrefix + 'loglevel') {\n      log.level = val;\n    } else {\n      // add the user-defined options to the config\n      name = name.substring(npmConfigPrefix.length); // gyp@741b7f1 enters an infinite loop when it encounters\n      // zero-length options so ensure those don't get through.\n\n      if (name) {\n        // convert names like force_process_config to force-process-config\n        if (name.includes('_')) {\n          name = name.replace(/_/g, '-');\n        }\n\n        this.opts[name] = val;\n      }\n    }\n  }, this);\n\n  if (this.opts.loglevel) {\n    log.level = this.opts.loglevel;\n  }\n\n  log.resume();\n};\n/**\n * Spawns a child process and emits a 'spawn' event.\n */\n\n\nproto.spawn = function spawn(command, args, opts) {\n  if (!opts) {\n    opts = {};\n  }\n\n  if (!opts.silent && !opts.stdio) {\n    opts.stdio = [0, 1, 2];\n  }\n\n  var cp = childProcess.spawn(command, args, opts);\n  log.info('spawn', command);\n  log.info('spawn args', args);\n  return cp;\n};\n/**\n * Returns the usage instructions for node-gyp.\n */\n\n\nproto.usage = function usage() {\n  var str = ['', '  Usage: node-gyp <command> [options]', '', '  where <command> is one of:', commands.map(function (c) {\n    return '    - ' + c + ' - ' + require('./' + c).usage;\n  }).join('\\n'), '', 'node-gyp@' + this.version + '  ' + path.resolve(__dirname, '..'), 'node@' + process.versions.node].join('\\n');\n  return str;\n};\n/**\n * Version number getter.\n */\n\n\nObject.defineProperty(proto, 'version', {\n  get: function () {\n    return this.package.version;\n  },\n  enumerable: true\n});\nmodule.exports = exports = gyp;","map":null,"metadata":{},"sourceType":"script"}