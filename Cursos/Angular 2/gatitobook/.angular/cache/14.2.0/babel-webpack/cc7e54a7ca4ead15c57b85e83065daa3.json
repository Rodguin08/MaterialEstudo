{"ast":null,"code":"// turn an array of lines from `git ls-remote` into a thing\n// vaguely resembling a packument, where docs are a resolved ref\nconst semver = require('semver');\n\nmodule.exports = lines => finish(lines.reduce(linesToRevsReducer, {\n  versions: {},\n  'dist-tags': {},\n  refs: {},\n  shas: {}\n}));\n\nconst finish = revs => distTags(shaList(peelTags(revs))); // We can check out shallow clones on specific SHAs if we have a ref\n\n\nconst shaList = revs => {\n  Object.keys(revs.refs).forEach(ref => {\n    const doc = revs.refs[ref];\n\n    if (!revs.shas[doc.sha]) {\n      revs.shas[doc.sha] = [ref];\n    } else {\n      revs.shas[doc.sha].push(ref);\n    }\n  });\n  return revs;\n}; // Replace any tags with their ^{} counterparts, if those exist\n\n\nconst peelTags = revs => {\n  Object.keys(revs.refs).filter(ref => ref.endsWith('^{}')).forEach(ref => {\n    const peeled = revs.refs[ref];\n    const unpeeled = revs.refs[ref.replace(/\\^\\{\\}$/, '')];\n\n    if (unpeeled) {\n      unpeeled.sha = peeled.sha;\n      delete revs.refs[ref];\n    }\n  });\n  return revs;\n};\n\nconst distTags = revs => {\n  // not entirely sure what situations would result in an\n  // ichabod repo, but best to be careful in Sleepy Hollow anyway\n  const HEAD = revs.refs.HEAD ||\n  /* istanbul ignore next */\n  {};\n  const versions = Object.keys(revs.versions);\n  versions.forEach(v => {\n    // simulate a dist-tags with latest pointing at the\n    // 'latest' branch if one exists and is a version,\n    // or HEAD if not.\n    const ver = revs.versions[v];\n\n    if (revs.refs.latest && ver.sha === revs.refs.latest.sha) {\n      revs['dist-tags'].latest = v;\n    } else if (ver.sha === HEAD.sha) {\n      revs['dist-tags'].HEAD = v;\n\n      if (!revs.refs.latest) {\n        revs['dist-tags'].latest = v;\n      }\n    }\n  });\n  return revs;\n};\n\nconst refType = ref => {\n  if (ref.startsWith('refs/tags/')) {\n    return 'tag';\n  }\n\n  if (ref.startsWith('refs/heads/')) {\n    return 'branch';\n  }\n\n  if (ref.startsWith('refs/pull/')) {\n    return 'pull';\n  }\n\n  if (ref === 'HEAD') {\n    return 'head';\n  } // Could be anything, ignore for now\n\n  /* istanbul ignore next */\n\n\n  return 'other';\n}; // return the doc, or null if we should ignore it.\n\n\nconst lineToRevDoc = line => {\n  const split = line.trim().split(/\\s+/, 2);\n\n  if (split.length < 2) {\n    return null;\n  }\n\n  const sha = split[0].trim();\n  const rawRef = split[1].trim();\n  const type = refType(rawRef);\n\n  if (type === 'tag') {\n    // refs/tags/foo^{} is the 'peeled tag', ie the commit\n    // that is tagged by refs/tags/foo they resolve to the same\n    // content, just different objects in git's data structure.\n    // But, we care about the thing the tag POINTS to, not the tag\n    // object itself, so we only look at the peeled tag refs, and\n    // ignore the pointer.\n    // For now, though, we have to save both, because some tags\n    // don't have peels, if they were not annotated.\n    const ref = rawRef.slice('refs/tags/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'branch') {\n    const ref = rawRef.slice('refs/heads/'.length);\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'pull') {\n    // NB: merged pull requests installable with #pull/123/merge\n    // for the merged pr, or #pull/123 for the PR head\n    const ref = rawRef.slice('refs/'.length).replace(/\\/head$/, '');\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  }\n\n  if (type === 'head') {\n    const ref = 'HEAD';\n    return {\n      sha,\n      ref,\n      rawRef,\n      type\n    };\n  } // at this point, all we can do is leave the ref un-munged\n\n\n  return {\n    sha,\n    ref: rawRef,\n    rawRef,\n    type\n  };\n};\n\nconst linesToRevsReducer = (revs, line) => {\n  const doc = lineToRevDoc(line);\n\n  if (!doc) {\n    return revs;\n  }\n\n  revs.refs[doc.ref] = doc;\n  revs.refs[doc.rawRef] = doc;\n\n  if (doc.type === 'tag') {\n    // try to pull a semver value out of tags like `release-v1.2.3`\n    // which is a pretty common pattern.\n    const match = !doc.ref.endsWith('^{}') && doc.ref.match(/v?(\\d+\\.\\d+\\.\\d+(?:[-+].+)?)$/);\n\n    if (match && semver.valid(match[1], true)) {\n      revs.versions[semver.clean(match[1], true)] = doc;\n    }\n  }\n\n  return revs;\n};","map":null,"metadata":{},"sourceType":"script"}