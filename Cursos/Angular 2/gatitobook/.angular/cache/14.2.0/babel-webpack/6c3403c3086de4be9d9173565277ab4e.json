{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRule = exports.callSource = exports.InvalidSourceResultException = exports.InvalidRuleResultException = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst interface_1 = require(\"../tree/interface\");\n\nfunction _getTypeOfResult(value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (typeof value == 'function') {\n    return `Function()`;\n  } else if (typeof value != 'object') {\n    return `${typeof value}(${JSON.stringify(value)})`;\n  } else {\n    if (Object.getPrototypeOf(value) == Object) {\n      return `Object(${JSON.stringify(value)})`;\n    } else if (value.constructor) {\n      return `Instance of class ${value.constructor.name}`;\n    } else {\n      return 'Unknown Object';\n    }\n  }\n}\n/**\n * When a rule or source returns an invalid value.\n */\n\n\nclass InvalidRuleResultException extends core_1.BaseException {\n  constructor(value) {\n    super(`Invalid rule result: ${_getTypeOfResult(value)}.`);\n  }\n\n}\n\nexports.InvalidRuleResultException = InvalidRuleResultException;\n\nclass InvalidSourceResultException extends core_1.BaseException {\n  constructor(value) {\n    super(`Invalid source result: ${_getTypeOfResult(value)}.`);\n  }\n\n}\n\nexports.InvalidSourceResultException = InvalidSourceResultException;\n\nfunction callSource(source, context) {\n  return (0, rxjs_1.defer)( /*#__PURE__*/_asyncToGenerator(function* () {\n    let result = source(context);\n\n    if ((0, rxjs_1.isObservable)(result)) {\n      result = yield result.pipe((0, operators_1.defaultIfEmpty)()).toPromise();\n    }\n\n    if (result && interface_1.TreeSymbol in result) {\n      return result;\n    }\n\n    throw new InvalidSourceResultException(result);\n  }));\n}\n\nexports.callSource = callSource;\n\nfunction callRule(rule, input, context) {\n  if ((0, rxjs_1.isObservable)(input)) {\n    return input.pipe((0, operators_1.mergeMap)(inputTree => callRuleAsync(rule, inputTree, context)));\n  } else {\n    return (0, rxjs_1.defer)(() => callRuleAsync(rule, input, context));\n  }\n}\n\nexports.callRule = callRule;\n\nfunction callRuleAsync(_x, _x2, _x3) {\n  return _callRuleAsync.apply(this, arguments);\n}\n\nfunction _callRuleAsync() {\n  _callRuleAsync = _asyncToGenerator(function* (rule, tree, context) {\n    let result = yield rule(tree, context);\n\n    while (typeof result === 'function') {\n      // This is considered a Rule, chain the rule and return its output.\n      result = yield result(tree, context);\n    }\n\n    if (typeof result === 'undefined') {\n      return tree;\n    }\n\n    if ((0, rxjs_1.isObservable)(result)) {\n      result = yield result.pipe((0, operators_1.defaultIfEmpty)(tree)).toPromise();\n    }\n\n    if (interface_1.TreeSymbol in result) {\n      return result;\n    }\n\n    throw new InvalidRuleResultException(result);\n  });\n  return _callRuleAsync.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}