{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writeWorkspace = exports.readWorkspace = exports._test_removeWorkspaceFile = exports._test_addWorkspaceFile = exports.WorkspaceFormat = void 0;\n\nconst virtual_fs_1 = require(\"../virtual-fs\");\n\nconst reader_1 = require(\"./json/reader\");\n\nconst writer_1 = require(\"./json/writer\");\n\nconst formatLookup = new WeakMap();\n/**\n * Supported workspace formats\n */\n\nvar WorkspaceFormat;\n\n(function (WorkspaceFormat) {\n  WorkspaceFormat[WorkspaceFormat[\"JSON\"] = 0] = \"JSON\";\n})(WorkspaceFormat = exports.WorkspaceFormat || (exports.WorkspaceFormat = {}));\n/**\n * @private\n */\n\n\nfunction _test_addWorkspaceFile(name, format) {\n  workspaceFiles[name] = format;\n}\n\nexports._test_addWorkspaceFile = _test_addWorkspaceFile;\n/**\n * @private\n */\n\nfunction _test_removeWorkspaceFile(name) {\n  delete workspaceFiles[name];\n}\n\nexports._test_removeWorkspaceFile = _test_removeWorkspaceFile; // NOTE: future additions could also perform content analysis to determine format/version\n\nconst workspaceFiles = {\n  'angular.json': WorkspaceFormat.JSON,\n  '.angular.json': WorkspaceFormat.JSON\n};\n/**\n * Reads and constructs a `WorkspaceDefinition`.  If the function is provided with a path to a\n * directory instead of a file, a search of the directory's files will commence to attempt to\n * locate a known workspace file.  Currently the following are considered known workspace files:\n * - `angular.json`\n * - `.angular.json`\n *\n * @param path The path to either a workspace file or a directory containing a workspace file.\n * @param host The `WorkspaceHost` to use to access the file and directory data.\n * @param format An optional `WorkspaceFormat` value. Used if the path specifies a non-standard\n * file name that would prevent automatically discovering the format.\n *\n *\n * @return An `Promise` of the read result object with the `WorkspaceDefinition` contained within\n * the `workspace` property.\n */\n\nfunction readWorkspace(_x, _x2, _x3) {\n  return _readWorkspace.apply(this, arguments);\n}\n\nfunction _readWorkspace() {\n  _readWorkspace = _asyncToGenerator(function* (path, host, format) {\n    if (yield host.isDirectory(path)) {\n      // TODO: Warn if multiple found (requires diagnostics support)\n      const directory = (0, virtual_fs_1.normalize)(path);\n      let found = false;\n\n      for (const [name, nameFormat] of Object.entries(workspaceFiles)) {\n        if (format !== undefined && format !== nameFormat) {\n          continue;\n        }\n\n        const potential = (0, virtual_fs_1.getSystemPath)((0, virtual_fs_1.join)(directory, name));\n\n        if (yield host.isFile(potential)) {\n          path = potential;\n          format = nameFormat;\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        throw new Error('Unable to locate a workspace file for workspace path. Are you missing an `angular.json`' + ' or `.angular.json` file?');\n      }\n    } else if (format === undefined) {\n      const filename = (0, virtual_fs_1.basename)((0, virtual_fs_1.normalize)(path));\n\n      if (filename in workspaceFiles) {\n        format = workspaceFiles[filename];\n      }\n    }\n\n    if (format === undefined) {\n      throw new Error('Unable to determine format for workspace path.');\n    }\n\n    let workspace;\n\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        workspace = yield (0, reader_1.readJsonWorkspace)(path, host);\n        break;\n\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n\n    formatLookup.set(workspace, WorkspaceFormat.JSON);\n    return {\n      workspace\n    };\n  });\n  return _readWorkspace.apply(this, arguments);\n}\n\nexports.readWorkspace = readWorkspace;\n/**\n * Writes a `WorkspaceDefinition` to the underlying storage via the provided `WorkspaceHost`.\n * If the `WorkspaceDefinition` was created via the `readWorkspace` function, metadata will be\n * used to determine the path and format of the Workspace.  In all other cases, the `path` and\n * `format` options must be specified as they would be otherwise unknown.\n *\n * @param workspace The `WorkspaceDefinition` that will be written.\n * @param host The `WorkspaceHost` to use to access/write the file and directory data.\n * @param path The path to a file location for the output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n * @param format The `WorkspaceFormat` to use for output. Required if `readWorkspace` was not\n * used to create the `WorkspaceDefinition`.  Optional otherwise; will override the\n * `WorkspaceDefinition` metadata if provided.\n *\n *\n * @return An `Promise` of type `void`.\n */\n\nfunction writeWorkspace(_x4, _x5, _x6, _x7) {\n  return _writeWorkspace.apply(this, arguments);\n}\n\nfunction _writeWorkspace() {\n  _writeWorkspace = _asyncToGenerator(function* (workspace, host, path, format) {\n    if (format === undefined) {\n      format = formatLookup.get(workspace);\n\n      if (format === undefined) {\n        throw new Error('A format is required for custom workspace objects.');\n      }\n    }\n\n    switch (format) {\n      case WorkspaceFormat.JSON:\n        return (0, writer_1.writeJsonWorkspace)(workspace, host, path);\n\n      default:\n        throw new Error('Unsupported workspace format.');\n    }\n  });\n  return _writeWorkspace.apply(this, arguments);\n}\n\nexports.writeWorkspace = writeWorkspace;","map":null,"metadata":{},"sourceType":"script"}