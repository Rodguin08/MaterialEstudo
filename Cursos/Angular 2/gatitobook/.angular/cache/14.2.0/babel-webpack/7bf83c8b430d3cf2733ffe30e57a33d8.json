{"ast":null,"code":"/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { createScanner } from './scanner';\nvar ParseOptions = /*#__PURE__*/(() => {\n  (function (ParseOptions) {\n    ParseOptions.DEFAULT = {\n      allowTrailingComma: false\n    };\n  })(ParseOptions || (ParseOptions = {}));\n\n  return ParseOptions;\n})();\n\n/**\n * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.\n */\nexport function getLocation(text, position) {\n  var segments = []; // strings or numbers\n\n  var earlyReturnException = new Object();\n  var previousNode = undefined;\n  var previousNodeInst = {\n    value: {},\n    offset: 0,\n    length: 0,\n    type: 'object',\n    parent: undefined\n  };\n  var isAtPropertyKey = false;\n\n  function setPreviousNode(value, offset, length, type) {\n    previousNodeInst.value = value;\n    previousNodeInst.offset = offset;\n    previousNodeInst.length = length;\n    previousNodeInst.type = type;\n    previousNodeInst.colonOffset = undefined;\n    previousNode = previousNodeInst;\n  }\n\n  try {\n    visit(text, {\n      onObjectBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        isAtPropertyKey = position > offset;\n        segments.push(''); // push a placeholder (will be replaced)\n      },\n      onObjectProperty: function (name, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(name, offset, length, 'property');\n        segments[segments.length - 1] = name;\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onObjectEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onArrayBegin: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.push(0);\n      },\n      onArrayEnd: function (offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        previousNode = undefined;\n        segments.pop();\n      },\n      onLiteralValue: function (value, offset, length) {\n        if (position < offset) {\n          throw earlyReturnException;\n        }\n\n        setPreviousNode(value, offset, length, getNodeType(value));\n\n        if (position <= offset + length) {\n          throw earlyReturnException;\n        }\n      },\n      onSeparator: function (sep, offset, length) {\n        if (position <= offset) {\n          throw earlyReturnException;\n        }\n\n        if (sep === ':' && previousNode && previousNode.type === 'property') {\n          previousNode.colonOffset = offset;\n          isAtPropertyKey = false;\n          previousNode = undefined;\n        } else if (sep === ',') {\n          var last = segments[segments.length - 1];\n\n          if (typeof last === 'number') {\n            segments[segments.length - 1] = last + 1;\n          } else {\n            isAtPropertyKey = true;\n            segments[segments.length - 1] = '';\n          }\n\n          previousNode = undefined;\n        }\n      }\n    });\n  } catch (e) {\n    if (e !== earlyReturnException) {\n      throw e;\n    }\n  }\n\n  return {\n    path: segments,\n    previousNode: previousNode,\n    isAtPropertyKey: isAtPropertyKey,\n    matches: function (pattern) {\n      var k = 0;\n\n      for (var i = 0; k < pattern.length && i < segments.length; i++) {\n        if (pattern[k] === segments[i] || pattern[k] === '*') {\n          k++;\n        } else if (pattern[k] !== '**') {\n          return false;\n        }\n      }\n\n      return k === pattern.length;\n    }\n  };\n}\n/**\n * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n * Therefore always check the errors list to find out if the input was valid.\n */\n\nexport function parse(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentProperty = null;\n  var currentParent = [];\n  var previousParents = [];\n\n  function onValue(value) {\n    if (Array.isArray(currentParent)) {\n      currentParent.push(value);\n    } else if (currentProperty !== null) {\n      currentParent[currentProperty] = value;\n    }\n  }\n\n  var visitor = {\n    onObjectBegin: function () {\n      var object = {};\n      onValue(object);\n      previousParents.push(currentParent);\n      currentParent = object;\n      currentProperty = null;\n    },\n    onObjectProperty: function (name) {\n      currentProperty = name;\n    },\n    onObjectEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onArrayBegin: function () {\n      var array = [];\n      onValue(array);\n      previousParents.push(currentParent);\n      currentParent = array;\n      currentProperty = null;\n    },\n    onArrayEnd: function () {\n      currentParent = previousParents.pop();\n    },\n    onLiteralValue: onValue,\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  return currentParent[0];\n}\n/**\n * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.\n */\n\nexport function parseTree(text, errors, options) {\n  if (errors === void 0) {\n    errors = [];\n  }\n\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var currentParent = {\n    type: 'array',\n    offset: -1,\n    length: -1,\n    children: [],\n    parent: undefined\n  }; // artificial root\n\n  function ensurePropertyComplete(endOffset) {\n    if (currentParent.type === 'property') {\n      currentParent.length = endOffset - currentParent.offset;\n      currentParent = currentParent.parent;\n    }\n  }\n\n  function onValue(valueNode) {\n    currentParent.children.push(valueNode);\n    return valueNode;\n  }\n\n  var visitor = {\n    onObjectBegin: function (offset) {\n      currentParent = onValue({\n        type: 'object',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onObjectProperty: function (name, offset, length) {\n      currentParent = onValue({\n        type: 'property',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n      currentParent.children.push({\n        type: 'string',\n        value: name,\n        offset: offset,\n        length: length,\n        parent: currentParent\n      });\n    },\n    onObjectEnd: function (offset, length) {\n      ensurePropertyComplete(offset + length); // in case of a missing value for a property: make sure property is complete\n\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onArrayBegin: function (offset, length) {\n      currentParent = onValue({\n        type: 'array',\n        offset: offset,\n        length: -1,\n        parent: currentParent,\n        children: []\n      });\n    },\n    onArrayEnd: function (offset, length) {\n      currentParent.length = offset + length - currentParent.offset;\n      currentParent = currentParent.parent;\n      ensurePropertyComplete(offset + length);\n    },\n    onLiteralValue: function (value, offset, length) {\n      onValue({\n        type: getNodeType(value),\n        offset: offset,\n        length: length,\n        parent: currentParent,\n        value: value\n      });\n      ensurePropertyComplete(offset + length);\n    },\n    onSeparator: function (sep, offset, length) {\n      if (currentParent.type === 'property') {\n        if (sep === ':') {\n          currentParent.colonOffset = offset;\n        } else if (sep === ',') {\n          ensurePropertyComplete(offset);\n        }\n      }\n    },\n    onError: function (error, offset, length) {\n      errors.push({\n        error: error,\n        offset: offset,\n        length: length\n      });\n    }\n  };\n  visit(text, visitor, options);\n  var result = currentParent.children[0];\n\n  if (result) {\n    delete result.parent;\n  }\n\n  return result;\n}\n/**\n * Finds the node at the given path in a JSON DOM.\n */\n\nexport function findNodeAtLocation(root, path) {\n  if (!root) {\n    return undefined;\n  }\n\n  var node = root;\n\n  for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {\n    var segment = path_1[_i];\n\n    if (typeof segment === 'string') {\n      if (node.type !== 'object' || !Array.isArray(node.children)) {\n        return undefined;\n      }\n\n      var found = false;\n\n      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {\n        var propertyNode = _b[_a];\n\n        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment && propertyNode.children.length === 2) {\n          node = propertyNode.children[1];\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        return undefined;\n      }\n    } else {\n      var index = segment;\n\n      if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {\n        return undefined;\n      }\n\n      node = node.children[index];\n    }\n  }\n\n  return node;\n}\n/**\n * Gets the JSON path of the given JSON DOM node\n */\n\nexport function getNodePath(node) {\n  if (!node.parent || !node.parent.children) {\n    return [];\n  }\n\n  var path = getNodePath(node.parent);\n\n  if (node.parent.type === 'property') {\n    var key = node.parent.children[0].value;\n    path.push(key);\n  } else if (node.parent.type === 'array') {\n    var index = node.parent.children.indexOf(node);\n\n    if (index !== -1) {\n      path.push(index);\n    }\n  }\n\n  return path;\n}\n/**\n * Evaluates the JavaScript object of the given JSON DOM node\n */\n\nexport function getNodeValue(node) {\n  switch (node.type) {\n    case 'array':\n      return node.children.map(getNodeValue);\n\n    case 'object':\n      var obj = Object.create(null);\n\n      for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n        var prop = _a[_i];\n        var valueNode = prop.children[1];\n\n        if (valueNode) {\n          obj[prop.children[0].value] = getNodeValue(valueNode);\n        }\n      }\n\n      return obj;\n\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'boolean':\n      return node.value;\n\n    default:\n      return undefined;\n  }\n}\nexport function contains(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  return offset >= node.offset && offset < node.offset + node.length || includeRightBound && offset === node.offset + node.length;\n}\n/**\n * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.\n */\n\nexport function findNodeAtOffset(node, offset, includeRightBound) {\n  if (includeRightBound === void 0) {\n    includeRightBound = false;\n  }\n\n  if (contains(node, offset, includeRightBound)) {\n    var children = node.children;\n\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length && children[i].offset <= offset; i++) {\n        var item = findNodeAtOffset(children[i], offset, includeRightBound);\n\n        if (item) {\n          return item;\n        }\n      }\n    }\n\n    return node;\n  }\n\n  return undefined;\n}\n/**\n * Parses the given text and invokes the visitor functions for each object, array and literal reached.\n */\n\nexport function visit(text, visitor, options) {\n  if (options === void 0) {\n    options = ParseOptions.DEFAULT;\n  }\n\n  var _scanner = createScanner(text, false); // Important: Only pass copies of this to visitor functions to prevent accidental modification, and\n  // to not affect visitor functions which stored a reference to a previous JSONPath\n\n\n  var _jsonPath = [];\n\n  function toNoArgVisit(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toNoArgVisitWithPath(visitFunction) {\n    return visitFunction ? function () {\n      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () {\n        return _jsonPath.slice();\n      });\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisit(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());\n    } : function () {\n      return true;\n    };\n  }\n\n  function toOneArgVisitWithPath(visitFunction) {\n    return visitFunction ? function (arg) {\n      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter(), function () {\n        return _jsonPath.slice();\n      });\n    } : function () {\n      return true;\n    };\n  }\n\n  var onObjectBegin = toNoArgVisitWithPath(visitor.onObjectBegin),\n      onObjectProperty = toOneArgVisitWithPath(visitor.onObjectProperty),\n      onObjectEnd = toNoArgVisit(visitor.onObjectEnd),\n      onArrayBegin = toNoArgVisitWithPath(visitor.onArrayBegin),\n      onArrayEnd = toNoArgVisit(visitor.onArrayEnd),\n      onLiteralValue = toOneArgVisitWithPath(visitor.onLiteralValue),\n      onSeparator = toOneArgVisit(visitor.onSeparator),\n      onComment = toNoArgVisit(visitor.onComment),\n      onError = toOneArgVisit(visitor.onError);\n  var disallowComments = options && options.disallowComments;\n  var allowTrailingComma = options && options.allowTrailingComma;\n\n  function scanNext() {\n    while (true) {\n      var token = _scanner.scan();\n\n      switch (_scanner.getTokenError()) {\n        case 4\n        /* ScanError.InvalidUnicode */\n        :\n          handleError(14\n          /* ParseErrorCode.InvalidUnicode */\n          );\n          break;\n\n        case 5\n        /* ScanError.InvalidEscapeCharacter */\n        :\n          handleError(15\n          /* ParseErrorCode.InvalidEscapeCharacter */\n          );\n          break;\n\n        case 3\n        /* ScanError.UnexpectedEndOfNumber */\n        :\n          handleError(13\n          /* ParseErrorCode.UnexpectedEndOfNumber */\n          );\n          break;\n\n        case 1\n        /* ScanError.UnexpectedEndOfComment */\n        :\n          if (!disallowComments) {\n            handleError(11\n            /* ParseErrorCode.UnexpectedEndOfComment */\n            );\n          }\n\n          break;\n\n        case 2\n        /* ScanError.UnexpectedEndOfString */\n        :\n          handleError(12\n          /* ParseErrorCode.UnexpectedEndOfString */\n          );\n          break;\n\n        case 6\n        /* ScanError.InvalidCharacter */\n        :\n          handleError(16\n          /* ParseErrorCode.InvalidCharacter */\n          );\n          break;\n      }\n\n      switch (token) {\n        case 12\n        /* SyntaxKind.LineCommentTrivia */\n        :\n        case 13\n        /* SyntaxKind.BlockCommentTrivia */\n        :\n          if (disallowComments) {\n            handleError(10\n            /* ParseErrorCode.InvalidCommentToken */\n            );\n          } else {\n            onComment();\n          }\n\n          break;\n\n        case 16\n        /* SyntaxKind.Unknown */\n        :\n          handleError(1\n          /* ParseErrorCode.InvalidSymbol */\n          );\n          break;\n\n        case 15\n        /* SyntaxKind.Trivia */\n        :\n        case 14\n        /* SyntaxKind.LineBreakTrivia */\n        :\n          break;\n\n        default:\n          return token;\n      }\n    }\n  }\n\n  function handleError(error, skipUntilAfter, skipUntil) {\n    if (skipUntilAfter === void 0) {\n      skipUntilAfter = [];\n    }\n\n    if (skipUntil === void 0) {\n      skipUntil = [];\n    }\n\n    onError(error);\n\n    if (skipUntilAfter.length + skipUntil.length > 0) {\n      var token = _scanner.getToken();\n\n      while (token !== 17\n      /* SyntaxKind.EOF */\n      ) {\n        if (skipUntilAfter.indexOf(token) !== -1) {\n          scanNext();\n          break;\n        } else if (skipUntil.indexOf(token) !== -1) {\n          break;\n        }\n\n        token = scanNext();\n      }\n    }\n  }\n\n  function parseString(isValue) {\n    var value = _scanner.getTokenValue();\n\n    if (isValue) {\n      onLiteralValue(value);\n    } else {\n      onObjectProperty(value); // add property name afterwards\n\n      _jsonPath.push(value);\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseLiteral() {\n    switch (_scanner.getToken()) {\n      case 11\n      /* SyntaxKind.NumericLiteral */\n      :\n        var tokenValue = _scanner.getTokenValue();\n\n        var value = Number(tokenValue);\n\n        if (isNaN(value)) {\n          handleError(2\n          /* ParseErrorCode.InvalidNumberFormat */\n          );\n          value = 0;\n        }\n\n        onLiteralValue(value);\n        break;\n\n      case 7\n      /* SyntaxKind.NullKeyword */\n      :\n        onLiteralValue(null);\n        break;\n\n      case 8\n      /* SyntaxKind.TrueKeyword */\n      :\n        onLiteralValue(true);\n        break;\n\n      case 9\n      /* SyntaxKind.FalseKeyword */\n      :\n        onLiteralValue(false);\n        break;\n\n      default:\n        return false;\n    }\n\n    scanNext();\n    return true;\n  }\n\n  function parseProperty() {\n    if (_scanner.getToken() !== 10\n    /* SyntaxKind.StringLiteral */\n    ) {\n      handleError(3\n      /* ParseErrorCode.PropertyNameExpected */\n      , [], [2\n      /* SyntaxKind.CloseBraceToken */\n      , 5\n      /* SyntaxKind.CommaToken */\n      ]);\n      return false;\n    }\n\n    parseString(false);\n\n    if (_scanner.getToken() === 6\n    /* SyntaxKind.ColonToken */\n    ) {\n      onSeparator(':');\n      scanNext(); // consume colon\n\n      if (!parseValue()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [2\n        /* SyntaxKind.CloseBraceToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n    } else {\n      handleError(5\n      /* ParseErrorCode.ColonExpected */\n      , [], [2\n      /* SyntaxKind.CloseBraceToken */\n      , 5\n      /* SyntaxKind.CommaToken */\n      ]);\n    }\n\n    _jsonPath.pop(); // remove processed property name\n\n\n    return true;\n  }\n\n  function parseObject() {\n    onObjectBegin();\n    scanNext(); // consume open brace\n\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 2\n    /* SyntaxKind.CloseBraceToken */\n    && _scanner.getToken() !== 17\n    /* SyntaxKind.EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* SyntaxKind.CommaToken */\n      ) {\n        if (!needsComma) {\n          handleError(4\n          /* ParseErrorCode.ValueExpected */\n          , [], []);\n        }\n\n        onSeparator(',');\n        scanNext(); // consume comma\n\n        if (_scanner.getToken() === 2\n        /* SyntaxKind.CloseBraceToken */\n        && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6\n        /* ParseErrorCode.CommaExpected */\n        , [], []);\n      }\n\n      if (!parseProperty()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [2\n        /* SyntaxKind.CloseBraceToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onObjectEnd();\n\n    if (_scanner.getToken() !== 2\n    /* SyntaxKind.CloseBraceToken */\n    ) {\n      handleError(7\n      /* ParseErrorCode.CloseBraceExpected */\n      , [2\n      /* SyntaxKind.CloseBraceToken */\n      ], []);\n    } else {\n      scanNext(); // consume close brace\n    }\n\n    return true;\n  }\n\n  function parseArray() {\n    onArrayBegin();\n    scanNext(); // consume open bracket\n\n    var isFirstElement = true;\n    var needsComma = false;\n\n    while (_scanner.getToken() !== 4\n    /* SyntaxKind.CloseBracketToken */\n    && _scanner.getToken() !== 17\n    /* SyntaxKind.EOF */\n    ) {\n      if (_scanner.getToken() === 5\n      /* SyntaxKind.CommaToken */\n      ) {\n        if (!needsComma) {\n          handleError(4\n          /* ParseErrorCode.ValueExpected */\n          , [], []);\n        }\n\n        onSeparator(',');\n        scanNext(); // consume comma\n\n        if (_scanner.getToken() === 4\n        /* SyntaxKind.CloseBracketToken */\n        && allowTrailingComma) {\n          break;\n        }\n      } else if (needsComma) {\n        handleError(6\n        /* ParseErrorCode.CommaExpected */\n        , [], []);\n      }\n\n      if (isFirstElement) {\n        _jsonPath.push(0);\n\n        isFirstElement = false;\n      } else {\n        _jsonPath[_jsonPath.length - 1]++;\n      }\n\n      if (!parseValue()) {\n        handleError(4\n        /* ParseErrorCode.ValueExpected */\n        , [], [4\n        /* SyntaxKind.CloseBracketToken */\n        , 5\n        /* SyntaxKind.CommaToken */\n        ]);\n      }\n\n      needsComma = true;\n    }\n\n    onArrayEnd();\n\n    if (!isFirstElement) {\n      _jsonPath.pop(); // remove array index\n\n    }\n\n    if (_scanner.getToken() !== 4\n    /* SyntaxKind.CloseBracketToken */\n    ) {\n      handleError(8\n      /* ParseErrorCode.CloseBracketExpected */\n      , [4\n      /* SyntaxKind.CloseBracketToken */\n      ], []);\n    } else {\n      scanNext(); // consume close bracket\n    }\n\n    return true;\n  }\n\n  function parseValue() {\n    switch (_scanner.getToken()) {\n      case 3\n      /* SyntaxKind.OpenBracketToken */\n      :\n        return parseArray();\n\n      case 1\n      /* SyntaxKind.OpenBraceToken */\n      :\n        return parseObject();\n\n      case 10\n      /* SyntaxKind.StringLiteral */\n      :\n        return parseString(true);\n\n      default:\n        return parseLiteral();\n    }\n  }\n\n  scanNext();\n\n  if (_scanner.getToken() === 17\n  /* SyntaxKind.EOF */\n  ) {\n    if (options.allowEmptyContent) {\n      return true;\n    }\n\n    handleError(4\n    /* ParseErrorCode.ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (!parseValue()) {\n    handleError(4\n    /* ParseErrorCode.ValueExpected */\n    , [], []);\n    return false;\n  }\n\n  if (_scanner.getToken() !== 17\n  /* SyntaxKind.EOF */\n  ) {\n    handleError(9\n    /* ParseErrorCode.EndOfFileExpected */\n    , [], []);\n  }\n\n  return true;\n}\n/**\n * Takes JSON with JavaScript-style comments and remove\n * them. Optionally replaces every none-newline character\n * of comments with a replaceCharacter\n */\n\nexport function stripComments(text, replaceCh) {\n  var _scanner = createScanner(text),\n      parts = [],\n      kind,\n      offset = 0,\n      pos;\n\n  do {\n    pos = _scanner.getPosition();\n    kind = _scanner.scan();\n\n    switch (kind) {\n      case 12\n      /* SyntaxKind.LineCommentTrivia */\n      :\n      case 13\n      /* SyntaxKind.BlockCommentTrivia */\n      :\n      case 17\n      /* SyntaxKind.EOF */\n      :\n        if (offset !== pos) {\n          parts.push(text.substring(offset, pos));\n        }\n\n        if (replaceCh !== undefined) {\n          parts.push(_scanner.getTokenValue().replace(/[^\\r\\n]/g, replaceCh));\n        }\n\n        offset = _scanner.getPosition();\n        break;\n    }\n  } while (kind !== 17\n  /* SyntaxKind.EOF */\n  );\n\n  return parts.join('');\n}\nexport function getNodeType(value) {\n  switch (typeof value) {\n    case 'boolean':\n      return 'boolean';\n\n    case 'number':\n      return 'number';\n\n    case 'string':\n      return 'string';\n\n    case 'object':\n      {\n        if (!value) {\n          return 'null';\n        } else if (Array.isArray(value)) {\n          return 'array';\n        }\n\n        return 'object';\n      }\n\n    default:\n      return 'null';\n  }\n}","map":null,"metadata":{},"sourceType":"module"}