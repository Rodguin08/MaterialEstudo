{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst {\n  FetchError,\n  Request,\n  isRedirect\n} = require('minipass-fetch');\n\nconst url = require('url');\n\nconst CachePolicy = require('./cache/policy.js');\n\nconst cache = require('./cache/index.js');\n\nconst remote = require('./remote.js'); // given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\n\n\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) {\n    return false;\n  }\n\n  if (options.redirect === 'manual') {\n    return false;\n  }\n\n  if (options.redirect === 'error') {\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', {\n      code: 'ENOREDIRECT'\n    });\n  }\n\n  if (!response.headers.has('location')) {\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', {\n      code: 'EINVALIDREDIRECT'\n    });\n  }\n\n  if (request.counter >= request.follow) {\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', {\n      code: 'EMAXREDIRECT'\n    });\n  }\n\n  return true;\n}; // given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\n\n\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options\n  };\n  const location = response.headers.get('location');\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url); // Comment below is used under the following license:\n\n  /**\n   * @license\n   * Copyright (c) 2010-2012 Mikeal Rogers\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   * http://www.apache.org/licenses/LICENSE-2.0\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an \"AS\n   * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n   * express or implied. See the License for the specific language\n   * governing permissions and limitations under the License.\n   */\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) {\n    request.headers.delete('authorization');\n    request.headers.delete('cookie');\n  } // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n\n\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n\n  _opts.headers = {};\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  const redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\n\nconst fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (request, options) {\n    const response = CachePolicy.storable(request, options) ? yield cache(request, options) : yield remote(request, options); // if the request wasn't a GET or HEAD, and the response\n    // status is between 200 and 399 inclusive, invalidate the\n    // request url\n\n    if (!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399) {\n      yield cache.invalidate(request, options);\n    }\n\n    if (!canFollowRedirect(request, response, options)) {\n      return response;\n    }\n\n    const redirect = getRedirect(request, response, options);\n    return fetch(redirect.request, redirect.options);\n  });\n\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = fetch;","map":null,"metadata":{},"sourceType":"script"}