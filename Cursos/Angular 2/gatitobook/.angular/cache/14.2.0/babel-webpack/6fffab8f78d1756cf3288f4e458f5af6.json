{"ast":null,"code":"'use strict';\n\nconst invalidTokenRegex = /[^^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nconst validateName = name => {\n  name = `${name}`;\n\n  if (invalidTokenRegex.test(name) || name === '') {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n};\n\nconst validateValue = value => {\n  value = `${value}`;\n\n  if (invalidHeaderCharRegex.test(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n};\n\nconst find = (map, name) => {\n  name = name.toLowerCase();\n\n  for (const key in map) {\n    if (key.toLowerCase() === name) {\n      return key;\n    }\n  }\n\n  return undefined;\n};\n\nconst MAP = Symbol('map');\n\nclass Headers {\n  constructor(init = undefined) {\n    this[MAP] = Object.create(null);\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n\n      return;\n    } // no-op\n\n\n    if (init === undefined || init === null) {\n      return;\n    }\n\n    if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        const pairs = [];\n\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n\n          const arrPair = Array.from(pair);\n\n          if (arrPair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          pairs.push(arrPair);\n        }\n\n        for (const pair of pairs) {\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          this.append(key, init[key]);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n  }\n\n  get(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n\n    if (key === undefined) {\n      return null;\n    }\n\n    return this[MAP][key].join(', ');\n  }\n\n  forEach(callback, thisArg = undefined) {\n    let pairs = getHeaders(this);\n\n    for (let i = 0; i < pairs.length; i++) {\n      const [name, value] = pairs[i];\n      callback.call(thisArg, value, name, this); // refresh in case the callback added more headers\n\n      pairs = getHeaders(this);\n    }\n  }\n\n  set(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n    this[MAP][key !== undefined ? key : name] = [value];\n  }\n\n  append(name, value) {\n    name = `${name}`;\n    value = `${value}`;\n    validateName(name);\n    validateValue(value);\n    const key = find(this[MAP], name);\n\n    if (key !== undefined) {\n      this[MAP][key].push(value);\n    } else {\n      this[MAP][name] = [value];\n    }\n  }\n\n  has(name) {\n    name = `${name}`;\n    validateName(name);\n    return find(this[MAP], name) !== undefined;\n  }\n\n  delete(name) {\n    name = `${name}`;\n    validateName(name);\n    const key = find(this[MAP], name);\n\n    if (key !== undefined) {\n      delete this[MAP][key];\n    }\n  }\n\n  raw() {\n    return this[MAP];\n  }\n\n  keys() {\n    return new HeadersIterator(this, 'key');\n  }\n\n  values() {\n    return new HeadersIterator(this, 'value');\n  }\n\n  [Symbol.iterator]() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  entries() {\n    return new HeadersIterator(this, 'key+value');\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Headers';\n  }\n\n  static exportNodeCompatibleHeaders(headers) {\n    const obj = Object.assign(Object.create(null), headers[MAP]); // http.request() only supports string as Host header. This hack makes\n    // specifying custom Host header possible.\n\n    const hostHeaderKey = find(headers[MAP], 'Host');\n\n    if (hostHeaderKey !== undefined) {\n      obj[hostHeaderKey] = obj[hostHeaderKey][0];\n    }\n\n    return obj;\n  }\n\n  static createHeadersLenient(obj) {\n    const headers = new Headers();\n\n    for (const name of Object.keys(obj)) {\n      if (invalidTokenRegex.test(name)) {\n        continue;\n      }\n\n      if (Array.isArray(obj[name])) {\n        for (const val of obj[name]) {\n          if (invalidHeaderCharRegex.test(val)) {\n            continue;\n          }\n\n          if (headers[MAP][name] === undefined) {\n            headers[MAP][name] = [val];\n          } else {\n            headers[MAP][name].push(val);\n          }\n        }\n      } else if (!invalidHeaderCharRegex.test(obj[name])) {\n        headers[MAP][name] = [obj[name]];\n      }\n    }\n\n    return headers;\n  }\n\n}\n\nObject.defineProperties(Headers.prototype, {\n  get: {\n    enumerable: true\n  },\n  forEach: {\n    enumerable: true\n  },\n  set: {\n    enumerable: true\n  },\n  append: {\n    enumerable: true\n  },\n  has: {\n    enumerable: true\n  },\n  delete: {\n    enumerable: true\n  },\n  keys: {\n    enumerable: true\n  },\n  values: {\n    enumerable: true\n  },\n  entries: {\n    enumerable: true\n  }\n});\n\nconst getHeaders = (headers, kind = 'key+value') => Object.keys(headers[MAP]).sort().map(kind === 'key' ? k => k.toLowerCase() : kind === 'value' ? k => headers[MAP][k].join(', ') : k => [k.toLowerCase(), headers[MAP][k].join(', ')]);\n\nconst INTERNAL = Symbol('internal');\n\nclass HeadersIterator {\n  constructor(target, kind) {\n    this[INTERNAL] = {\n      target,\n      kind,\n      index: 0\n    };\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'HeadersIterator';\n  }\n\n  next() {\n    /* istanbul ignore if: should be impossible */\n    if (!this || Object.getPrototypeOf(this) !== HeadersIterator.prototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n\n    const {\n      target,\n      kind,\n      index\n    } = this[INTERNAL];\n    const values = getHeaders(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    this[INTERNAL].index++;\n    return {\n      value: values[index],\n      done: false\n    };\n  }\n\n} // manually extend because 'extends' requires a ctor\n\n\nObject.setPrototypeOf(HeadersIterator.prototype, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nmodule.exports = Headers;","map":null,"metadata":{},"sourceType":"script"}