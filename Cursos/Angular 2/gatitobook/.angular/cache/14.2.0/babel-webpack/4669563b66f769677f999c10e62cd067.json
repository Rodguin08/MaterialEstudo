{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst index = require('./entry-index');\n\nconst memo = require('./memoization');\n\nconst write = require('./content/write');\n\nconst Flush = require('minipass-flush');\n\nconst {\n  PassThrough\n} = require('minipass-collect');\n\nconst Pipeline = require('minipass-pipeline');\n\nconst putOpts = opts => ({\n  algorithms: ['sha512'],\n  ...opts\n});\n\nmodule.exports = putData;\n\nfunction putData(_x, _x2, _x3) {\n  return _putData.apply(this, arguments);\n}\n\nfunction _putData() {\n  _putData = _asyncToGenerator(function* (cache, key, data, opts = {}) {\n    const {\n      memoize\n    } = opts;\n    opts = putOpts(opts);\n    const res = yield write(cache, data, opts);\n    const entry = yield index.insert(cache, key, res.integrity, { ...opts,\n      size: res.size\n    });\n\n    if (memoize) {\n      memo.put(cache, entry, data, opts);\n    }\n\n    return res.integrity;\n  });\n  return _putData.apply(this, arguments);\n}\n\nmodule.exports.stream = putStream;\n\nfunction putStream(cache, key, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  opts = putOpts(opts);\n  let integrity;\n  let size;\n  let error;\n  let memoData;\n  const pipeline = new Pipeline(); // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  } // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n\n\n  const contentStream = write.stream(cache, opts).on('integrity', int => {\n    integrity = int;\n  }).on('size', s => {\n    size = s;\n  }).on('error', err => {\n    error = err;\n  });\n  pipeline.push(contentStream); // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n\n  pipeline.push(new Flush({\n    flush() {\n      return _asyncToGenerator(function* () {\n        if (!error) {\n          const entry = yield index.insert(cache, key, integrity, { ...opts,\n            size\n          });\n\n          if (memoize && memoData) {\n            memo.put(cache, entry, memoData, opts);\n          }\n\n          pipeline.emit('integrity', integrity);\n          pipeline.emit('size', size);\n        }\n      })();\n    }\n\n  }));\n  return pipeline;\n}","map":null,"metadata":{},"sourceType":"script"}