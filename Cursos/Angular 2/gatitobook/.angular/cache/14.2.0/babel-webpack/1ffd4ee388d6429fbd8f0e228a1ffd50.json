{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ConfigCommandModule = void 0;\n\nconst path_1 = /*#__PURE__*/require(\"path\");\n\nconst uuid_1 = /*#__PURE__*/require(\"uuid\");\n\nconst command_module_1 = /*#__PURE__*/require(\"../../command-builder/command-module\");\n\nconst config_1 = /*#__PURE__*/require(\"../../utilities/config\");\n\nconst json_file_1 = /*#__PURE__*/require(\"../../utilities/json-file\");\n\nclass ConfigCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.command = 'config [json-path] [value]';\n    this.describe = 'Retrieves or sets Angular configuration values in the angular.json file for the workspace.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n\n  builder(localYargs) {\n    return localYargs.positional('json-path', {\n      description: `The configuration key to set or query, in JSON path format. ` + `For example: \"a[3].foo.bar[2]\". If no new value is provided, returns the current value of this key.`,\n      type: 'string'\n    }).positional('value', {\n      description: 'If provided, a new value for the given configuration key.',\n      type: 'string'\n    }).option('global', {\n      description: `Access the global configuration in the caller's home directory.`,\n      alias: ['g'],\n      type: 'boolean',\n      default: false\n    }).strict();\n  }\n\n  run(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const level = options.global ? 'global' : 'local';\n      const [config] = yield (0, config_1.getWorkspaceRaw)(level);\n\n      if (options.value == undefined) {\n        if (!config) {\n          _this.context.logger.error('No config found.');\n\n          return 1;\n        }\n\n        return _this.get(config, options);\n      } else {\n        return _this.set(options);\n      }\n    })();\n  }\n\n  get(jsonFile, options) {\n    const {\n      logger\n    } = this.context;\n    const value = options.jsonPath ? jsonFile.get(parseJsonPath(options.jsonPath)) : jsonFile.content;\n\n    if (value === undefined) {\n      logger.error('Value cannot be found.');\n      return 1;\n    } else if (typeof value === 'string') {\n      logger.info(value);\n    } else {\n      logger.info(JSON.stringify(value, null, 2));\n    }\n\n    return 0;\n  }\n\n  set(options) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      if (!((_a = options.jsonPath) === null || _a === void 0 ? void 0 : _a.trim())) {\n        throw new command_module_1.CommandModuleError('Invalid Path.');\n      }\n\n      const [config, configPath] = yield (0, config_1.getWorkspaceRaw)(options.global ? 'global' : 'local');\n      const {\n        logger\n      } = _this2.context;\n\n      if (!config || !configPath) {\n        throw new command_module_1.CommandModuleError('Confguration file cannot be found.');\n      }\n\n      const normalizeUUIDValue = v => v === '' ? (0, uuid_1.v4)() : `${v}`;\n\n      const value = options.jsonPath === 'cli.analyticsSharing.uuid' ? normalizeUUIDValue(options.value) : options.value;\n      const modified = config.modify(parseJsonPath(options.jsonPath), normalizeValue(value));\n\n      if (!modified) {\n        logger.error('Value cannot be found.');\n        return 1;\n      }\n\n      yield (0, config_1.validateWorkspace)((0, json_file_1.parseJson)(config.content), (_b = options.global) !== null && _b !== void 0 ? _b : false);\n      config.save();\n      return 0;\n    })();\n  }\n\n}\n\nexports.ConfigCommandModule = ConfigCommandModule;\n/**\n * Splits a JSON path string into fragments. Fragments can be used to get the value referenced\n * by the path. For example, a path of \"a[3].foo.bar[2]\" would give you a fragment array of\n * [\"a\", 3, \"foo\", \"bar\", 2].\n * @param path The JSON string to parse.\n * @returns {(string|number)[]} The fragments for the string.\n * @private\n */\n\nfunction parseJsonPath(path) {\n  const fragments = (path || '').split(/\\./g);\n  const result = [];\n\n  while (fragments.length > 0) {\n    const fragment = fragments.shift();\n\n    if (fragment == undefined) {\n      break;\n    }\n\n    const match = fragment.match(/([^[]+)((\\[.*\\])*)/);\n\n    if (!match) {\n      throw new command_module_1.CommandModuleError('Invalid JSON path.');\n    }\n\n    result.push(match[1]);\n\n    if (match[2]) {\n      const indices = match[2].slice(1, -1).split('][').map(x => /^\\d$/.test(x) ? +x : x.replace(/\"|'/g, ''));\n      result.push(...indices);\n    }\n  }\n\n  return result.filter(fragment => fragment != null);\n}\n\nfunction normalizeValue(value) {\n  const valueString = `${value}`.trim();\n\n  switch (valueString) {\n    case 'true':\n      return true;\n\n    case 'false':\n      return false;\n\n    case 'null':\n      return null;\n\n    case 'undefined':\n      return undefined;\n  }\n\n  if (isFinite(+valueString)) {\n    return +valueString;\n  }\n\n  try {\n    // We use `JSON.parse` instead of `parseJson` because the latter will parse UUIDs\n    // and convert them into a numberic entities.\n    // Example: 73b61974-182c-48e4-b4c6-30ddf08c5c98 -> 73.\n    // These values should never contain comments, therefore using `JSON.parse` is safe.\n    return JSON.parse(valueString);\n  } catch {\n    return value;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}