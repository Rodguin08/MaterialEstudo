{"ast":null,"code":"// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']); // we have to use url.parse until we add the same shim that hosted-git-info has\n// to handle scp:// urls\n\nconst {\n  parse\n} = require('url'); // eslint-disable-line node/no-deprecated-api\n\n\nconst path = require('path');\n\nconst getRevs = require('./revs.js');\n\nconst spawn = require('./spawn.js');\n\nconst {\n  isWindows\n} = require('./utils.js');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst fs = require('fs');\n\nconst mkdirp = require('mkdirp');\n\nmodule.exports = (repo, ref = 'HEAD', target = null, opts = {}) => getRevs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\n\nconst maybeShallow = (repo, opts) => {\n  if (opts.gitShallow === false || opts.gitShallow) {\n    return opts.gitShallow;\n  }\n\n  return shallowHosts.has(parse(repo).host);\n};\n\nconst defaultTarget = (repo,\n/* istanbul ignore next */\ncwd = process.cwd()) => path.resolve(cwd, path.basename(repo.replace(/[/\\\\]?\\.git$/, '')));\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => {\n  if (!revDoc) {\n    return unresolved(repo, ref, target, opts);\n  }\n\n  if (revDoc.sha === revs.refs.HEAD.sha) {\n    return plain(repo, revDoc, target, opts);\n  }\n\n  if (revDoc.type === 'tag' || revDoc.type === 'branch') {\n    return branch(repo, revDoc, target, opts);\n  }\n\n  return other(repo, revDoc, target, opts);\n};\n\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  /* istanbul ignore next - will fail anyway, can't pull */\n\n  if (!revs) {\n    return null;\n  }\n\n  if (spec.gitRange) {\n    return pickManifest(revs, spec.gitRange, opts);\n  }\n\n  if (!ref) {\n    return revs.refs.HEAD;\n  }\n\n  if (revs.refs[ref]) {\n    return revs.refs[ref];\n  }\n\n  if (revs.shas[ref]) {\n    return revs.refs[revs.shas[ref][0]];\n  }\n\n  return null;\n}; // pull request or some other kind of advertised ref\n\n\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n}; // tag or branches.  use -b\n\n\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n}; // just the head.  clone it\n\n\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n\n  if (maybeShallow(repo, opts)) {\n    args.push('--depth=1');\n  }\n\n  if (isWindows(opts)) {\n    args.push('--config', 'core.longpaths=true');\n  }\n\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\nconst updateSubmodules = (target, opts) => new Promise(resolve => fs.stat(target + '/.gitmodules', er => {\n  if (er) {\n    return resolve(null);\n  }\n\n  return resolve(spawn(['submodule', 'update', '-q', '--init', '--recursive'], { ...opts,\n    cwd: target\n  }));\n}));\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(({\n    stdout\n  }) => stdout.trim());\n};","map":null,"metadata":{},"sourceType":"script"}