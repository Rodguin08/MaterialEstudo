{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndentLogger = void 0;\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * Keep an map of indentation => array of indentations based on the level.\n * This is to optimize calculating the prefix based on the indentation itself. Since most logs\n * come from similar levels, and with similar indentation strings, this will be shared by all\n * loggers. Also, string concatenation is expensive so performing concats for every log entries\n * is expensive; this alleviates it.\n */\n\n\nconst indentationMap = {};\n\nclass IndentLogger extends logger_1.Logger {\n  constructor(name, parent = null, indentation = '  ') {\n    super(name, parent);\n    indentationMap[indentation] = indentationMap[indentation] || [''];\n    const indentMap = indentationMap[indentation];\n    this._observable = this._observable.pipe((0, operators_1.map)(entry => {\n      const l = entry.path.filter(x => !!x).length;\n\n      if (l >= indentMap.length) {\n        let current = indentMap[indentMap.length - 1];\n\n        while (l >= indentMap.length) {\n          current += indentation;\n          indentMap.push(current);\n        }\n      }\n\n      entry.message = indentMap[l] + entry.message.split(/\\n/).join('\\n' + indentMap[l]);\n      return entry;\n    }));\n  }\n\n}\n\nexports.IndentLogger = IndentLogger;","map":null,"metadata":{},"sourceType":"script"}