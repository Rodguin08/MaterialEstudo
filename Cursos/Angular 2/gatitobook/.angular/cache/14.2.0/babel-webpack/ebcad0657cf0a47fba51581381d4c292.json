{"ast":null,"code":"'use strict';\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n/* eslint-disable no-control-regex */\n// this is a modified version of https://github.com/chalk/ansi-regex (MIT License)\n\n\nconst ANSI_REGEX = /[\\u001b\\u009b][[\\]#;?()]*(?:(?:(?:[^\\W_]*;?[^\\W_]*)\\u0007)|(?:(?:[0-9]{1,4}(;[0-9]{0,4})*)?[~0-9=<>cf-nqrtyA-PRZ]))/g;\n\nconst hasColor = () => {\n  if (typeof process !== 'undefined') {\n    return process.env.FORCE_COLOR !== '0';\n  }\n\n  return false;\n};\n\nconst create = () => {\n  const colors = {\n    enabled: hasColor(),\n    visible: true,\n    styles: {},\n    keys: {}\n  };\n\n  const ansi = style => {\n    let open = style.open = `\\u001b[${style.codes[0]}m`;\n    let close = style.close = `\\u001b[${style.codes[1]}m`;\n    let regex = style.regex = new RegExp(`\\\\u001b\\\\[${style.codes[1]}m`, 'g');\n\n    style.wrap = (input, newline) => {\n      if (input.includes(close)) input = input.replace(regex, close + open);\n      let output = open + input + close; // see https://github.com/chalk/chalk/pull/92, thanks to the\n      // chalk contributors for this fix. However, we've confirmed that\n      // this issue is also present in Windows terminals\n\n      return newline ? output.replace(/\\r*\\n/g, `${close}$&${open}`) : output;\n    };\n\n    return style;\n  };\n\n  const wrap = (style, input, newline) => {\n    return typeof style === 'function' ? style(input) : style.wrap(input, newline);\n  };\n\n  const style = (input, stack) => {\n    if (input === '' || input == null) return '';\n    if (colors.enabled === false) return input;\n    if (colors.visible === false) return '';\n    let str = '' + input;\n    let nl = str.includes('\\n');\n    let n = stack.length;\n\n    if (n > 0 && stack.includes('unstyle')) {\n      stack = [...new Set(['unstyle', ...stack])].reverse();\n    }\n\n    while (n-- > 0) str = wrap(colors.styles[stack[n]], str, nl);\n\n    return str;\n  };\n\n  const define = (name, codes, type) => {\n    colors.styles[name] = ansi({\n      name,\n      codes\n    });\n    let keys = colors.keys[type] || (colors.keys[type] = []);\n    keys.push(name);\n    Reflect.defineProperty(colors, name, {\n      configurable: true,\n      enumerable: true,\n\n      set(value) {\n        colors.alias(name, value);\n      },\n\n      get() {\n        let color = input => style(input, color.stack);\n\n        Reflect.setPrototypeOf(color, colors);\n        color.stack = this.stack ? this.stack.concat(name) : [name];\n        return color;\n      }\n\n    });\n  };\n\n  define('reset', [0, 0], 'modifier');\n  define('bold', [1, 22], 'modifier');\n  define('dim', [2, 22], 'modifier');\n  define('italic', [3, 23], 'modifier');\n  define('underline', [4, 24], 'modifier');\n  define('inverse', [7, 27], 'modifier');\n  define('hidden', [8, 28], 'modifier');\n  define('strikethrough', [9, 29], 'modifier');\n  define('black', [30, 39], 'color');\n  define('red', [31, 39], 'color');\n  define('green', [32, 39], 'color');\n  define('yellow', [33, 39], 'color');\n  define('blue', [34, 39], 'color');\n  define('magenta', [35, 39], 'color');\n  define('cyan', [36, 39], 'color');\n  define('white', [37, 39], 'color');\n  define('gray', [90, 39], 'color');\n  define('grey', [90, 39], 'color');\n  define('bgBlack', [40, 49], 'bg');\n  define('bgRed', [41, 49], 'bg');\n  define('bgGreen', [42, 49], 'bg');\n  define('bgYellow', [43, 49], 'bg');\n  define('bgBlue', [44, 49], 'bg');\n  define('bgMagenta', [45, 49], 'bg');\n  define('bgCyan', [46, 49], 'bg');\n  define('bgWhite', [47, 49], 'bg');\n  define('blackBright', [90, 39], 'bright');\n  define('redBright', [91, 39], 'bright');\n  define('greenBright', [92, 39], 'bright');\n  define('yellowBright', [93, 39], 'bright');\n  define('blueBright', [94, 39], 'bright');\n  define('magentaBright', [95, 39], 'bright');\n  define('cyanBright', [96, 39], 'bright');\n  define('whiteBright', [97, 39], 'bright');\n  define('bgBlackBright', [100, 49], 'bgBright');\n  define('bgRedBright', [101, 49], 'bgBright');\n  define('bgGreenBright', [102, 49], 'bgBright');\n  define('bgYellowBright', [103, 49], 'bgBright');\n  define('bgBlueBright', [104, 49], 'bgBright');\n  define('bgMagentaBright', [105, 49], 'bgBright');\n  define('bgCyanBright', [106, 49], 'bgBright');\n  define('bgWhiteBright', [107, 49], 'bgBright');\n  colors.ansiRegex = ANSI_REGEX;\n\n  colors.hasColor = colors.hasAnsi = str => {\n    colors.ansiRegex.lastIndex = 0;\n    return typeof str === 'string' && str !== '' && colors.ansiRegex.test(str);\n  };\n\n  colors.alias = (name, color) => {\n    let fn = typeof color === 'string' ? colors[color] : color;\n\n    if (typeof fn !== 'function') {\n      throw new TypeError('Expected alias to be the name of an existing color (string) or a function');\n    }\n\n    if (!fn.stack) {\n      Reflect.defineProperty(fn, 'name', {\n        value: name\n      });\n      colors.styles[name] = fn;\n      fn.stack = [name];\n    }\n\n    Reflect.defineProperty(colors, name, {\n      configurable: true,\n      enumerable: true,\n\n      set(value) {\n        colors.alias(name, value);\n      },\n\n      get() {\n        let color = input => style(input, color.stack);\n\n        Reflect.setPrototypeOf(color, colors);\n        color.stack = this.stack ? this.stack.concat(fn.stack) : fn.stack;\n        return color;\n      }\n\n    });\n  };\n\n  colors.theme = custom => {\n    if (!isObject(custom)) throw new TypeError('Expected theme to be an object');\n\n    for (let name of Object.keys(custom)) {\n      colors.alias(name, custom[name]);\n    }\n\n    return colors;\n  };\n\n  colors.alias('unstyle', str => {\n    if (typeof str === 'string' && str !== '') {\n      colors.ansiRegex.lastIndex = 0;\n      return str.replace(colors.ansiRegex, '');\n    }\n\n    return '';\n  });\n  colors.alias('noop', str => str);\n  colors.none = colors.clear = colors.noop;\n  colors.stripColor = colors.unstyle;\n  colors.symbols = require('./symbols');\n  colors.define = define;\n  return colors;\n};\n\nmodule.exports = create();\nmodule.exports.create = create;","map":null,"metadata":{},"sourceType":"script"}