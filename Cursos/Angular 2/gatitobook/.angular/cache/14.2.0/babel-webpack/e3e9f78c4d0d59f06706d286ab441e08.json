{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst fs = require('fs');\n\nconst sysPath = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nlet fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD,\n  EV_CHANGE,\n  EV_ADD_DIR,\n  EV_UNLINK,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN,\n  IDENTITY_FN\n} = require('./constants');\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\nconst statMethods = {\n  stat,\n  lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\n * @mixin\n */\n\n\nclass FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      try {\n        const stats = yield stat(path);\n        if (_this.fsw.closed) return;\n\n        if (sameTypes(info, stats)) {\n          _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } catch (error) {\n        if (error.code === 'EACCES') {\n          _this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          _this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    })();\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    var _this2 = this;\n\n    if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (fullPath, flags, info) {\n        if (_this2.fsw.closed) return;\n        if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n        const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n        if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n        const parent = sysPath.dirname(path);\n        const item = sysPath.basename(path);\n\n        const watchedDir = _this2.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n        if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n          if (typeof opts.ignored === FUNCTION_TYPE) {\n            let stats;\n\n            try {\n              stats = yield stat(path);\n            } catch (error) {}\n\n            if (_this2.fsw.closed) return;\n            if (_this2.checkIgnored(path, stats)) return;\n\n            if (sameTypes(info, stats)) {\n              _this2.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n            } else {\n              _this2.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n            }\n          } else {\n            _this2.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          switch (info.event) {\n            case FSEVENT_CREATED:\n            case FSEVENT_MODIFIED:\n              return _this2.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n            case FSEVENT_DELETED:\n            case FSEVENT_MOVED:\n              return _this2.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        }\n      });\n\n      return function watchCallback(_x, _x2, _x3) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      // don't follow the same symlink more than once\n      if (_this3.fsw.closed || _this3.fsw._symlinkPaths.has(fullPath)) return;\n\n      _this3.fsw._symlinkPaths.set(fullPath, true);\n\n      _this3.fsw._incrReadyCount();\n\n      try {\n        const linkTarget = yield realpath(linkPath);\n        if (_this3.fsw.closed) return;\n\n        if (_this3.fsw._isIgnored(linkTarget)) {\n          return _this3.fsw._emitReady();\n        }\n\n        _this3.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n        // that causes emitted paths to incorporate the link's path\n\n\n        _this3._addToFsEvents(linkTarget || linkPath, path => {\n          let aliasedPath = linkPath;\n\n          if (linkTarget && linkTarget !== DOT_SLASH) {\n            aliasedPath = path.replace(linkTarget, linkPath);\n          } else if (path !== DOT_SLASH) {\n            aliasedPath = sysPath.join(linkPath, path);\n          }\n\n          return transform(aliasedPath);\n        }, false, curDepth);\n      } catch (error) {\n        if (_this3.fsw._handleError(error)) {\n          return _this3.fsw._emitReady();\n        }\n      }\n    })();\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\n    const base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      if (_this4.fsw.closed) {\n        return;\n      }\n\n      const opts = _this4.fsw.options;\n      const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n      const wh = _this4.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n      try {\n        const stats = yield statMethods[wh.statMethod](wh.watchPath);\n        if (_this4.fsw.closed) return;\n\n        if (_this4.fsw._isIgnored(wh.watchPath, stats)) {\n          throw null;\n        }\n\n        if (stats.isDirectory()) {\n          // emit addDir unless this is a glob parent\n          if (!wh.globFilter) _this4.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n          if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n          _this4.fsw._readdirp(wh.watchPath, {\n            fileFilter: entry => wh.filterPath(entry),\n            directoryFilter: entry => wh.filterDir(entry),\n            ...Depth(opts.depth - (priorDepth || 0))\n          }).on(STR_DATA, entry => {\n            // need to check filterPath on dirs b/c filterDir is less restrictive\n            if (_this4.fsw.closed) {\n              return;\n            }\n\n            if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n            const joinedPath = sysPath.join(wh.watchPath, entry.path);\n            const {\n              fullPath\n            } = entry;\n\n            if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n              // preserve the current depth here since it can't be derived from\n              // real paths past the symlink\n              const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n              _this4._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n            } else {\n              _this4.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n            }\n          }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n            _this4.fsw._emitReady();\n          });\n        } else {\n          _this4.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n          _this4.fsw._emitReady();\n        }\n      } catch (error) {\n        if (!error || _this4.fsw._handleError(error)) {\n          // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n          _this4.fsw._emitReady();\n\n          _this4.fsw._emitReady();\n        }\n      }\n\n      if (opts.persistent && forceAdd !== true) {\n        if (typeof transform === FUNCTION_TYPE) {\n          // realpath has already been resolved\n          _this4.initWatch(undefined, path, wh, processPath);\n        } else {\n          let realPath;\n\n          try {\n            realPath = yield realpath(wh.watchPath);\n          } catch (e) {}\n\n          _this4.initWatch(realPath, path, wh, processPath);\n        }\n      }\n    })();\n  }\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":null,"metadata":{},"sourceType":"script"}