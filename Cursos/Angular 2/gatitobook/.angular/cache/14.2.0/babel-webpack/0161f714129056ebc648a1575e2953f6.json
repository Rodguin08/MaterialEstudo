{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FilterHostTree = exports.HostCreateTree = exports.HostTree = exports.HostDirEntry = void 0;\n\nconst core_1 = require(\"@angular-devkit/core\");\n\nconst jsonc_parser_1 = require(\"jsonc-parser\");\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst util_1 = require(\"util\");\n\nconst exception_1 = require(\"../exception/exception\");\n\nconst delegate_1 = require(\"./delegate\");\n\nconst entry_1 = require(\"./entry\");\n\nconst interface_1 = require(\"./interface\");\n\nconst recorder_1 = require(\"./recorder\");\n\nconst scoped_1 = require(\"./scoped\");\n\nlet _uniqueId = 0;\n\nclass HostDirEntry {\n  constructor(parent, path, _host, _tree) {\n    this.parent = parent;\n    this.path = path;\n    this._host = _host;\n    this._tree = _tree;\n  }\n\n  get subdirs() {\n    return this._host.list(this.path).filter(fragment => this._host.isDirectory((0, core_1.join)(this.path, fragment)));\n  }\n\n  get subfiles() {\n    return this._host.list(this.path).filter(fragment => this._host.isFile((0, core_1.join)(this.path, fragment)));\n  }\n\n  dir(name) {\n    return this._tree.getDir((0, core_1.join)(this.path, name));\n  }\n\n  file(name) {\n    return this._tree.get((0, core_1.join)(this.path, name));\n  }\n\n  visit(visitor) {\n    try {\n      this.getSubfilesRecursively().forEach(file => visitor(file.path, file));\n    } catch (e) {\n      if (e !== interface_1.FileVisitorCancelToken) {\n        throw e;\n      }\n    }\n  }\n\n  getSubfilesRecursively() {\n    function _recurse(entry) {\n      return entry.subdirs.reduce((files, subdir) => [...files, ..._recurse(entry.dir(subdir))], entry.subfiles.map(subfile => entry.file(subfile)));\n    }\n\n    return _recurse(this);\n  }\n\n}\n\nexports.HostDirEntry = HostDirEntry;\n\nclass HostTree {\n  constructor(_backend = new core_1.virtualFs.Empty()) {\n    this._backend = _backend;\n    this._id = --_uniqueId;\n    this._ancestry = new Set();\n    this._dirCache = new Map();\n    this._record = new core_1.virtualFs.CordHost(new core_1.virtualFs.SafeReadonlyHost(_backend));\n    this._recordSync = new core_1.virtualFs.SyncDelegateHost(this._record);\n  }\n\n  [interface_1.TreeSymbol]() {\n    return this;\n  }\n\n  static isHostTree(tree) {\n    if (tree instanceof HostTree) {\n      return true;\n    }\n\n    if (typeof tree === 'object' && typeof tree._ancestry === 'object') {\n      return true;\n    }\n\n    return false;\n  }\n\n  _normalizePath(path) {\n    return (0, core_1.normalize)('/' + path);\n  }\n\n  _willCreate(path) {\n    return this._record.willCreate(path);\n  }\n\n  _willOverwrite(path) {\n    return this._record.willOverwrite(path);\n  }\n\n  _willDelete(path) {\n    return this._record.willDelete(path);\n  }\n\n  _willRename(path) {\n    return this._record.willRename(path);\n  }\n\n  branch() {\n    const branchedTree = new HostTree(this._backend);\n    branchedTree._record = this._record.clone();\n    branchedTree._recordSync = new core_1.virtualFs.SyncDelegateHost(branchedTree._record);\n    branchedTree._ancestry = new Set(this._ancestry).add(this._id);\n    return branchedTree;\n  }\n\n  isAncestorOf(tree) {\n    if (tree instanceof HostTree) {\n      return tree._ancestry.has(this._id);\n    }\n\n    if (tree instanceof delegate_1.DelegateTree) {\n      return this.isAncestorOf(tree._other);\n    }\n\n    if (tree instanceof scoped_1.ScopedTree) {\n      return this.isAncestorOf(tree._base);\n    }\n\n    return false;\n  }\n\n  merge(other, strategy = interface_1.MergeStrategy.Default) {\n    if (other === this) {\n      // Merging with yourself? Tsk tsk. Nothing to do at least.\n      return;\n    }\n\n    if (this.isAncestorOf(other)) {\n      // Workaround for merging a branch back into one of its ancestors\n      // More complete branch point tracking is required to avoid\n      strategy |= interface_1.MergeStrategy.Overwrite;\n    }\n\n    const creationConflictAllowed = (strategy & interface_1.MergeStrategy.AllowCreationConflict) == interface_1.MergeStrategy.AllowCreationConflict;\n    const overwriteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowOverwriteConflict) == interface_1.MergeStrategy.AllowOverwriteConflict;\n    const deleteConflictAllowed = (strategy & interface_1.MergeStrategy.AllowDeleteConflict) == interface_1.MergeStrategy.AllowDeleteConflict;\n    other.actions.forEach(action => {\n      switch (action.kind) {\n        case 'c':\n          {\n            const {\n              path,\n              content\n            } = action;\n\n            if (this._willCreate(path) || this._willOverwrite(path) || this.exists(path)) {\n              const existingContent = this.read(path);\n\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n\n              if (!creationConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n\n              this._record.overwrite(path, content).subscribe();\n            } else {\n              this._record.create(path, content).subscribe();\n            }\n\n            return;\n          }\n\n        case 'o':\n          {\n            const {\n              path,\n              content\n            } = action;\n\n            if (this._willDelete(path) && !overwriteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            } // Ignore if content is the same (considered the same change).\n\n\n            if (this._willOverwrite(path)) {\n              const existingContent = this.read(path);\n\n              if (existingContent && content.equals(existingContent)) {\n                // Identical outcome; no action required\n                return;\n              }\n\n              if (!overwriteConflictAllowed) {\n                throw new exception_1.MergeConflictException(path);\n              }\n            } // We use write here as merge validation has already been done, and we want to let\n            // the CordHost do its job.\n\n\n            this._record.write(path, content).subscribe();\n\n            return;\n          }\n\n        case 'r':\n          {\n            const {\n              path,\n              to\n            } = action;\n\n            if (this._willDelete(path)) {\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            if (this._willRename(path)) {\n              if (this._record.willRenameTo(path, to)) {\n                // Identical outcome; no action required\n                return;\n              } // No override possible for renaming.\n\n\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            this.rename(path, to);\n            return;\n          }\n\n        case 'd':\n          {\n            const {\n              path\n            } = action;\n\n            if (this._willDelete(path)) {\n              // TODO: This should technically check the content (e.g., hash on delete)\n              // Identical outcome; no action required\n              return;\n            }\n\n            if (!this.exists(path) && !deleteConflictAllowed) {\n              throw new exception_1.MergeConflictException(path);\n            }\n\n            this._recordSync.delete(path);\n\n            return;\n          }\n      }\n    });\n  }\n\n  get root() {\n    return this.getDir('/');\n  } // Readonly.\n\n\n  read(path) {\n    const entry = this.get(path);\n    return entry ? entry.content : null;\n  }\n\n  readText(path) {\n    const data = this.read(path);\n\n    if (data === null) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n\n    const decoder = new util_1.TextDecoder('utf-8', {\n      fatal: true\n    });\n\n    try {\n      // With the `fatal` option enabled, invalid data will throw a TypeError\n      return decoder.decode(data);\n    } catch (e) {\n      if (e instanceof TypeError) {\n        throw new Error(`Failed to decode \"${path}\" as UTF-8 text.`);\n      }\n\n      throw e;\n    }\n  }\n\n  readJson(path) {\n    const content = this.readText(path);\n    const errors = [];\n    const result = (0, jsonc_parser_1.parse)(content, errors, {\n      allowTrailingComma: true\n    }); // If there is a parse error throw with the error information\n\n    if (errors[0]) {\n      const {\n        error,\n        offset\n      } = errors[0];\n      throw new Error(`Failed to parse \"${path}\" as JSON. ${(0, jsonc_parser_1.printParseErrorCode)(error)} at offset: ${offset}.`);\n    }\n\n    return result;\n  }\n\n  exists(path) {\n    return this._recordSync.isFile(this._normalizePath(path));\n  }\n\n  get(path) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.isDirectory(p)) {\n      throw new core_1.PathIsDirectoryException(p);\n    }\n\n    if (!this._recordSync.exists(p)) {\n      return null;\n    }\n\n    return new entry_1.LazyFileEntry(p, () => Buffer.from(this._recordSync.read(p)));\n  }\n\n  getDir(path) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.isFile(p)) {\n      throw new core_1.PathIsFileException(p);\n    }\n\n    let maybeCache = this._dirCache.get(p);\n\n    if (!maybeCache) {\n      let parent = (0, core_1.dirname)(p);\n\n      if (p === parent) {\n        parent = null;\n      }\n\n      maybeCache = new HostDirEntry(parent && this.getDir(parent), p, this._recordSync, this);\n\n      this._dirCache.set(p, maybeCache);\n    }\n\n    return maybeCache;\n  }\n\n  visit(visitor) {\n    this.root.visit((path, entry) => {\n      visitor(path, entry);\n    });\n  } // Change content of host files.\n\n\n  overwrite(path, content) {\n    const p = this._normalizePath(path);\n\n    if (!this._recordSync.exists(p)) {\n      throw new exception_1.FileDoesNotExistException(p);\n    }\n\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n\n    this._record.overwrite(p, c).subscribe();\n  }\n\n  beginUpdate(path) {\n    const entry = this.get(path);\n\n    if (!entry) {\n      throw new exception_1.FileDoesNotExistException(path);\n    }\n\n    return recorder_1.UpdateRecorderBase.createFromFileEntry(entry);\n  }\n\n  commitUpdate(record) {\n    if (record instanceof recorder_1.UpdateRecorderBase) {\n      const path = record.path;\n      const entry = this.get(path);\n\n      if (!entry) {\n        throw new exception_1.ContentHasMutatedException(path);\n      } else {\n        const newContent = record.apply(entry.content);\n\n        if (!newContent.equals(entry.content)) {\n          this.overwrite(path, newContent);\n        }\n      }\n    } else {\n      throw new exception_1.InvalidUpdateRecordException();\n    }\n  } // Structural methods.\n\n\n  create(path, content) {\n    const p = this._normalizePath(path);\n\n    if (this._recordSync.exists(p)) {\n      throw new exception_1.FileAlreadyExistException(p);\n    }\n\n    const c = typeof content == 'string' ? Buffer.from(content) : content;\n\n    this._record.create(p, c).subscribe();\n  }\n\n  delete(path) {\n    this._recordSync.delete(this._normalizePath(path));\n  }\n\n  rename(from, to) {\n    this._recordSync.rename(this._normalizePath(from), this._normalizePath(to));\n  }\n\n  apply(action, strategy) {\n    throw new exception_1.SchematicsException('Apply not implemented on host trees.');\n  }\n\n  *generateActions() {\n    for (const record of this._record.records()) {\n      switch (record.kind) {\n        case 'create':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'c',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n\n        case 'overwrite':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'o',\n            path: record.path,\n            content: Buffer.from(record.content)\n          };\n          break;\n\n        case 'rename':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'r',\n            path: record.from,\n            to: record.to\n          };\n          break;\n\n        case 'delete':\n          yield {\n            id: this._id,\n            parent: 0,\n            kind: 'd',\n            path: record.path\n          };\n          break;\n      }\n    }\n  }\n\n  get actions() {\n    // Create a list of all records until we hit our original backend. This is to support branches\n    // that diverge from each others.\n    return Array.from(this.generateActions());\n  }\n\n}\n\nexports.HostTree = HostTree;\n\nclass HostCreateTree extends HostTree {\n  constructor(host) {\n    super();\n    const tempHost = new HostTree(host);\n    tempHost.visit(path => {\n      const content = tempHost.read(path);\n\n      if (content) {\n        this.create(path, content);\n      }\n    });\n  }\n\n}\n\nexports.HostCreateTree = HostCreateTree;\n\nclass FilterHostTree extends HostTree {\n  constructor(tree, filter = () => true) {\n    const newBackend = new core_1.virtualFs.SimpleMemoryHost(); // cast to allow access\n\n    const originalBackend = tree._backend;\n\n    const recurse = base => {\n      return originalBackend.list(base).pipe((0, operators_1.mergeMap)(x => x), (0, operators_1.map)(path => (0, core_1.join)(base, path)), (0, operators_1.concatMap)(path => {\n        let isDirectory = false;\n        originalBackend.isDirectory(path).subscribe(val => isDirectory = val);\n\n        if (isDirectory) {\n          return recurse(path);\n        }\n\n        let isFile = false;\n        originalBackend.isFile(path).subscribe(val => isFile = val);\n\n        if (!isFile || !filter(path)) {\n          return rxjs_1.EMPTY;\n        }\n\n        let content = null;\n        originalBackend.read(path).subscribe(val => content = val);\n\n        if (!content) {\n          return rxjs_1.EMPTY;\n        }\n\n        return newBackend.write(path, content);\n      }));\n    };\n\n    recurse((0, core_1.normalize)('/')).subscribe();\n    super(newBackend);\n\n    for (const action of tree.actions) {\n      if (!filter(action.path)) {\n        continue;\n      }\n\n      switch (action.kind) {\n        case 'c':\n          this.create(action.path, action.content);\n          break;\n\n        case 'd':\n          this.delete(action.path);\n          break;\n\n        case 'o':\n          this.overwrite(action.path, action.content);\n          break;\n\n        case 'r':\n          this.rename(action.path, action.to);\n          break;\n      }\n    }\n  }\n\n}\n\nexports.FilterHostTree = FilterHostTree;","map":null,"metadata":{},"sourceType":"script"}