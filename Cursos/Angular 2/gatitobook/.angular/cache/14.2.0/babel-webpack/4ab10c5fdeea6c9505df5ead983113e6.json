{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar _asyncToGenerator = /*#__PURE__*/require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateCommandModule = void 0;\n\nconst schematics_1 = /*#__PURE__*/require(\"@angular-devkit/schematics\");\n\nconst tools_1 = /*#__PURE__*/require(\"@angular-devkit/schematics/tools\");\n\nconst child_process_1 = /*#__PURE__*/require(\"child_process\");\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst npm_package_arg_1 = __importDefault( /*#__PURE__*/require(\"npm-package-arg\"));\n\nconst npm_pick_manifest_1 = __importDefault( /*#__PURE__*/require(\"npm-pick-manifest\"));\n\nconst path = __importStar( /*#__PURE__*/require(\"path\"));\n\nconst path_1 = /*#__PURE__*/require(\"path\");\n\nconst semver = __importStar( /*#__PURE__*/require(\"semver\"));\n\nconst workspace_schema_1 = /*#__PURE__*/require(\"../../../lib/config/workspace-schema\");\n\nconst command_module_1 = /*#__PURE__*/require(\"../../command-builder/command-module\");\n\nconst schematic_engine_host_1 = /*#__PURE__*/require(\"../../command-builder/utilities/schematic-engine-host\");\n\nconst schematic_workflow_1 = /*#__PURE__*/require(\"../../command-builder/utilities/schematic-workflow\");\n\nconst color_1 = /*#__PURE__*/require(\"../../utilities/color\");\n\nconst environment_options_1 = /*#__PURE__*/require(\"../../utilities/environment-options\");\n\nconst error_1 = /*#__PURE__*/require(\"../../utilities/error\");\n\nconst log_file_1 = /*#__PURE__*/require(\"../../utilities/log-file\");\n\nconst package_metadata_1 = /*#__PURE__*/require(\"../../utilities/package-metadata\");\n\nconst package_tree_1 = /*#__PURE__*/require(\"../../utilities/package-tree\");\n\nconst version_1 = /*#__PURE__*/require(\"../../utilities/version\");\n\nconst ANGULAR_PACKAGES_REGEXP = /^@(?:angular|nguniversal)\\//;\nconst UPDATE_SCHEMATIC_COLLECTION = /*#__PURE__*/path.join(__dirname, 'schematic/collection.json');\n\nclass UpdateCommandModule extends command_module_1.CommandModule {\n  constructor() {\n    super(...arguments);\n    this.scope = command_module_1.CommandScope.In;\n    this.shouldReportAnalytics = false;\n    this.command = 'update [packages..]';\n    this.describe = 'Updates your workspace and its dependencies. See https://update.angular.io/.';\n    this.longDescriptionPath = (0, path_1.join)(__dirname, 'long-description.md');\n  }\n\n  builder(localYargs) {\n    return localYargs.positional('packages', {\n      description: 'The names of package(s) to update.',\n      type: 'string',\n      array: true\n    }).option('force', {\n      description: 'Ignore peer dependency version mismatches.',\n      type: 'boolean',\n      default: false\n    }).option('next', {\n      description: 'Use the prerelease version, including beta and RCs.',\n      type: 'boolean',\n      default: false\n    }).option('migrate-only', {\n      description: 'Only perform a migration, do not update the installed version.',\n      type: 'boolean'\n    }).option('name', {\n      description: 'The name of the migration to run. ' + `Only available with a single package being updated, and only with 'migrate-only' option.`,\n      type: 'string',\n      implies: ['migrate-only'],\n      conflicts: ['to', 'from']\n    }).option('from', {\n      description: 'Version from which to migrate from. ' + `Only available with a single package being updated, and only with 'migrate-only'.`,\n      type: 'string',\n      implies: ['to', 'migrate-only'],\n      conflicts: ['name']\n    }).option('to', {\n      describe: 'Version up to which to apply migrations. Only available with a single package being updated, ' + `and only with 'migrate-only' option. Requires 'from' to be specified. Default to the installed version detected.`,\n      type: 'string',\n      implies: ['from', 'migrate-only'],\n      conflicts: ['name']\n    }).option('allow-dirty', {\n      describe: 'Whether to allow updating when the repository contains modified or untracked files.',\n      type: 'boolean',\n      default: false\n    }).option('verbose', {\n      describe: 'Display additional details about internal operations during execution.',\n      type: 'boolean',\n      default: false\n    }).option('create-commits', {\n      describe: 'Create source control commits for updates and migrations.',\n      type: 'boolean',\n      alias: ['C'],\n      default: false\n    }).check(({\n      packages,\n      'allow-dirty': allowDirty,\n      'migrate-only': migrateOnly\n    }) => {\n      const {\n        logger\n      } = this.context; // This allows the user to easily reset any changes from the update.\n\n      if ((packages === null || packages === void 0 ? void 0 : packages.length) && !this.checkCleanGit()) {\n        if (allowDirty) {\n          logger.warn('Repository is not clean. Update changes will be mixed with pre-existing changes.');\n        } else {\n          throw new command_module_1.CommandModuleError('Repository is not clean. Please commit or stash any changes before updating.');\n        }\n      }\n\n      if (migrateOnly) {\n        if ((packages === null || packages === void 0 ? void 0 : packages.length) !== 1) {\n          throw new command_module_1.CommandModuleError(`A single package must be specified when using the 'migrate-only' option.`);\n        }\n      }\n\n      return true;\n    }).strict();\n  }\n\n  run(options) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      var _a, _b;\n\n      const {\n        logger,\n        packageManager\n      } = _this.context;\n      packageManager.ensureCompatibility(); // Check if the current installed CLI version is older than the latest compatible version.\n\n      if (!environment_options_1.disableVersionCheck) {\n        const cliVersionToInstall = yield _this.checkCLIVersion(options.packages, options.verbose, options.next);\n\n        if (cliVersionToInstall) {\n          logger.warn('The installed Angular CLI version is outdated.\\n' + `Installing a temporary Angular CLI versioned ${cliVersionToInstall} to perform the update.`);\n          return _this.runTempBinary(`@angular/cli@${cliVersionToInstall}`, process.argv.slice(2));\n        }\n      }\n\n      const packages = [];\n\n      for (const request of (_a = options.packages) !== null && _a !== void 0 ? _a : []) {\n        try {\n          const packageIdentifier = (0, npm_package_arg_1.default)(request); // only registry identifiers are supported\n\n          if (!packageIdentifier.registry) {\n            logger.error(`Package '${request}' is not a registry package identifer.`);\n            return 1;\n          }\n\n          if (packages.some(v => v.name === packageIdentifier.name)) {\n            logger.error(`Duplicate package '${packageIdentifier.name}' specified.`);\n            return 1;\n          }\n\n          if (options.migrateOnly && packageIdentifier.rawSpec) {\n            logger.warn('Package specifier has no effect when using \"migrate-only\" option.');\n          } // If next option is used and no specifier supplied, use next tag\n\n\n          if (options.next && !packageIdentifier.rawSpec) {\n            packageIdentifier.fetchSpec = 'next';\n          }\n\n          packages.push(packageIdentifier);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(e.message);\n          return 1;\n        }\n      }\n\n      logger.info(`Using package manager: ${color_1.colors.grey(packageManager.name)}`);\n      logger.info('Collecting installed dependencies...');\n      const rootDependencies = yield (0, package_tree_1.getProjectDependencies)(_this.context.root);\n      logger.info(`Found ${rootDependencies.size} dependencies.`);\n      const workflow = new tools_1.NodeWorkflow(_this.context.root, {\n        packageManager: packageManager.name,\n        packageManagerForce: _this.packageManagerForce(options.verbose),\n        // __dirname -> favor @schematics/update from this package\n        // Otherwise, use packages from the active workspace (migrations)\n        resolvePaths: [__dirname, _this.context.root],\n        schemaValidation: true,\n        engineHostCreator: options => new schematic_engine_host_1.SchematicEngineHost(options.resolvePaths)\n      });\n\n      if (packages.length === 0) {\n        // Show status\n        const {\n          success\n        } = yield _this.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n          force: options.force,\n          next: options.next,\n          verbose: options.verbose,\n          packageManager: packageManager.name,\n          packages: []\n        });\n        return success ? 0 : 1;\n      }\n\n      return options.migrateOnly ? _this.migrateOnly(workflow, ((_b = options.packages) !== null && _b !== void 0 ? _b : [])[0], rootDependencies, options) : _this.updatePackagesAndMigrate(workflow, rootDependencies, options, packages);\n    })();\n  }\n\n  executeSchematic(workflow, collection, schematic, options = {}) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this2.context;\n      const workflowSubscription = (0, schematic_workflow_1.subscribeToWorkflow)(workflow, logger); // TODO: Allow passing a schematic instance directly\n\n      try {\n        yield workflow.execute({\n          collection,\n          schematic,\n          options,\n          logger\n        }).toPromise();\n        return {\n          success: !workflowSubscription.error,\n          files: workflowSubscription.files\n        };\n      } catch (e) {\n        if (e instanceof schematics_1.UnsuccessfulWorkflowExecution) {\n          logger.error(`${color_1.colors.symbols.cross} Migration failed. See above for further details.\\n`);\n        } else {\n          (0, error_1.assertIsError)(e);\n          const logPath = (0, log_file_1.writeErrorToLogFile)(e);\n          logger.fatal(`${color_1.colors.symbols.cross} Migration failed: ${e.message}\\n` + `  See \"${logPath}\" for further details.\\n`);\n        }\n\n        return {\n          success: false,\n          files: workflowSubscription.files\n        };\n      } finally {\n        workflowSubscription.unsubscribe();\n      }\n    })();\n  }\n  /**\n   * @return Whether or not the migration was performed successfully.\n   */\n\n\n  executeMigration(workflow, packageName, collectionPath, migrationName, commit) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this3.context;\n      const collection = workflow.engine.createCollection(collectionPath);\n      const name = collection.listSchematicNames().find(name => name === migrationName);\n\n      if (!name) {\n        logger.error(`Cannot find migration '${migrationName}' in '${packageName}'.`);\n        return 1;\n      }\n\n      logger.info(color_1.colors.cyan(`** Executing '${migrationName}' of package '${packageName}' **\\n`));\n      const schematic = workflow.engine.createSchematic(name, collection);\n      return _this3.executePackageMigrations(workflow, [schematic.description], packageName, commit);\n    })();\n  }\n  /**\n   * @return Whether or not the migrations were performed successfully.\n   */\n\n\n  executeMigrations(workflow, packageName, collectionPath, from, to, commit) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const collection = workflow.engine.createCollection(collectionPath);\n      const migrationRange = new semver.Range('>' + (semver.prerelease(from) ? from.split('-')[0] + '-0' : from) + ' <=' + to.split('-')[0]);\n      const migrations = [];\n\n      for (const name of collection.listSchematicNames()) {\n        const schematic = workflow.engine.createSchematic(name, collection);\n        const description = schematic.description;\n        description.version = coerceVersionNumber(description.version);\n\n        if (!description.version) {\n          continue;\n        }\n\n        if (semver.satisfies(description.version, migrationRange, {\n          includePrerelease: true\n        })) {\n          migrations.push(description);\n        }\n      }\n\n      if (migrations.length === 0) {\n        return 0;\n      }\n\n      migrations.sort((a, b) => semver.compare(a.version, b.version) || a.name.localeCompare(b.name));\n\n      _this4.context.logger.info(color_1.colors.cyan(`** Executing migrations of package '${packageName}' **\\n`));\n\n      return _this4.executePackageMigrations(workflow, migrations, packageName, commit);\n    })();\n  }\n\n  executePackageMigrations(workflow, migrations, packageName, commit = false) {\n    var _this5 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this5.context;\n\n      for (const migration of migrations) {\n        const [title, ...description] = migration.description.split('. ');\n        logger.info(color_1.colors.cyan(color_1.colors.symbols.pointer) + ' ' + color_1.colors.bold(title.endsWith('.') ? title : title + '.'));\n\n        if (description.length) {\n          logger.info('  ' + description.join('.\\n  '));\n        }\n\n        const result = yield _this5.executeSchematic(workflow, migration.collection.name, migration.name);\n\n        if (!result.success) {\n          return 1;\n        }\n\n        logger.info('  Migration completed.'); // Commit migration\n\n        if (commit) {\n          const commitPrefix = `${packageName} migration - ${migration.name}`;\n          const commitMessage = migration.description ? `${commitPrefix}\\n\\n${migration.description}` : commitPrefix;\n\n          const committed = _this5.commit(commitMessage);\n\n          if (!committed) {\n            // Failed to commit, something went wrong. Abort the update.\n            return 1;\n          }\n        }\n\n        logger.info(''); // Extra trailing newline.\n      }\n\n      return 0;\n    })();\n  }\n\n  migrateOnly(workflow, packageName, rootDependencies, options) {\n    var _this6 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        logger\n      } = _this6.context;\n      const packageDependency = rootDependencies.get(packageName);\n      let packagePath = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.path;\n      let packageNode = packageDependency === null || packageDependency === void 0 ? void 0 : packageDependency.package;\n\n      if (packageDependency && !packageNode) {\n        logger.error('Package found in package.json but is not installed.');\n        return 1;\n      } else if (!packageDependency) {\n        // Allow running migrations on transitively installed dependencies\n        // There can technically be nested multiple versions\n        // TODO: If multiple, this should find all versions and ask which one to use\n        const packageJson = (0, package_tree_1.findPackageJson)(_this6.context.root, packageName);\n\n        if (packageJson) {\n          packagePath = path.dirname(packageJson);\n          packageNode = yield (0, package_tree_1.readPackageJson)(packageJson);\n        }\n      }\n\n      if (!packageNode || !packagePath) {\n        logger.error('Package is not installed.');\n        return 1;\n      }\n\n      const updateMetadata = packageNode['ng-update'];\n      let migrations = updateMetadata === null || updateMetadata === void 0 ? void 0 : updateMetadata.migrations;\n\n      if (migrations === undefined) {\n        logger.error('Package does not provide migrations.');\n        return 1;\n      } else if (typeof migrations !== 'string') {\n        logger.error('Package contains a malformed migrations field.');\n        return 1;\n      } else if (path.posix.isAbsolute(migrations) || path.win32.isAbsolute(migrations)) {\n        logger.error('Package contains an invalid migrations field. Absolute paths are not permitted.');\n        return 1;\n      } // Normalize slashes\n\n\n      migrations = migrations.replace(/\\\\/g, '/');\n\n      if (migrations.startsWith('../')) {\n        logger.error('Package contains an invalid migrations field. Paths outside the package root are not permitted.');\n        return 1;\n      } // Check if it is a package-local location\n\n\n      const localMigrations = path.join(packagePath, migrations);\n\n      if ((0, fs_1.existsSync)(localMigrations)) {\n        migrations = localMigrations;\n      } else {\n        // Try to resolve from package location.\n        // This avoids issues with package hoisting.\n        try {\n          migrations = require.resolve(migrations, {\n            paths: [packagePath]\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n\n          if (e.code === 'MODULE_NOT_FOUND') {\n            logger.error('Migrations for package were not found.');\n          } else {\n            logger.error(`Unable to resolve migrations for package.  [${e.message}]`);\n          }\n\n          return 1;\n        }\n      }\n\n      if (options.name) {\n        return _this6.executeMigration(workflow, packageName, migrations, options.name, options.createCommits);\n      }\n\n      const from = coerceVersionNumber(options.from);\n\n      if (!from) {\n        logger.error(`\"from\" value [${options.from}] is not a valid version.`);\n        return 1;\n      }\n\n      return _this6.executeMigrations(workflow, packageName, migrations, from, options.to || packageNode.version, options.createCommits);\n    })();\n  } // eslint-disable-next-line max-lines-per-function\n\n\n  updatePackagesAndMigrate(workflow, rootDependencies, options, packages) {\n    var _this7 = this;\n\n    return _asyncToGenerator(function* () {\n      var _a;\n\n      const {\n        logger\n      } = _this7.context;\n\n      const logVerbose = message => {\n        if (options.verbose) {\n          logger.info(message);\n        }\n      };\n\n      const requests = []; // Validate packages actually are part of the workspace\n\n      for (const pkg of packages) {\n        const node = rootDependencies.get(pkg.name);\n\n        if (!(node === null || node === void 0 ? void 0 : node.package)) {\n          logger.error(`Package '${pkg.name}' is not a dependency.`);\n          return 1;\n        } // If a specific version is requested and matches the installed version, skip.\n\n\n        if (pkg.type === 'version' && node.package.version === pkg.fetchSpec) {\n          logger.info(`Package '${pkg.name}' is already at '${pkg.fetchSpec}'.`);\n          continue;\n        }\n\n        requests.push({\n          identifier: pkg,\n          node\n        });\n      }\n\n      if (requests.length === 0) {\n        return 0;\n      }\n\n      logger.info('Fetching dependency metadata from registry...');\n      const packagesToUpdate = [];\n\n      for (const {\n        identifier: requestIdentifier,\n        node\n      } of requests) {\n        const packageName = requestIdentifier.name;\n        let metadata;\n\n        try {\n          // Metadata requests are internally cached; multiple requests for same name\n          // does not result in additional network traffic\n          metadata = yield (0, package_metadata_1.fetchPackageMetadata)(packageName, logger, {\n            verbose: options.verbose\n          });\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n          logger.error(`Error fetching metadata for '${packageName}': ` + e.message);\n          return 1;\n        } // Try to find a package version based on the user requested package specifier\n        // registry specifier types are either version, range, or tag\n\n\n        let manifest;\n\n        if (requestIdentifier.type === 'version' || requestIdentifier.type === 'range' || requestIdentifier.type === 'tag') {\n          try {\n            manifest = (0, npm_pick_manifest_1.default)(metadata, requestIdentifier.fetchSpec);\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n\n            if (e.code === 'ETARGET') {\n              // If not found and next was used and user did not provide a specifier, try latest.\n              // Package may not have a next tag.\n              if (requestIdentifier.type === 'tag' && requestIdentifier.fetchSpec === 'next' && !requestIdentifier.rawSpec) {\n                try {\n                  manifest = (0, npm_pick_manifest_1.default)(metadata, 'latest');\n                } catch (e) {\n                  (0, error_1.assertIsError)(e);\n\n                  if (e.code !== 'ETARGET' && e.code !== 'ENOVERSIONS') {\n                    throw e;\n                  }\n                }\n              }\n            } else if (e.code !== 'ENOVERSIONS') {\n              throw e;\n            }\n          }\n        }\n\n        if (!manifest) {\n          logger.error(`Package specified by '${requestIdentifier.raw}' does not exist within the registry.`);\n          return 1;\n        }\n\n        if (manifest.version === ((_a = node.package) === null || _a === void 0 ? void 0 : _a.version)) {\n          logger.info(`Package '${packageName}' is already up to date.`);\n          continue;\n        }\n\n        if (node.package && ANGULAR_PACKAGES_REGEXP.test(node.package.name)) {\n          const {\n            name,\n            version\n          } = node.package;\n          const toBeInstalledMajorVersion = +manifest.version.split('.')[0];\n          const currentMajorVersion = +version.split('.')[0];\n\n          if (toBeInstalledMajorVersion - currentMajorVersion > 1) {\n            // Only allow updating a single version at a time.\n            if (currentMajorVersion < 6) {\n              // Before version 6, the major versions were not always sequential.\n              // Example @angular/core skipped version 3, @angular/cli skipped versions 2-5.\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `For more information about the update process, see https://update.angular.io/.`);\n            } else {\n              const nextMajorVersionFromCurrent = currentMajorVersion + 1;\n              logger.error(`Updating multiple major versions of '${name}' at once is not supported. Please migrate each major version individually.\\n` + `Run 'ng update ${name}@${nextMajorVersionFromCurrent}' in your workspace directory ` + `to update to latest '${nextMajorVersionFromCurrent}.x' version of '${name}'.\\n\\n` + `For more information about the update process, see https://update.angular.io/?v=${currentMajorVersion}.0-${nextMajorVersionFromCurrent}.0`);\n            }\n\n            return 1;\n          }\n        }\n\n        packagesToUpdate.push(requestIdentifier.toString());\n      }\n\n      if (packagesToUpdate.length === 0) {\n        return 0;\n      }\n\n      const {\n        success\n      } = yield _this7.executeSchematic(workflow, UPDATE_SCHEMATIC_COLLECTION, 'update', {\n        verbose: options.verbose,\n        force: options.force,\n        next: options.next,\n        packageManager: _this7.context.packageManager.name,\n        packages: packagesToUpdate\n      });\n\n      if (success) {\n        try {\n          yield fs_1.promises.rm(path.join(_this7.context.root, 'node_modules'), {\n            force: true,\n            recursive: true,\n            maxRetries: 3\n          });\n        } catch {}\n\n        const installationSuccess = yield _this7.context.packageManager.installAll(_this7.packageManagerForce(options.verbose) ? ['--force'] : [], _this7.context.root);\n\n        if (!installationSuccess) {\n          return 1;\n        }\n      }\n\n      if (success && options.createCommits) {\n        if (!_this7.commit(`Angular CLI update for packages - ${packagesToUpdate.join(', ')}`)) {\n          return 1;\n        }\n      } // This is a temporary workaround to allow data to be passed back from the update schematic\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      const migrations = global.externalMigrations;\n\n      if (success && migrations) {\n        for (const migration of migrations) {\n          // Resolve the package from the workspace root, as otherwise it will be resolved from the temp\n          // installed CLI version.\n          let packagePath;\n          logVerbose(`Resolving migration package '${migration.package}' from '${_this7.context.root}'...`);\n\n          try {\n            try {\n              packagePath = path.dirname( // This may fail if the `package.json` is not exported as an entry point\n              require.resolve(path.join(migration.package, 'package.json'), {\n                paths: [_this7.context.root]\n              }));\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n\n              if (e.code === 'MODULE_NOT_FOUND') {\n                // Fallback to trying to resolve the package's main entry point\n                packagePath = require.resolve(migration.package, {\n                  paths: [_this7.context.root]\n                });\n              } else {\n                throw e;\n              }\n            }\n          } catch (e) {\n            (0, error_1.assertIsError)(e);\n\n            if (e.code === 'MODULE_NOT_FOUND') {\n              logVerbose(e.toString());\n              logger.error(`Migrations for package (${migration.package}) were not found.` + ' The package could not be found in the workspace.');\n            } else {\n              logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n            }\n\n            return 1;\n          }\n\n          let migrations; // Check if it is a package-local location\n\n          const localMigrations = path.join(packagePath, migration.collection);\n\n          if ((0, fs_1.existsSync)(localMigrations)) {\n            migrations = localMigrations;\n          } else {\n            // Try to resolve from package location.\n            // This avoids issues with package hoisting.\n            try {\n              migrations = require.resolve(migration.collection, {\n                paths: [packagePath]\n              });\n            } catch (e) {\n              (0, error_1.assertIsError)(e);\n\n              if (e.code === 'MODULE_NOT_FOUND') {\n                logger.error(`Migrations for package (${migration.package}) were not found.`);\n              } else {\n                logger.error(`Unable to resolve migrations for package (${migration.package}).  [${e.message}]`);\n              }\n\n              return 1;\n            }\n          }\n\n          const result = yield _this7.executeMigrations(workflow, migration.package, migrations, migration.from, migration.to, options.createCommits); // A non-zero value is a failure for the package's migrations\n\n          if (result !== 0) {\n            return result;\n          }\n        }\n      }\n\n      return success ? 0 : 1;\n    })();\n  }\n  /**\n   * @return Whether or not the commit was successful.\n   */\n\n\n  commit(message) {\n    const {\n      logger\n    } = this.context; // Check if a commit is needed.\n\n    let commitNeeded;\n\n    try {\n      commitNeeded = hasChangesToCommit();\n    } catch (err) {\n      logger.error(`  Failed to read Git tree:\\n${err.stderr}`);\n      return false;\n    }\n\n    if (!commitNeeded) {\n      logger.info('  No changes to commit after migration.');\n      return true;\n    } // Commit changes and abort on error.\n\n\n    try {\n      createCommit(message);\n    } catch (err) {\n      logger.error(`Failed to commit update (${message}):\\n${err.stderr}`);\n      return false;\n    } // Notify user of the commit.\n\n\n    const hash = findCurrentGitSha();\n    const shortMessage = message.split('\\n')[0];\n\n    if (hash) {\n      logger.info(`  Committed migration step (${getShortHash(hash)}): ${shortMessage}.`);\n    } else {\n      // Commit was successful, but reading the hash was not. Something weird happened,\n      // but nothing that would stop the update. Just log the weirdness and continue.\n      logger.info(`  Committed migration step: ${shortMessage}.`);\n      logger.warn('  Failed to look up hash of most recent commit, continuing anyways.');\n    }\n\n    return true;\n  }\n\n  checkCleanGit() {\n    try {\n      const topLevel = (0, child_process_1.execSync)('git rev-parse --show-toplevel', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n      const result = (0, child_process_1.execSync)('git status --porcelain', {\n        encoding: 'utf8',\n        stdio: 'pipe'\n      });\n\n      if (result.trim().length === 0) {\n        return true;\n      } // Only files inside the workspace root are relevant\n\n\n      for (const entry of result.split('\\n')) {\n        const relativeEntry = path.relative(path.resolve(this.context.root), path.resolve(topLevel.trim(), entry.slice(3).trim()));\n\n        if (!relativeEntry.startsWith('..') && !path.isAbsolute(relativeEntry)) {\n          return false;\n        }\n      }\n    } catch {}\n\n    return true;\n  }\n  /**\n   * Checks if the current installed CLI version is older or newer than a compatible version.\n   * @returns the version to install or null when there is no update to install.\n   */\n\n\n  checkCLIVersion(packagesToUpdate, verbose = false, next = false) {\n    var _this8 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        version\n      } = yield (0, package_metadata_1.fetchPackageManifest)(`@angular/cli@${_this8.getCLIUpdateRunnerVersion(packagesToUpdate, next)}`, _this8.context.logger, {\n        verbose,\n        usingYarn: _this8.context.packageManager.name === workspace_schema_1.PackageManager.Yarn\n      });\n      return version_1.VERSION.full === version ? null : version;\n    })();\n  }\n\n  getCLIUpdateRunnerVersion(packagesToUpdate, next) {\n    var _a, _b;\n\n    if (next) {\n      return 'next';\n    }\n\n    const updatingAngularPackage = packagesToUpdate === null || packagesToUpdate === void 0 ? void 0 : packagesToUpdate.find(r => ANGULAR_PACKAGES_REGEXP.test(r));\n\n    if (updatingAngularPackage) {\n      // If we are updating any Angular package we can update the CLI to the target version because\n      // migrations for @angular/core@13 can be executed using Angular/cli@13.\n      // This is same behaviour as `npx @angular/cli@13 update @angular/core@13`.\n      // `@angular/cli@13` -> ['', 'angular/cli', '13']\n      // `@angular/cli` -> ['', 'angular/cli']\n      const tempVersion = coerceVersionNumber(updatingAngularPackage.split('@')[2]);\n      return (_b = (_a = semver.parse(tempVersion)) === null || _a === void 0 ? void 0 : _a.major) !== null && _b !== void 0 ? _b : 'latest';\n    } // When not updating an Angular package we cannot determine which schematic runtime the migration should to be executed in.\n    // Typically, we can assume that the `@angular/cli` was updated previously.\n    // Example: Angular official packages are typically updated prior to NGRX etc...\n    // Therefore, we only update to the latest patch version of the installed major version of the Angular CLI.\n    // This is important because we might end up in a scenario where locally Angular v12 is installed, updating NGRX from 11 to 12.\n    // We end up using Angular ClI v13 to run the migrations if we run the migrations using the CLI installed major version + 1 logic.\n\n\n    return version_1.VERSION.major;\n  }\n\n  runTempBinary(packageName, args = []) {\n    var _this9 = this;\n\n    return _asyncToGenerator(function* () {\n      const {\n        success,\n        tempNodeModules\n      } = yield _this9.context.packageManager.installTemp(packageName);\n\n      if (!success) {\n        return 1;\n      } // Remove version/tag etc... from package name\n      // Ex: @angular/cli@latest -> @angular/cli\n\n\n      const packageNameNoVersion = packageName.substring(0, packageName.lastIndexOf('@'));\n      const pkgLocation = (0, path_1.join)(tempNodeModules, packageNameNoVersion);\n      const packageJsonPath = (0, path_1.join)(pkgLocation, 'package.json'); // Get a binary location for this package\n\n      let binPath;\n\n      if ((0, fs_1.existsSync)(packageJsonPath)) {\n        const content = yield fs_1.promises.readFile(packageJsonPath, 'utf-8');\n\n        if (content) {\n          const {\n            bin = {}\n          } = JSON.parse(content);\n          const binKeys = Object.keys(bin);\n\n          if (binKeys.length) {\n            binPath = (0, path_1.resolve)(pkgLocation, bin[binKeys[0]]);\n          }\n        }\n      }\n\n      if (!binPath) {\n        throw new Error(`Cannot locate bin for temporary package: ${packageNameNoVersion}.`);\n      }\n\n      const {\n        status,\n        error\n      } = (0, child_process_1.spawnSync)(process.execPath, [binPath, ...args], {\n        stdio: 'inherit',\n        env: { ...process.env,\n          NG_DISABLE_VERSION_CHECK: 'true',\n          NG_CLI_ANALYTICS: 'false'\n        }\n      });\n\n      if (status === null && error) {\n        throw error;\n      }\n\n      return status !== null && status !== void 0 ? status : 0;\n    })();\n  }\n\n  packageManagerForce(verbose) {\n    // npm 7+ can fail due to it incorrectly resolving peer dependencies that have valid SemVer\n    // ranges during an update. Update will set correct versions of dependencies within the\n    // package.json file. The force option is set to workaround these errors.\n    // Example error:\n    // npm ERR! Conflicting peer dependency: @angular/compiler-cli@14.0.0-rc.0\n    // npm ERR! node_modules/@angular/compiler-cli\n    // npm ERR!   peer @angular/compiler-cli@\"^14.0.0 || ^14.0.0-rc\" from @angular-devkit/build-angular@14.0.0-rc.0\n    // npm ERR!   node_modules/@angular-devkit/build-angular\n    // npm ERR!     dev @angular-devkit/build-angular@\"~14.0.0-rc.0\" from the root project\n    if (this.context.packageManager.name === workspace_schema_1.PackageManager.Npm && this.context.packageManager.version && semver.gte(this.context.packageManager.version, '7.0.0')) {\n      if (verbose) {\n        this.context.logger.info('NPM 7+ detected -- enabling force option for package installation');\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n}\n\nexports.UpdateCommandModule = UpdateCommandModule;\n/**\n * @return Whether or not the working directory has Git changes to commit.\n */\n\nfunction hasChangesToCommit() {\n  // List all modified files not covered by .gitignore.\n  // If any files are returned, then there must be something to commit.\n  return (0, child_process_1.execSync)('git ls-files -m -d -o --exclude-standard').toString() !== '';\n}\n/**\n * Precondition: Must have pending changes to commit, they do not need to be staged.\n * Postcondition: The Git working tree is committed and the repo is clean.\n * @param message The commit message to use.\n */\n\n\nfunction createCommit(message) {\n  // Stage entire working tree for commit.\n  (0, child_process_1.execSync)('git add -A', {\n    encoding: 'utf8',\n    stdio: 'pipe'\n  }); // Commit with the message passed via stdin to avoid bash escaping issues.\n\n  (0, child_process_1.execSync)('git commit --no-verify -F -', {\n    encoding: 'utf8',\n    stdio: 'pipe',\n    input: message\n  });\n}\n/**\n * @return The Git SHA hash of the HEAD commit. Returns null if unable to retrieve the hash.\n */\n\n\nfunction findCurrentGitSha() {\n  try {\n    return (0, child_process_1.execSync)('git rev-parse HEAD', {\n      encoding: 'utf8',\n      stdio: 'pipe'\n    }).trim();\n  } catch {\n    return null;\n  }\n}\n\nfunction getShortHash(commitHash) {\n  return commitHash.slice(0, 9);\n}\n\nfunction coerceVersionNumber(version) {\n  var _a;\n\n  if (!version) {\n    return undefined;\n  }\n\n  if (!/^\\d{1,30}\\.\\d{1,30}\\.\\d{1,30}/.test(version)) {\n    const match = version.match(/^\\d{1,30}(\\.\\d{1,30})*/);\n\n    if (!match) {\n      return undefined;\n    }\n\n    if (!match[1]) {\n      version = version.substring(0, match[0].length) + '.0.0' + version.substring(match[0].length);\n    } else if (!match[2]) {\n      version = version.substring(0, match[0].length) + '.0' + version.substring(match[0].length);\n    } else {\n      return undefined;\n    }\n  }\n\n  return (_a = semver.valid(version)) !== null && _a !== void 0 ? _a : undefined;\n}","map":null,"metadata":{},"sourceType":"script"}