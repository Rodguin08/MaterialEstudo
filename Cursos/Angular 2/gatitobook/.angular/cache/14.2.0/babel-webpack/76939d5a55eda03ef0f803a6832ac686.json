{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/Voluti/Desktop/Git/Cursos/Angular 2/gatitobook/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nconst Fetcher = require('./fetcher.js');\n\nconst FileFetcher = require('./file.js');\n\nconst RemoteFetcher = require('./remote.js');\n\nconst DirFetcher = require('./dir.js');\n\nconst hashre = /^[a-f0-9]{40}$/;\n\nconst git = require('@npmcli/git');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst npa = require('npm-package-arg');\n\nconst Minipass = require('minipass');\n\nconst cacache = require('cacache');\n\nconst log = require('proc-log');\n\nconst npm = require('./util/npm.js');\n\nconst _resolvedFromRepo = Symbol('_resolvedFromRepo');\n\nconst _resolvedFromHosted = Symbol('_resolvedFromHosted');\n\nconst _resolvedFromClone = Symbol('_resolvedFromClone');\n\nconst _tarballFromResolved = Symbol.for('pacote.Fetcher._tarballFromResolved');\n\nconst _addGitSha = Symbol('_addGitSha');\n\nconst addGitSha = require('./util/add-git-sha.js');\n\nconst _clone = Symbol('_clone');\n\nconst _cloneHosted = Symbol('_cloneHosted');\n\nconst _cloneRepo = Symbol('_cloneRepo');\n\nconst _setResolvedWithSha = Symbol('_setResolvedWithSha');\n\nconst _prepareDir = Symbol('_prepareDir');\n\nconst _readPackageJson = Symbol.for('package.Fetcher._readPackageJson'); // get the repository url.\n// prefer https if there's auth, since ssh will drop that.\n// otherwise, prefer ssh if available (more secure).\n// We have to add the git+ back because npa suppresses it.\n\n\nconst repoUrl = (h, opts) => h.sshurl && !(h.https && h.auth) && addGitPlus(h.sshurl(opts)) || h.https && addGitPlus(h.https(opts)); // add git+ to the url, but only one time.\n\n\nconst addGitPlus = url => url && `git+${url}`.replace(/^(git\\+)+/, 'git+');\n\nclass GitFetcher extends Fetcher {\n  constructor(spec, opts) {\n    super(spec, opts); // we never want to compare integrity for git dependencies: npm/rfcs#525\n\n    if (this.opts.integrity) {\n      delete this.opts.integrity;\n      log.warn(`skipping integrity check for git dependency ${this.spec.fetchSpec}`);\n    }\n\n    this.resolvedRef = null;\n\n    if (this.spec.hosted) {\n      this.from = this.spec.hosted.shortcut({\n        noCommittish: false\n      });\n    } // shortcut: avoid full clone when we can go straight to the tgz\n    // if we have the full sha and it's a hosted git platform\n\n\n    if (this.spec.gitCommittish && hashre.test(this.spec.gitCommittish)) {\n      this.resolvedSha = this.spec.gitCommittish; // use hosted.tarball() when we shell to RemoteFetcher later\n\n      this.resolved = this.spec.hosted ? repoUrl(this.spec.hosted, {\n        noCommittish: false\n      }) : this.spec.rawSpec;\n    } else {\n      this.resolvedSha = '';\n    }\n  } // just exposed to make it easier to test all the combinations\n\n\n  static repoUrl(hosted, opts) {\n    return repoUrl(hosted, opts);\n  }\n\n  get types() {\n    return ['git'];\n  }\n\n  resolve() {\n    // likely a hosted git repo with a sha, so get the tarball url\n    // but in general, no reason to resolve() more than necessary!\n    if (this.resolved) {\n      return super.resolve();\n    } // fetch the git repo and then look at the current hash\n\n\n    const h = this.spec.hosted; // try to use ssh, fall back to git.\n\n    return h ? this[_resolvedFromHosted](h) : this[_resolvedFromRepo](this.spec.fetchSpec);\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_resolvedFromHosted](hosted) {\n    return this[_resolvedFromRepo](hosted.https && hosted.https()).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n\n      const ssh = hosted.sshurl && hosted.sshurl(); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n\n      return this[_resolvedFromRepo](ssh);\n    });\n  }\n\n  [_resolvedFromRepo](gitRemote) {\n    // XXX make this a custom error class\n    if (!gitRemote) {\n      return Promise.reject(new Error(`No git url for ${this.spec}`));\n    }\n\n    const gitRange = this.spec.gitRange;\n    const name = this.spec.name;\n    return git.revs(gitRemote, this.opts).then(remoteRefs => {\n      return gitRange ? pickManifest({\n        versions: remoteRefs.versions,\n        'dist-tags': remoteRefs['dist-tags'],\n        name\n      }, gitRange, this.opts) : this.spec.gitCommittish ? remoteRefs.refs[this.spec.gitCommittish] || remoteRefs.refs[remoteRefs.shas[this.spec.gitCommittish]] : remoteRefs.refs.HEAD; // no git committish, get default head\n    }).then(revDoc => {\n      // the committish provided isn't in the rev list\n      // things like HEAD~3 or @yesterday can land here.\n      if (!revDoc || !revDoc.sha) {\n        return this[_resolvedFromClone]();\n      }\n\n      this.resolvedRef = revDoc;\n      this.resolvedSha = revDoc.sha;\n\n      this[_addGitSha](revDoc.sha);\n\n      return this.resolved;\n    });\n  }\n\n  [_setResolvedWithSha](withSha) {\n    // we haven't cloned, so a tgz download is still faster\n    // of course, if it's not a known host, we can't do that.\n    this.resolved = !this.spec.hosted ? withSha : repoUrl(npa(withSha).hosted, {\n      noCommittish: false\n    });\n  } // when we get the git sha, we affix it to our spec to build up\n  // either a git url with a hash, or a tarball download URL\n\n\n  [_addGitSha](sha) {\n    this[_setResolvedWithSha](addGitSha(this.spec, sha));\n  }\n\n  [_resolvedFromClone]() {\n    // do a full or shallow clone, then look at the HEAD\n    // kind of wasteful, but no other option, really\n    return this[_clone](dir => this.resolved);\n  }\n\n  [_prepareDir](dir) {\n    return this[_readPackageJson](dir + '/package.json').then(mani => {\n      // no need if we aren't going to do any preparation.\n      const scripts = mani.scripts;\n\n      if (!mani.workspaces && (!scripts || !(scripts.postinstall || scripts.build || scripts.preinstall || scripts.install || scripts.prepack || scripts.prepare))) {\n        return;\n      } // to avoid cases where we have an cycle of git deps that depend\n      // on one another, we only ever do preparation for one instance\n      // of a given git dep along the chain of installations.\n      // Note that this does mean that a dependency MAY in theory end up\n      // trying to run its prepare script using a dependency that has not\n      // been properly prepared itself, but that edge case is smaller\n      // and less hazardous than a fork bomb of npm and git commands.\n\n\n      const noPrepare = !process.env._PACOTE_NO_PREPARE_ ? [] : process.env._PACOTE_NO_PREPARE_.split('\\n');\n\n      if (noPrepare.includes(this.resolved)) {\n        log.info('prepare', 'skip prepare, already seen', this.resolved);\n        return;\n      }\n\n      noPrepare.push(this.resolved); // the DirFetcher will do its own preparation to run the prepare scripts\n      // All we have to do is put the deps in place so that it can succeed.\n\n      return npm(this.npmBin, [].concat(this.npmInstallCmd).concat(this.npmCliConfig), dir, { ...process.env,\n        _PACOTE_NO_PREPARE_: noPrepare.join('\\n')\n      }, {\n        message: 'git dep preparation failed'\n      });\n    });\n  }\n\n  [_tarballFromResolved]() {\n    const stream = new Minipass();\n    stream.resolved = this.resolved;\n    stream.from = this.from; // check it out and then shell out to the DirFetcher tarball packer\n\n    this[_clone](dir => this[_prepareDir](dir).then(() => new Promise((res, rej) => {\n      const df = new DirFetcher(`file:${dir}`, { ...this.opts,\n        resolved: null,\n        integrity: null\n      });\n\n      const dirStream = df[_tarballFromResolved]();\n\n      dirStream.on('error', rej);\n      dirStream.on('end', res);\n      dirStream.pipe(stream);\n    }))).catch(\n    /* istanbul ignore next: very unlikely and hard to test */\n    er => stream.emit('error', er));\n\n    return stream;\n  } // clone a git repo into a temp folder (or fetch and unpack if possible)\n  // handler accepts a directory, and returns a promise that resolves\n  // when we're done with it, at which point, cacache deletes it\n  //\n  // TODO: after cloning, create a tarball of the folder, and add to the cache\n  // with cacache.put.stream(), using a key that's deterministic based on the\n  // spec and repo, so that we don't ever clone the same thing multiple times.\n\n\n  [_clone](handler, tarballOk = true) {\n    var _this = this;\n\n    const o = {\n      tmpPrefix: 'git-clone'\n    };\n    const ref = this.resolvedSha || this.spec.gitCommittish;\n    const h = this.spec.hosted;\n    const resolved = this.resolved; // can be set manually to false to fall back to actual git clone\n\n    tarballOk = tarballOk && h && resolved === repoUrl(h, {\n      noCommittish: false\n    }) && h.tarball;\n    return cacache.tmp.withTmp(this.cache, o, /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (tmp) {\n        // if we're resolved, and have a tarball url, shell out to RemoteFetcher\n        if (tarballOk) {\n          const nameat = _this.spec.name ? `${_this.spec.name}@` : '';\n          return new RemoteFetcher(h.tarball({\n            noCommittish: false\n          }), { ..._this.opts,\n            allowGitIgnore: true,\n            pkgid: `git:${nameat}${_this.resolved}`,\n            resolved: _this.resolved,\n            integrity: null // it'll always be different, if we have one\n\n          }).extract(tmp).then(() => handler(tmp), er => {\n            // fall back to ssh download if tarball fails\n            if (er.constructor.name.match(/^Http/)) {\n              return _this[_clone](handler, false);\n            } else {\n              throw er;\n            }\n          });\n        }\n\n        const sha = yield h ? _this[_cloneHosted](ref, tmp) : _this[_cloneRepo](_this.spec.fetchSpec, ref, tmp);\n        _this.resolvedSha = sha;\n\n        if (!_this.resolved) {\n          yield _this[_addGitSha](sha);\n        }\n\n        return handler(tmp);\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  } // first try https, since that's faster and passphrase-less for\n  // public repos, and supports private repos when auth is provided.\n  // Fall back to SSH to support private repos\n  // NB: we always store the https url in resolved field if auth\n  // is present, otherwise ssh if the hosted type provides it\n\n\n  [_cloneHosted](ref, tmp) {\n    const hosted = this.spec.hosted;\n    return this[_cloneRepo](hosted.https({\n      noCommittish: true\n    }), ref, tmp).catch(er => {\n      // Throw early since we know pathspec errors will fail again if retried\n      if (er instanceof git.errors.GitPathspecError) {\n        throw er;\n      }\n\n      const ssh = hosted.sshurl && hosted.sshurl({\n        noCommittish: true\n      }); // no fallthrough if we can't fall through or have https auth\n\n      if (!ssh || hosted.auth) {\n        throw er;\n      }\n\n      return this[_cloneRepo](ssh, ref, tmp);\n    });\n  }\n\n  [_cloneRepo](repo, ref, tmp) {\n    const {\n      opts,\n      spec\n    } = this;\n    return git.clone(repo, ref, tmp, { ...opts,\n      spec\n    });\n  }\n\n  manifest() {\n    if (this.package) {\n      return Promise.resolve(this.package);\n    }\n\n    return this.spec.hosted && this.resolved ? FileFetcher.prototype.manifest.apply(this) : this[_clone](dir => this[_readPackageJson](dir + '/package.json').then(mani => this.package = { ...mani,\n      _resolved: this.resolved,\n      _from: this.from\n    }));\n  }\n\n  packument() {\n    return FileFetcher.prototype.packument.apply(this);\n  }\n\n}\n\nmodule.exports = GitFetcher;","map":null,"metadata":{},"sourceType":"script"}