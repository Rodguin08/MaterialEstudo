{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.strategy = void 0;\n\nconst rxjs_1 = require(\"rxjs\");\n\nconst operators_1 = require(\"rxjs/operators\");\n\nconst json_1 = require(\"../../json\");\n\nconst api_1 = require(\"./api\"); // eslint-disable-next-line @typescript-eslint/no-namespace\n\n\nvar strategy;\n\n(function (strategy) {\n  /**\n   * Creates a JobStrategy that serializes every call. This strategy can be mixed between jobs.\n   */\n  function serialize() {\n    let latest = (0, rxjs_1.of)();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const previous = latest;\n        latest = (0, rxjs_1.concat)(previous.pipe((0, operators_1.ignoreElements)()), new rxjs_1.Observable(o => handler(argument, context).subscribe(o))).pipe((0, operators_1.shareReplay)(0));\n        return latest;\n      };\n\n      return Object.assign(newHandler, {\n        jobDescription: Object.assign({}, handler.jobDescription, options)\n      });\n    };\n  }\n\n  strategy.serialize = serialize;\n  /**\n   * Creates a JobStrategy that will always reuse a running job, and restart it if the job ended.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n\n  function reuse(replayMessages = false) {\n    let inboundBus = new rxjs_1.Subject();\n    let run = null;\n    let state = null;\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        // Forward inputs.\n        const subscription = context.inboundBus.subscribe(inboundBus);\n\n        if (run) {\n          return (0, rxjs_1.concat)( // Update state.\n          (0, rxjs_1.of)(state), run).pipe((0, operators_1.finalize)(() => subscription.unsubscribe()));\n        }\n\n        run = handler(argument, { ...context,\n          inboundBus: inboundBus.asObservable()\n        }).pipe((0, operators_1.tap)(message => {\n          if (message.kind == api_1.JobOutboundMessageKind.Start || message.kind == api_1.JobOutboundMessageKind.OnReady || message.kind == api_1.JobOutboundMessageKind.End) {\n            state = message;\n          }\n        }, undefined, () => {\n          subscription.unsubscribe();\n          inboundBus = new rxjs_1.Subject();\n          run = null;\n        }), replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        return run;\n      };\n\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n\n  strategy.reuse = reuse;\n  /**\n   * Creates a JobStrategy that will reuse a running job if the argument matches.\n   * @param replayMessages Replay ALL messages if a job is reused, otherwise just hook up where it\n   * is.\n   */\n\n  function memoize(replayMessages = false) {\n    const runs = new Map();\n    return (handler, options) => {\n      const newHandler = (argument, context) => {\n        const argumentJson = JSON.stringify((0, json_1.isJsonObject)(argument) ? Object.keys(argument).sort().reduce((result, key) => {\n          result[key] = argument[key];\n          return result;\n        }, {}) : argument);\n        const maybeJob = runs.get(argumentJson);\n\n        if (maybeJob) {\n          return maybeJob;\n        }\n\n        const run = handler(argument, context).pipe(replayMessages ? (0, operators_1.shareReplay)() : (0, operators_1.share)());\n        runs.set(argumentJson, run);\n        return run;\n      };\n\n      return Object.assign(newHandler, handler, options || {});\n    };\n  }\n\n  strategy.memoize = memoize;\n})(strategy = exports.strategy || (exports.strategy = {}));","map":null,"metadata":{},"sourceType":"script"}