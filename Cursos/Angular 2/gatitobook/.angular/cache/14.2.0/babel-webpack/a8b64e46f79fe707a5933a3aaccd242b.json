{"ast":null,"code":"\"use strict\";\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar _a;\n\n/*#__PURE__*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SchematicEngineHost = void 0;\n\nconst schematics_1 = /*#__PURE__*/require(\"@angular-devkit/schematics\");\n\nconst tools_1 = /*#__PURE__*/require(\"@angular-devkit/schematics/tools\");\n\nconst fs_1 = /*#__PURE__*/require(\"fs\");\n\nconst jsonc_parser_1 = /*#__PURE__*/require(\"jsonc-parser\");\n\nconst module_1 = __importDefault( /*#__PURE__*/require(\"module\"));\n\nconst path_1 = /*#__PURE__*/require(\"path\");\n\nconst vm_1 = /*#__PURE__*/require(\"vm\");\n\nconst error_1 = /*#__PURE__*/require(\"../../utilities/error\");\n/**\n * Environment variable to control schematic package redirection\n */\n\n\nconst schematicRedirectVariable = (_a = process.env['NG_SCHEMATIC_REDIRECT']) === null || _a === void 0 ? void 0 : /*#__PURE__*/_a.toLowerCase();\n\nfunction shouldWrapSchematic(schematicFile, schematicEncapsulation) {\n  // Check environment variable if present\n  switch (schematicRedirectVariable) {\n    case '0':\n    case 'false':\n    case 'off':\n    case 'none':\n      return false;\n\n    case 'all':\n      return true;\n  }\n\n  const normalizedSchematicFile = schematicFile.replace(/\\\\/g, '/'); // Never wrap the internal update schematic when executed directly\n  // It communicates with the update command via `global`\n  // But we still want to redirect schematics located in `@angular/cli/node_modules`.\n\n  if (normalizedSchematicFile.includes('node_modules/@angular/cli/') && !normalizedSchematicFile.includes('node_modules/@angular/cli/node_modules/')) {\n    return false;\n  } // Check for first-party Angular schematic packages\n  // Angular schematics are safe to use in the wrapped VM context\n\n\n  if (/\\/node_modules\\/@(?:angular|schematics|nguniversal)\\//.test(normalizedSchematicFile)) {\n    return true;\n  } // Otherwise use the value of the schematic collection's encapsulation option (current default of false)\n\n\n  return schematicEncapsulation;\n}\n\nclass SchematicEngineHost extends tools_1.NodeModulesEngineHost {\n  _resolveReferenceString(refString, parentPath, collectionDescription) {\n    const [path, name] = refString.split('#', 2); // Mimic behavior of ExportStringRef class used in default behavior\n\n    const fullPath = path[0] === '.' ? (0, path_1.resolve)(parentPath !== null && parentPath !== void 0 ? parentPath : process.cwd(), path) : path;\n\n    const schematicFile = require.resolve(fullPath, {\n      paths: [parentPath]\n    });\n\n    if (shouldWrapSchematic(schematicFile, !!(collectionDescription === null || collectionDescription === void 0 ? void 0 : collectionDescription.encapsulation))) {\n      const schematicPath = (0, path_1.dirname)(schematicFile);\n      const moduleCache = new Map();\n      const factoryInitializer = wrap(schematicFile, schematicPath, moduleCache, name || 'default');\n      const factory = factoryInitializer();\n\n      if (!factory || typeof factory !== 'function') {\n        return null;\n      }\n\n      return {\n        ref: factory,\n        path: schematicPath\n      };\n    } // All other schematics use default behavior\n\n\n    return super._resolveReferenceString(refString, parentPath, collectionDescription);\n  }\n\n}\n\nexports.SchematicEngineHost = SchematicEngineHost;\n/**\n * Minimal shim modules for legacy deep imports of `@schematics/angular`\n */\n\nconst legacyModules = {\n  '@schematics/angular/utility/config': {\n    getWorkspace(host) {\n      const path = '/.angular.json';\n      const data = host.read(path);\n\n      if (!data) {\n        throw new schematics_1.SchematicsException(`Could not find (${path})`);\n      }\n\n      return (0, jsonc_parser_1.parse)(data.toString(), [], {\n        allowTrailingComma: true\n      });\n    }\n\n  },\n  '@schematics/angular/utility/project': {\n    buildDefaultPath(project) {\n      const root = project.sourceRoot ? `/${project.sourceRoot}/` : `/${project.root}/src/`;\n      return `${root}${project.projectType === 'application' ? 'app' : 'lib'}`;\n    }\n\n  }\n};\n/**\n * Wrap a JavaScript file in a VM context to allow specific Angular dependencies to be redirected.\n * This VM setup is ONLY intended to redirect dependencies.\n *\n * @param schematicFile A JavaScript schematic file path that should be wrapped.\n * @param schematicDirectory A directory that will be used as the location of the JavaScript file.\n * @param moduleCache A map to use for caching repeat module usage and proper `instanceof` support.\n * @param exportName An optional name of a specific export to return. Otherwise, return all exports.\n */\n\nfunction wrap(schematicFile, schematicDirectory, moduleCache, exportName) {\n  const hostRequire = module_1.default.createRequire(__filename);\n  const schematicRequire = module_1.default.createRequire(schematicFile);\n\n  const customRequire = function (id) {\n    if (legacyModules[id]) {\n      // Provide compatibility modules for older versions of @angular/cdk\n      return legacyModules[id];\n    } else if (id.startsWith('schematics:')) {\n      // Schematics built-in modules use the `schematics` scheme (similar to the Node.js `node` scheme)\n      const builtinId = id.slice(11);\n      const builtinModule = loadBuiltinModule(builtinId);\n\n      if (!builtinModule) {\n        throw new Error(`Unknown schematics built-in module '${id}' requested from schematic '${schematicFile}'`);\n      }\n\n      return builtinModule;\n    } else if (id.startsWith('@angular-devkit/') || id.startsWith('@schematics/')) {\n      // Files should not redirect `@angular/core` and instead use the direct\n      // dependency if available. This allows old major version migrations to continue to function\n      // even though the latest major version may have breaking changes in `@angular/core`.\n      if (id.startsWith('@angular-devkit/core')) {\n        try {\n          return schematicRequire(id);\n        } catch (e) {\n          (0, error_1.assertIsError)(e);\n\n          if (e.code !== 'MODULE_NOT_FOUND') {\n            throw e;\n          }\n        }\n      } // Resolve from inside the `@angular/cli` project\n\n\n      return hostRequire(id);\n    } else if (id.startsWith('.') || id.startsWith('@angular/cdk')) {\n      // Wrap relative files inside the schematic collection\n      // Also wrap `@angular/cdk`, it contains helper utilities that import core schematic packages\n      // Resolve from the original file\n      const modulePath = schematicRequire.resolve(id); // Use cached module if available\n\n      const cachedModule = moduleCache.get(modulePath);\n\n      if (cachedModule) {\n        return cachedModule;\n      } // Do not wrap vendored third-party packages or JSON files\n\n\n      if (!/[/\\\\]node_modules[/\\\\]@schematics[/\\\\]angular[/\\\\]third_party[/\\\\]/.test(modulePath) && !modulePath.endsWith('.json')) {\n        // Wrap module and save in cache\n        const wrappedModule = wrap(modulePath, (0, path_1.dirname)(modulePath), moduleCache)();\n        moduleCache.set(modulePath, wrappedModule);\n        return wrappedModule;\n      }\n    } // All others are required directly from the original file\n\n\n    return schematicRequire(id);\n  }; // Setup a wrapper function to capture the module's exports\n\n\n  const schematicCode = (0, fs_1.readFileSync)(schematicFile, 'utf8'); // `module` is required due to @angular/localize ng-add being in UMD format\n\n  const headerCode = '(function() {\\nvar exports = {};\\nvar module = { exports };\\n';\n  const footerCode = exportName ? `\\nreturn module.exports['${exportName}'];});` : '\\nreturn module.exports;});';\n  const script = new vm_1.Script(headerCode + schematicCode + footerCode, {\n    filename: schematicFile,\n    lineOffset: 3\n  });\n  const context = {\n    __dirname: schematicDirectory,\n    __filename: schematicFile,\n    Buffer,\n    console,\n    process,\n\n    get global() {\n      return this;\n    },\n\n    require: customRequire\n  };\n  const exportsFactory = script.runInNewContext(context);\n  return exportsFactory;\n}\n\nfunction loadBuiltinModule(id) {\n  return undefined;\n}","map":null,"metadata":{},"sourceType":"script"}